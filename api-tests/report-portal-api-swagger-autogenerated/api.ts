// tslint:disable
// @ts-nocheck
/**
 * Report Portal
 * Report Portal API documentation
 *
 * OpenAPI spec version: 5.11.0
 * Contact: Support Report Portal <support@reportportal.io>
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as portableFetch from "node-fetch";
import * as url from "url";
import {Configuration} from "./configuration";

const BASE_PATH = "https://demo.reportportal.io/api".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration?: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name = "RequiredError"

    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 *
 * @export
 * @interface ActivityEventResource
 */
export interface ActivityEventResource {
    /**
     *
     * @type {string}
     * @memberof ActivityEventResource
     */
    createdAt?: string;
    /**
     *
     * @type {any}
     * @memberof ActivityEventResource
     */
    details?: any;
    /**
     *
     * @type {string}
     * @memberof ActivityEventResource
     */
    eventName: string;
    /**
     *
     * @type {number}
     * @memberof ActivityEventResource
     */
    id: number;
    /**
     *
     * @type {number}
     * @memberof ActivityEventResource
     */
    objectId: number;
    /**
     *
     * @type {string}
     * @memberof ActivityEventResource
     */
    objectName: string;
    /**
     *
     * @type {string}
     * @memberof ActivityEventResource
     */
    objectType: string;
    /**
     *
     * @type {number}
     * @memberof ActivityEventResource
     */
    projectId: number;
    /**
     *
     * @type {string}
     * @memberof ActivityEventResource
     */
    projectName: string;
    /**
     *
     * @type {string}
     * @memberof ActivityEventResource
     */
    subjectId: string;
    /**
     *
     * @type {string}
     * @memberof ActivityEventResource
     */
    subjectName: string;
    /**
     *
     * @type {string}
     * @memberof ActivityEventResource
     */
    subjectType: string;
}

/**
 *
 * @export
 * @interface ActivityResource
 */
export interface ActivityResource {
    /**
     *
     * @type {string}
     * @memberof ActivityResource
     */
    actionType: string;
    /**
     *
     * @type {any}
     * @memberof ActivityResource
     */
    details?: any;
    /**
     *
     * @type {number}
     * @memberof ActivityResource
     */
    id: number;
    /**
     *
     * @type {Date}
     * @memberof ActivityResource
     */
    lastModified: Date;
    /**
     *
     * @type {number}
     * @memberof ActivityResource
     */
    loggedObjectId: number;
    /**
     *
     * @type {string}
     * @memberof ActivityResource
     */
    objectName?: string;
    /**
     *
     * @type {string}
     * @memberof ActivityResource
     */
    objectType: string;
    /**
     *
     * @type {number}
     * @memberof ActivityResource
     */
    projectId: number;
    /**
     *
     * @type {string}
     * @memberof ActivityResource
     */
    projectName?: string;
    /**
     *
     * @type {string}
     * @memberof ActivityResource
     */
    user: string;
}

/**
 *
 * @export
 * @interface AddWidgetRq
 */
export interface AddWidgetRq {
    /**
     *
     * @type {WidgetObjectModel}
     * @memberof AddWidgetRq
     */
    addWidget?: WidgetObjectModel;
}

/**
 *
 * @export
 * @interface AllowedValue
 */
export interface AllowedValue {
    /**
     *
     * @type {string}
     * @memberof AllowedValue
     */
    valueId?: string;
    /**
     *
     * @type {string}
     * @memberof AllowedValue
     */
    valueName?: string;
}

/**
 *
 * @export
 * @interface AnalyticsResource
 */
export interface AnalyticsResource {
    /**
     *
     * @type {boolean}
     * @memberof AnalyticsResource
     */
    enabled?: boolean;
    /**
     *
     * @type {string}
     * @memberof AnalyticsResource
     */
    type?: string;
}

/**
 *
 * @export
 * @interface AnalyzeLaunchRQ
 */
export interface AnalyzeLaunchRQ {
    /**
     *
     * @type {Array<string>}
     * @memberof AnalyzeLaunchRQ
     */
    analyzeItemsMode?: Array<AnalyzeLaunchRQ.AnalyzeItemsModeEnum>;
    /**
     *
     * @type {string}
     * @memberof AnalyzeLaunchRQ
     */
    analyzerMode?: AnalyzeLaunchRQ.AnalyzerModeEnum;
    /**
     *
     * @type {string}
     * @memberof AnalyzeLaunchRQ
     */
    analyzerTypeName?: AnalyzeLaunchRQ.AnalyzerTypeNameEnum;
    /**
     *
     * @type {number}
     * @memberof AnalyzeLaunchRQ
     */
    launchId?: number;
}

/**
 * @export
 * @namespace AnalyzeLaunchRQ
 */
export namespace AnalyzeLaunchRQ {
    /**
     * @export
     * @enum {string}
     */
    export enum AnalyzeItemsModeEnum {
        TOINVESTIGATE = <any>'TO_INVESTIGATE',
        AUTOANALYZED = <any>'AUTO_ANALYZED',
        MANUALLYANALYZED = <any>'MANUALLY_ANALYZED'
    }

    /**
     * @export
     * @enum {string}
     */
    export enum AnalyzerModeEnum {
        ALL = <any>'ALL',
        LAUNCHNAME = <any>'LAUNCH_NAME',
        CURRENTLAUNCH = <any>'CURRENT_LAUNCH',
        PREVIOUSLAUNCH = <any>'PREVIOUS_LAUNCH',
        CURRENTANDTHESAMENAME = <any>'CURRENT_AND_THE_SAME_NAME'
    }

    /**
     * @export
     * @enum {string}
     */
    export enum AnalyzerTypeNameEnum {
        AutoAnalyzer = <any>'autoAnalyzer',
        PatternAnalyzer = <any>'patternAnalyzer'
    }
}

/**
 *
 * @export
 * @interface ApiKeyRQ
 */
export interface ApiKeyRQ {
    /**
     *
     * @type {string}
     * @memberof ApiKeyRQ
     */
    name: string;
}

/**
 *
 * @export
 * @interface ApiKeyRS
 */
export interface ApiKeyRS {
    /**
     *
     * @type {string}
     * @memberof ApiKeyRS
     */
    apiKey?: string;
    /**
     *
     * @type {string}
     * @memberof ApiKeyRS
     */
    createdAt?: string;
    /**
     *
     * @type {number}
     * @memberof ApiKeyRS
     */
    id: number;
    /**
     *
     * @type {string}
     * @memberof ApiKeyRS
     */
    lastUsedAt?: string;
    /**
     *
     * @type {string}
     * @memberof ApiKeyRS
     */
    name: string;
    /**
     *
     * @type {number}
     * @memberof ApiKeyRS
     */
    userId: number;
}

/**
 *
 * @export
 * @interface ApiKeysRS
 */
export interface ApiKeysRS {
    /**
     *
     * @type {Array<ApiKeyRS>}
     * @memberof ApiKeysRS
     */
    items: Array<ApiKeyRS>;
}

/**
 *
 * @export
 * @interface AssignUsersRQ
 */
export interface AssignUsersRQ {
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof AssignUsersRQ
     */
    userNames: { [key: string]: string; };
}

/**
 *
 * @export
 * @interface AssignedProject
 */
export interface AssignedProject {
    /**
     *
     * @type {string}
     * @memberof AssignedProject
     */
    entryType?: string;
    /**
     *
     * @type {string}
     * @memberof AssignedProject
     */
    projectRole?: string;
}

/**
 *
 * @export
 * @interface BatchElementCreatedRS
 */
export interface BatchElementCreatedRS {
    /**
     *
     * @type {string}
     * @memberof BatchElementCreatedRS
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof BatchElementCreatedRS
     */
    message?: string;
    /**
     *
     * @type {string}
     * @memberof BatchElementCreatedRS
     */
    stackTrace?: string;
}

/**
 *
 * @export
 * @interface BatchSaveOperatingRS
 */
export interface BatchSaveOperatingRS {
    /**
     *
     * @type {Array<BatchElementCreatedRS>}
     * @memberof BatchSaveOperatingRS
     */
    responses?: Array<BatchElementCreatedRS>;
}

/**
 *
 * @export
 * @interface BinaryContent
 */
export interface BinaryContent {
    /**
     *
     * @type {string}
     * @memberof BinaryContent
     */
    contentType: string;
    /**
     *
     * @type {string}
     * @memberof BinaryContent
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof BinaryContent
     */
    thumbnailId: string;
}

/**
 *
 * @export
 * @interface BulkInfoUpdateRQ
 */
export interface BulkInfoUpdateRQ {
    /**
     *
     * @type {Array<UpdateItemAttributeRQ>}
     * @memberof BulkInfoUpdateRQ
     */
    attributes?: Array<UpdateItemAttributeRQ>;
    /**
     *
     * @type {Description}
     * @memberof BulkInfoUpdateRQ
     */
    description?: Description;
    /**
     *
     * @type {Array<number>}
     * @memberof BulkInfoUpdateRQ
     */
    ids?: Array<number>;
}

/**
 *
 * @export
 * @interface BulkRQlongFinishExecutionRQ
 */
export interface BulkRQlongFinishExecutionRQ {
    /**
     *
     * @type {{ [key: string]: FinishExecutionRQ; }}
     * @memberof BulkRQlongFinishExecutionRQ
     */
    entities: { [key: string]: FinishExecutionRQ; };
}

/**
 *
 * @export
 * @interface BulkRQlongUpdateLaunchRQ
 */
export interface BulkRQlongUpdateLaunchRQ {
    /**
     *
     * @type {{ [key: string]: UpdateLaunchRQ; }}
     * @memberof BulkRQlongUpdateLaunchRQ
     */
    entities: { [key: string]: UpdateLaunchRQ; };
}

/**
 *
 * @export
 * @interface BulkUpdateFilterRQ
 */
export interface BulkUpdateFilterRQ {
    /**
     *
     * @type {Array<UserFilterCondition>}
     * @memberof BulkUpdateFilterRQ
     */
    conditions: Array<UserFilterCondition>;
    /**
     *
     * @type {string}
     * @memberof BulkUpdateFilterRQ
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof BulkUpdateFilterRQ
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof BulkUpdateFilterRQ
     */
    name: string;
    /**
     *
     * @type {Array<Order>}
     * @memberof BulkUpdateFilterRQ
     */
    orders: Array<Order>;
    /**
     *
     * @type {string}
     * @memberof BulkUpdateFilterRQ
     */
    type: BulkUpdateFilterRQ.TypeEnum;
}

/**
 * @export
 * @namespace BulkUpdateFilterRQ
 */
export namespace BulkUpdateFilterRQ {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Launch = <any>'launch',
        Testitem = <any>'testitem',
        Log = <any>'log'
    }
}

/**
 *
 * @export
 * @interface ChangePasswordRQ
 */
export interface ChangePasswordRQ {
    /**
     *
     * @type {string}
     * @memberof ChangePasswordRQ
     */
    newPassword?: string;
    /**
     *
     * @type {string}
     * @memberof ChangePasswordRQ
     */
    oldPassword?: string;
}

/**
 *
 * @export
 * @interface ChartStatisticsContent
 */
export interface ChartStatisticsContent {
    /**
     *
     * @type {number}
     * @memberof ChartStatisticsContent
     */
    id?: number;
    /**
     *
     * @type {string}
     * @memberof ChartStatisticsContent
     */
    name?: string;
    /**
     *
     * @type {number}
     * @memberof ChartStatisticsContent
     */
    number?: number;
    /**
     *
     * @type {Timestamp}
     * @memberof ChartStatisticsContent
     */
    startTime?: Timestamp;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof ChartStatisticsContent
     */
    values?: { [key: string]: string; };
}

/**
 *
 * @export
 * @interface ClusterInfoResource
 */
export interface ClusterInfoResource {
    /**
     *
     * @type {number}
     * @memberof ClusterInfoResource
     */
    id?: number;
    /**
     *
     * @type {number}
     * @memberof ClusterInfoResource
     */
    index?: number;
    /**
     *
     * @type {number}
     * @memberof ClusterInfoResource
     */
    launchId?: number;
    /**
     *
     * @type {string}
     * @memberof ClusterInfoResource
     */
    message?: string;
    /**
     *
     * @type {any}
     * @memberof ClusterInfoResource
     */
    metadata?: any;
}

/**
 *
 * @export
 * @interface CollectionsRQBulkUpdateFilterRQ
 */
export interface CollectionsRQBulkUpdateFilterRQ {
    /**
     *
     * @type {Array<BulkUpdateFilterRQ>}
     * @memberof CollectionsRQBulkUpdateFilterRQ
     */
    elements: Array<BulkUpdateFilterRQ>;
}

/**
 *
 * @export
 * @interface ContentParameters
 */
export interface ContentParameters {
    /**
     *
     * @type {Array<string>}
     * @memberof ContentParameters
     */
    contentFields: Array<string>;
    /**
     *
     * @type {number}
     * @memberof ContentParameters
     */
    itemsCount: number;
    /**
     *
     * @type {any}
     * @memberof ContentParameters
     */
    widgetOptions?: any;
}

/**
 *
 * @export
 * @interface CreateClustersRQ
 */
export interface CreateClustersRQ {
    /**
     *
     * @type {number}
     * @memberof CreateClustersRQ
     */
    launchId: number;
    /**
     *
     * @type {boolean}
     * @memberof CreateClustersRQ
     */
    removeNumbers?: boolean;
}

/**
 *
 * @export
 * @interface CreateDashboardRQ
 */
export interface CreateDashboardRQ {
    /**
     *
     * @type {string}
     * @memberof CreateDashboardRQ
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof CreateDashboardRQ
     */
    name: string;
}

/**
 *
 * @export
 * @interface CreateIssueSubTypeRQ
 */
export interface CreateIssueSubTypeRQ {
    /**
     *
     * @type {string}
     * @memberof CreateIssueSubTypeRQ
     */
    color: string;
    /**
     *
     * @type {string}
     * @memberof CreateIssueSubTypeRQ
     */
    longName: string;
    /**
     *
     * @type {string}
     * @memberof CreateIssueSubTypeRQ
     */
    shortName: string;
    /**
     *
     * @type {string}
     * @memberof CreateIssueSubTypeRQ
     */
    typeRef: string;
}

/**
 *
 * @export
 * @interface CreatePatternTemplateRQ
 */
export interface CreatePatternTemplateRQ {
    /**
     *
     * @type {boolean}
     * @memberof CreatePatternTemplateRQ
     */
    enabled?: boolean;
    /**
     *
     * @type {string}
     * @memberof CreatePatternTemplateRQ
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof CreatePatternTemplateRQ
     */
    type?: string;
    /**
     *
     * @type {string}
     * @memberof CreatePatternTemplateRQ
     */
    value?: string;
}

/**
 *
 * @export
 * @interface CreateProjectRQ
 */
export interface CreateProjectRQ {
    /**
     *
     * @type {string}
     * @memberof CreateProjectRQ
     */
    entryType: CreateProjectRQ.EntryTypeEnum;
    /**
     *
     * @type {string}
     * @memberof CreateProjectRQ
     */
    projectName: string;
}

/**
 * @export
 * @namespace CreateProjectRQ
 */
export namespace CreateProjectRQ {
    /**
     * @export
     * @enum {string}
     */
    export enum EntryTypeEnum {
        INTERNAL = <any>'INTERNAL'
    }
}

/**
 *
 * @export
 * @interface CreateUserBidRS
 */
export interface CreateUserBidRS {
    /**
     *
     * @type {string}
     * @memberof CreateUserBidRS
     */
    backLink?: string;
    /**
     *
     * @type {string}
     * @memberof CreateUserBidRS
     */
    bid?: string;
    /**
     *
     * @type {string}
     * @memberof CreateUserBidRS
     */
    message?: string;
}

/**
 *
 * @export
 * @interface CreateUserRQ
 */
export interface CreateUserRQ {
    /**
     *
     * @type {string}
     * @memberof CreateUserRQ
     */
    defaultProject: string;
    /**
     *
     * @type {string}
     * @memberof CreateUserRQ
     */
    email: string;
    /**
     *
     * @type {string}
     * @memberof CreateUserRQ
     */
    role: string;
}

/**
 *
 * @export
 * @interface CreateUserRQConfirm
 */
export interface CreateUserRQConfirm {
    /**
     *
     * @type {string}
     * @memberof CreateUserRQConfirm
     */
    email: string;
    /**
     *
     * @type {string}
     * @memberof CreateUserRQConfirm
     */
    fullName: string;
    /**
     *
     * @type {string}
     * @memberof CreateUserRQConfirm
     */
    login: string;
    /**
     *
     * @type {string}
     * @memberof CreateUserRQConfirm
     */
    password: string;
}

/**
 *
 * @export
 * @interface CreateUserRQFull
 */
export interface CreateUserRQFull {
    /**
     *
     * @type {string}
     * @memberof CreateUserRQFull
     */
    accountRole: CreateUserRQFull.AccountRoleEnum;
    /**
     *
     * @type {string}
     * @memberof CreateUserRQFull
     */
    defaultProject: string;
    /**
     *
     * @type {string}
     * @memberof CreateUserRQFull
     */
    email: string;
    /**
     *
     * @type {string}
     * @memberof CreateUserRQFull
     */
    fullName: string;
    /**
     *
     * @type {string}
     * @memberof CreateUserRQFull
     */
    login: string;
    /**
     *
     * @type {string}
     * @memberof CreateUserRQFull
     */
    password: string;
    /**
     *
     * @type {string}
     * @memberof CreateUserRQFull
     */
    projectRole: CreateUserRQFull.ProjectRoleEnum;
}

/**
 * @export
 * @namespace CreateUserRQFull
 */
export namespace CreateUserRQFull {
    /**
     * @export
     * @enum {string}
     */
    export enum AccountRoleEnum {
        USER = <any>'USER',
        ADMINISTRATOR = <any>'ADMINISTRATOR'
    }

    /**
     * @export
     * @enum {string}
     */
    export enum ProjectRoleEnum {
        CUSTOMER = <any>'CUSTOMER',
        MEMBER = <any>'MEMBER',
        LEAD = <any>'LEAD',
        PROJECTMANAGER = <any>'PROJECT_MANAGER'
    }
}

/**
 *
 * @export
 * @interface CreateUserRS
 */
export interface CreateUserRS {
    /**
     *
     * @type {number}
     * @memberof CreateUserRS
     */
    id?: number;
    /**
     *
     * @type {string}
     * @memberof CreateUserRS
     */
    login?: string;
    /**
     *
     * @type {string}
     * @memberof CreateUserRS
     */
    warning?: string;
}

/**
 *
 * @export
 * @interface DashboardResource
 */
export interface DashboardResource {
    /**
     *
     * @type {string}
     * @memberof DashboardResource
     */
    description?: string;
    /**
     *
     * @type {number}
     * @memberof DashboardResource
     */
    id: number;
    /**
     *
     * @type {string}
     * @memberof DashboardResource
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof DashboardResource
     */
    owner?: string;
    /**
     *
     * @type {Array<WidgetObjectModel>}
     * @memberof DashboardResource
     */
    widgets?: Array<WidgetObjectModel>;
}

/**
 *
 * @export
 * @interface DefineIssueRQ
 */
export interface DefineIssueRQ {
    /**
     *
     * @type {Array<IssueDefinition>}
     * @memberof DefineIssueRQ
     */
    issues: Array<IssueDefinition>;
}

/**
 *
 * @export
 * @interface DeleteBulkRQ
 */
export interface DeleteBulkRQ {
    /**
     *
     * @type {Array<number>}
     * @memberof DeleteBulkRQ
     */
    ids?: Array<number>;
}

/**
 *
 * @export
 * @interface DeleteBulkRS
 */
export interface DeleteBulkRS {
    /**
     *
     * @type {Array<ErrorRS>}
     * @memberof DeleteBulkRS
     */
    errors?: Array<ErrorRS>;
    /**
     *
     * @type {Array<number>}
     * @memberof DeleteBulkRS
     */
    notFound?: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof DeleteBulkRS
     */
    successfullyDeleted?: Array<number>;
}

/**
 *
 * @export
 * @interface DemoDataRq
 */
export interface DemoDataRq {
    /**
     *
     * @type {boolean}
     * @memberof DemoDataRq
     */
    createDashboard?: boolean;
}

/**
 *
 * @export
 * @interface DemoDataRs
 */
export interface DemoDataRs {
    /**
     *
     * @type {number}
     * @memberof DemoDataRs
     */
    dashboardId?: number;
    /**
     *
     * @type {Array<number>}
     * @memberof DemoDataRs
     */
    launchIds?: Array<number>;
}

/**
 *
 * @export
 * @interface Description
 */
export interface Description {
    /**
     *
     * @type {string}
     * @memberof Description
     */
    action?: Description.ActionEnum;
    /**
     *
     * @type {string}
     * @memberof Description
     */
    comment?: string;
}

/**
 * @export
 * @namespace Description
 */
export namespace Description {
    /**
     * @export
     * @enum {string}
     */
    export enum ActionEnum {
        DELETE = <any>'DELETE',
        UPDATE = <any>'UPDATE',
        CREATE = <any>'CREATE'
    }
}

/**
 *
 * @export
 * @interface EditUserRQ
 */
export interface EditUserRQ {
    /**
     *
     * @type {string}
     * @memberof EditUserRQ
     */
    email?: string;
    /**
     *
     * @type {string}
     * @memberof EditUserRQ
     */
    fullName?: string;
    /**
     *
     * @type {string}
     * @memberof EditUserRQ
     */
    role?: string;
}

/**
 *
 * @export
 * @interface EntryCreatedAsyncRS
 */
export interface EntryCreatedAsyncRS {
    /**
     *
     * @type {string}
     * @memberof EntryCreatedAsyncRS
     */
    id?: string;
}

/**
 *
 * @export
 * @interface EntryCreatedRS
 */
export interface EntryCreatedRS {
    /**
     *
     * @type {number}
     * @memberof EntryCreatedRS
     */
    id?: number;
}

/**
 *
 * @export
 * @interface Entrylongint
 */
export interface Entrylongint {
    /**
     *
     * @type {number}
     * @memberof Entrylongint
     */
    key?: number;
    /**
     *
     * @type {number}
     * @memberof Entrylongint
     */
    value?: number;
}

/**
 *
 * @export
 * @interface ErrorRS
 */
export interface ErrorRS {
    /**
     *
     * @type {string}
     * @memberof ErrorRS
     */
    errorCode?: ErrorRS.ErrorCodeEnum;
    /**
     *
     * @type {string}
     * @memberof ErrorRS
     */
    message?: string;
    /**
     *
     * @type {string}
     * @memberof ErrorRS
     */
    stackTrace?: string;
}

/**
 * @export
 * @namespace ErrorRS
 */
export namespace ErrorRS {
    /**
     * @export
     * @enum {string}
     */
    export enum ErrorCodeEnum {
        INCORRECTREQUEST = <any>'INCORRECT_REQUEST',
        BINARYDATACANNOTBESAVED = <any>'BINARY_DATA_CANNOT_BE_SAVED',
        ACCESSDENIED = <any>'ACCESS_DENIED',
        ADDRESSLOCKED = <any>'ADDRESS_LOCKED',
        PROJECTNOTFOUND = <any>'PROJECT_NOT_FOUND',
        LAUNCHNOTFOUND = <any>'LAUNCH_NOT_FOUND',
        TESTSUITENOTFOUND = <any>'TEST_SUITE_NOT_FOUND',
        TESTITEMNOTFOUND = <any>'TEST_ITEM_NOT_FOUND',
        LOGNOTFOUND = <any>'LOG_NOT_FOUND',
        ROLENOTFOUND = <any>'ROLE_NOT_FOUND',
        USERNOTFOUND = <any>'USER_NOT_FOUND',
        WIDGETNOTFOUND = <any>'WIDGET_NOT_FOUND',
        WIDGETNOTFOUNDINDASHBOARD = <any>'WIDGET_NOT_FOUND_IN_DASHBOARD',
        DASHBOARDNOTFOUND = <any>'DASHBOARD_NOT_FOUND',
        USERFILTERNOTFOUND = <any>'USER_FILTER_NOT_FOUND',
        ACTIVITYNOTFOUND = <any>'ACTIVITY_NOT_FOUND',
        UNABLETOCREATEWIDGET = <any>'UNABLE_TO_CREATE_WIDGET',
        INTEGRATIONNOTFOUND = <any>'INTEGRATION_NOT_FOUND',
        PROJECTNOTCONFIGURED = <any>'PROJECT_NOT_CONFIGURED',
        SERVERSETTINGSNOTFOUND = <any>'SERVER_SETTINGS_NOT_FOUND',
        ISSUETYPENOTFOUND = <any>'ISSUE_TYPE_NOT_FOUND',
        PROJECTSETTINGSNOTFOUND = <any>'PROJECT_SETTINGS_NOT_FOUND',
        TICKETNOTFOUND = <any>'TICKET_NOT_FOUND',
        AUTHINTEGRATIONNOTFOUND = <any>'AUTH_INTEGRATION_NOT_FOUND',
        WIDGETNOTFOUNDINPROJECT = <any>'WIDGET_NOT_FOUND_IN_PROJECT',
        USERFILTERNOTFOUNDINPROJECT = <any>'USER_FILTER_NOT_FOUND_IN_PROJECT',
        DASHBOARDNOTFOUNDINPROJECT = <any>'DASHBOARD_NOT_FOUND_IN_PROJECT',
        PATTERNTEMPLATENOTFOUNDINPROJECT = <any>'PATTERN_TEMPLATE_NOT_FOUND_IN_PROJECT',
        TESTITEMORLAUNCHNOTFOUND = <any>'TEST_ITEM_OR_LAUNCH_NOT_FOUND',
        ANALYZERNOTFOUND = <any>'ANALYZER_NOT_FOUND',
        ATTACHMENTNOTFOUND = <any>'ATTACHMENT_NOT_FOUND',
        UNABLETOLOADBINARYDATA = <any>'UNABLE_TO_LOAD_BINARY_DATA',
        CLUSTERNOTFOUND = <any>'CLUSTER_NOT_FOUND',
        NOTFOUND = <any>'NOT_FOUND',
        INCORRECTFILTERPARAMETERS = <any>'INCORRECT_FILTER_PARAMETERS',
        INCORRECTSORTINGPARAMETERS = <any>'INCORRECT_SORTING_PARAMETERS',
        INCORRECTINTEGRATIONNAME = <any>'INCORRECT_INTEGRATION_NAME',
        UNABLEMODIFYSHARABLERESOURCE = <any>'UNABLE_MODIFY_SHARABLE_RESOURCE',
        INCORRECTAUTHENTICATIONTYPE = <any>'INCORRECT_AUTHENTICATION_TYPE',
        UNABLEPOSTTICKET = <any>'UNABLE_POST_TICKET',
        UNABLEINTERACTWITHINTEGRATION = <any>'UNABLE_INTERACT_WITH_INTEGRATION',
        UNABLEASSIGNUNASSIGNUSERTOPROJECT = <any>'UNABLE_ASSIGN_UNASSIGN_USER_TO_PROJECT',
        EMAILCONFIGURATIONISINCORRECT = <any>'EMAIL_CONFIGURATION_IS_INCORRECT',
        PROJECTUPDATENOTALLOWED = <any>'PROJECT_UPDATE_NOT_ALLOWED',
        UNABLETOUPDATEYOURSELFROLE = <any>'UNABLE_TO_UPDATE_YOURSELF_ROLE',
        FORBIDDENOPERATION = <any>'FORBIDDEN_OPERATION',
        RESOURCEALREADYEXISTS = <any>'RESOURCE_ALREADY_EXISTS',
        ROLEALREADYEXISTSERROR = <any>'ROLE_ALREADY_EXISTS_ERROR',
        USERALREADYEXISTS = <any>'USER_ALREADY_EXISTS',
        USERFILTERALREADYEXISTS = <any>'USER_FILTER_ALREADY_EXISTS',
        PROJECTALREADYEXISTS = <any>'PROJECT_ALREADY_EXISTS',
        DASHBOARDUPDATEERROR = <any>'DASHBOARD_UPDATE_ERROR',
        UNABLELOADWIDGETCONTENT = <any>'UNABLE_LOAD_WIDGET_CONTENT',
        UNABLEADDTOFAVORITE = <any>'UNABLE_ADD_TO_FAVORITE',
        INTEGRATIONALREADYEXISTS = <any>'INTEGRATION_ALREADY_EXISTS',
        SERVERSETTINGSALREADYEXISTS = <any>'SERVER_SETTINGS_ALREADY_EXISTS',
        UNABLEREMOVEFROMFAVORITE = <any>'UNABLE_REMOVE_FROM_FAVORITE',
        LAUNCHISNOTFINISHED = <any>'LAUNCH_IS_NOT_FINISHED',
        TESTITEMISNOTFINISHED = <any>'TEST_ITEM_IS_NOT_FINISHED',
        INCORRECTFINISHSTATUS = <any>'INCORRECT_FINISH_STATUS',
        BADREQUESTERROR = <any>'BAD_REQUEST_ERROR',
        BADSAVELOGREQUEST = <any>'BAD_SAVE_LOG_REQUEST',
        REPORTINGITEMALREADYFINISHED = <any>'REPORTING_ITEM_ALREADY_FINISHED',
        AMBIGUOUSTESTITEMSTATUS = <any>'AMBIGUOUS_TEST_ITEM_STATUS',
        FAILEDTESTITEMISSUETYPEDEFINITION = <any>'FAILED_TEST_ITEM_ISSUE_TYPE_DEFINITION',
        FINISHTIMEEARLIERTHANSTARTTIME = <any>'FINISH_TIME_EARLIER_THAN_START_TIME',
        FINISHITEMNOTALLOWED = <any>'FINISH_ITEM_NOT_ALLOWED',
        FINISHLAUNCHNOTALLOWED = <any>'FINISH_LAUNCH_NOT_ALLOWED',
        STARTITEMNOTALLOWED = <any>'START_ITEM_NOT_ALLOWED',
        CHILDSTARTTIMEEARLIERTHANPARENT = <any>'CHILD_START_TIME_EARLIER_THAN_PARENT',
        UNSUPPORTEDTESTITEMTYPE = <any>'UNSUPPORTED_TEST_ITEM_TYPE',
        LOGGINGISNOTALLOWED = <any>'LOGGING_IS_NOT_ALLOWED',
        BADSAVEWIDGETREQUEST = <any>'BAD_SAVE_WIDGET_REQUEST',
        BADUPDATEWIDGETREQUEST = <any>'BAD_UPDATE_WIDGET_REQUEST',
        UNABLELOADTESTITEMHISTORY = <any>'UNABLE_LOAD_TEST_ITEM_HISTORY',
        BADSAVEUSERFILTERREQUEST = <any>'BAD_SAVE_USER_FILTER_REQUEST',
        RETRIESHANDLERERROR = <any>'RETRIES_HANDLER_ERROR',
        IMPORTFILEERROR = <any>'IMPORT_FILE_ERROR',
        PARSINGXMLERROR = <any>'PARSING_XML_ERROR',
        OBJECTRETRIEVALERROR = <any>'OBJECT_RETRIEVAL_ERROR',
        PLUGINUPLOADERROR = <any>'PLUGIN_UPLOAD_ERROR',
        PLUGINREMOVEERROR = <any>'PLUGIN_REMOVE_ERROR',
        UNABLETOSAVECHILDITEMFORTHERETRY = <any>'UNABLE_TO_SAVE_CHILD_ITEM_FOR_THE_RETRY',
        PATTERNANALYSISERROR = <any>'PATTERN_ANALYSIS_ERROR',
        PROJECTDOESNTCONTAINUSER = <any>'PROJECT_DOESNT_CONTAIN_USER',
        UNCLASSIFIEDREPORTPORTALERROR = <any>'UNCLASSIFIED_REPORT_PORTAL_ERROR',
        BADUPDATEPREFERENCEREQUEST = <any>'BAD_UPDATE_PREFERENCE_REQUEST',
        UNSUPPORTEDMERGESTRATEGYTYPE = <any>'UNSUPPORTED_MERGE_STRATEGY_TYPE',
        DEMODATAGENERATIONERROR = <any>'DEMO_DATA_GENERATION_ERROR',
        UNCLASSIFIEDERROR = <any>'UNCLASSIFIED_ERROR'
    }
}

/**
 *
 * @export
 * @interface ExternalSystemIssue
 */
export interface ExternalSystemIssue {
    /**
     *
     * @type {string}
     * @memberof ExternalSystemIssue
     */
    btsProject?: string;
    /**
     *
     * @type {string}
     * @memberof ExternalSystemIssue
     */
    btsUrl?: string;
    /**
     *
     * @type {string}
     * @memberof ExternalSystemIssue
     */
    pluginName?: string;
    /**
     *
     * @type {number}
     * @memberof ExternalSystemIssue
     */
    submitDate?: number;
    /**
     *
     * @type {string}
     * @memberof ExternalSystemIssue
     */
    ticketId?: string;
    /**
     *
     * @type {string}
     * @memberof ExternalSystemIssue
     */
    url?: string;
}

/**
 *
 * @export
 * @interface FinishExecutionRQ
 */
export interface FinishExecutionRQ {
    /**
     *
     * @type {Array<ItemAttributesRQ>}
     * @memberof FinishExecutionRQ
     */
    attributes?: Array<ItemAttributesRQ>;
    /**
     *
     * @type {string}
     * @memberof FinishExecutionRQ
     */
    description?: string;
    /**
     *
     * @type {Date}
     * @memberof FinishExecutionRQ
     */
    endTime: Date;
    /**
     *
     * @type {string}
     * @memberof FinishExecutionRQ
     */
    status?: FinishExecutionRQ.StatusEnum;
}

/**
 * @export
 * @namespace FinishExecutionRQ
 */
export namespace FinishExecutionRQ {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        PASSED = <any>'PASSED',
        FAILED = <any>'FAILED',
        STOPPED = <any>'STOPPED',
        SKIPPED = <any>'SKIPPED',
        INTERRUPTED = <any>'INTERRUPTED',
        CANCELLED = <any>'CANCELLED',
        INFO = <any>'INFO',
        WARN = <any>'WARN'
    }
}

/**
 *
 * @export
 * @interface FinishLaunchRS
 */
export interface FinishLaunchRS {
    /**
     *
     * @type {string}
     * @memberof FinishLaunchRS
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof FinishLaunchRS
     */
    link?: string;
    /**
     *
     * @type {number}
     * @memberof FinishLaunchRS
     */
    number?: number;
}

/**
 *
 * @export
 * @interface FinishTestItemRQ
 */
export interface FinishTestItemRQ {
    /**
     *
     * @type {Array<ItemAttributesRQ>}
     * @memberof FinishTestItemRQ
     */
    attributes?: Array<ItemAttributesRQ>;
    /**
     *
     * @type {string}
     * @memberof FinishTestItemRQ
     */
    description?: string;
    /**
     *
     * @type {Date}
     * @memberof FinishTestItemRQ
     */
    endTime: Date;
    /**
     *
     * @type {Issue}
     * @memberof FinishTestItemRQ
     */
    issue?: Issue;
    /**
     *
     * @type {string}
     * @memberof FinishTestItemRQ
     */
    launchUuid: string;
    /**
     *
     * @type {boolean}
     * @memberof FinishTestItemRQ
     */
    retry?: boolean;
    /**
     *
     * @type {string}
     * @memberof FinishTestItemRQ
     */
    retryOf?: string;
    /**
     *
     * @type {string}
     * @memberof FinishTestItemRQ
     */
    status?: FinishTestItemRQ.StatusEnum;
    /**
     *
     * @type {string}
     * @memberof FinishTestItemRQ
     */
    testCaseId?: string;
}

/**
 * @export
 * @namespace FinishTestItemRQ
 */
export namespace FinishTestItemRQ {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        PASSED = <any>'PASSED',
        FAILED = <any>'FAILED',
        STOPPED = <any>'STOPPED',
        SKIPPED = <any>'SKIPPED',
        INTERRUPTED = <any>'INTERRUPTED',
        CANCELLED = <any>'CANCELLED',
        INFO = <any>'INFO',
        WARN = <any>'WARN'
    }
}

/**
 *
 * @export
 * @interface GetLogsUnderRq
 */
export interface GetLogsUnderRq {
    /**
     *
     * @type {Array<number>}
     * @memberof GetLogsUnderRq
     */
    itemIds?: Array<number>;
    /**
     *
     * @type {string}
     * @memberof GetLogsUnderRq
     */
    logLevel?: GetLogsUnderRq.LogLevelEnum;
}

/**
 * @export
 * @namespace GetLogsUnderRq
 */
export namespace GetLogsUnderRq {
    /**
     * @export
     * @enum {string}
     */
    export enum LogLevelEnum {
        Error = <any>'error',
        Warn = <any>'warn',
        Info = <any>'info',
        Debug = <any>'debug',
        Trace = <any>'trace',
        Fatal = <any>'fatal',
        Unknown = <any>'unknown'
    }
}

/**
 *
 * @export
 * @interface IntegrationRQ
 */
export interface IntegrationRQ {
    /**
     *
     * @type {boolean}
     * @memberof IntegrationRQ
     */
    enabled?: boolean;
    /**
     *
     * @type {any}
     * @memberof IntegrationRQ
     */
    integrationParameters?: any;
    /**
     *
     * @type {string}
     * @memberof IntegrationRQ
     */
    name?: string;
}

/**
 *
 * @export
 * @interface IntegrationResource
 */
export interface IntegrationResource {
    /**
     *
     * @type {Date}
     * @memberof IntegrationResource
     */
    creationDate?: Date;
    /**
     *
     * @type {string}
     * @memberof IntegrationResource
     */
    creator?: string;
    /**
     *
     * @type {boolean}
     * @memberof IntegrationResource
     */
    enabled?: boolean;
    /**
     *
     * @type {number}
     * @memberof IntegrationResource
     */
    id?: number;
    /**
     *
     * @type {any}
     * @memberof IntegrationResource
     */
    integrationParameters?: any;
    /**
     *
     * @type {IntegrationTypeResource}
     * @memberof IntegrationResource
     */
    integrationType?: IntegrationTypeResource;
    /**
     *
     * @type {string}
     * @memberof IntegrationResource
     */
    name?: string;
    /**
     *
     * @type {number}
     * @memberof IntegrationResource
     */
    projectId?: number;
}

/**
 *
 * @export
 * @interface IntegrationTypeResource
 */
export interface IntegrationTypeResource {
    /**
     *
     * @type {string}
     * @memberof IntegrationTypeResource
     */
    authFlow?: IntegrationTypeResource.AuthFlowEnum;
    /**
     *
     * @type {Date}
     * @memberof IntegrationTypeResource
     */
    creationDate?: Date;
    /**
     *
     * @type {any}
     * @memberof IntegrationTypeResource
     */
    details?: any;
    /**
     *
     * @type {boolean}
     * @memberof IntegrationTypeResource
     */
    enabled?: boolean;
    /**
     *
     * @type {string}
     * @memberof IntegrationTypeResource
     */
    groupType?: string;
    /**
     *
     * @type {string}
     * @memberof IntegrationTypeResource
     */
    name?: string;
    /**
     *
     * @type {number}
     * @memberof IntegrationTypeResource
     */
    type?: number;
}

/**
 * @export
 * @namespace IntegrationTypeResource
 */
export namespace IntegrationTypeResource {
    /**
     * @export
     * @enum {string}
     */
    export enum AuthFlowEnum {
        OAUTH = <any>'OAUTH',
        BASIC = <any>'BASIC',
        TOKEN = <any>'TOKEN',
        FORM = <any>'FORM',
        LDAP = <any>'LDAP'
    }
}

/**
 *
 * @export
 * @interface Issue
 */
export interface Issue {
    /**
     *
     * @type {boolean}
     * @memberof Issue
     */
    autoAnalyzed?: boolean;
    /**
     *
     * @type {string}
     * @memberof Issue
     */
    comment?: string;
    /**
     *
     * @type {Array<ExternalSystemIssue>}
     * @memberof Issue
     */
    externalSystemIssues?: Array<ExternalSystemIssue>;
    /**
     *
     * @type {boolean}
     * @memberof Issue
     */
    ignoreAnalyzer?: boolean;
    /**
     *
     * @type {string}
     * @memberof Issue
     */
    issueType: string;
}

/**
 *
 * @export
 * @interface IssueDefinition
 */
export interface IssueDefinition {
    /**
     *
     * @type {Issue}
     * @memberof IssueDefinition
     */
    issue: Issue;
    /**
     *
     * @type {number}
     * @memberof IssueDefinition
     */
    testItemId: number;
}

/**
 *
 * @export
 * @interface IssueSubTypeCreatedRS
 */
export interface IssueSubTypeCreatedRS {
    /**
     *
     * @type {number}
     * @memberof IssueSubTypeCreatedRS
     */
    id?: number;
    /**
     *
     * @type {string}
     * @memberof IssueSubTypeCreatedRS
     */
    locator?: string;
}

/**
 *
 * @export
 * @interface IssueSubTypeResource
 */
export interface IssueSubTypeResource {
    /**
     *
     * @type {string}
     * @memberof IssueSubTypeResource
     */
    color?: string;
    /**
     *
     * @type {number}
     * @memberof IssueSubTypeResource
     */
    id?: number;
    /**
     *
     * @type {string}
     * @memberof IssueSubTypeResource
     */
    locator?: string;
    /**
     *
     * @type {string}
     * @memberof IssueSubTypeResource
     */
    longName?: string;
    /**
     *
     * @type {string}
     * @memberof IssueSubTypeResource
     */
    shortName?: string;
    /**
     *
     * @type {string}
     * @memberof IssueSubTypeResource
     */
    typeRef?: string;
}

/**
 *
 * @export
 * @interface ItemAttributeResource
 */
export interface ItemAttributeResource {
    /**
     *
     * @type {string}
     * @memberof ItemAttributeResource
     */
    key?: string;
    /**
     *
     * @type {string}
     * @memberof ItemAttributeResource
     */
    value?: string;
}

/**
 *
 * @export
 * @interface ItemAttributesRQ
 */
export interface ItemAttributesRQ {
    /**
     *
     * @type {string}
     * @memberof ItemAttributesRQ
     */
    key?: string;
    /**
     *
     * @type {boolean}
     * @memberof ItemAttributesRQ
     */
    system?: boolean;
    /**
     *
     * @type {string}
     * @memberof ItemAttributesRQ
     */
    value?: string;
}

/**
 *
 * @export
 * @interface ItemPathName
 */
export interface ItemPathName {
    /**
     *
     * @type {number}
     * @memberof ItemPathName
     */
    id?: number;
    /**
     *
     * @type {string}
     * @memberof ItemPathName
     */
    name?: string;
}

/**
 *
 * @export
 * @interface IterableActivityEventResource
 */
export interface IterableActivityEventResource {
}

/**
 *
 * @export
 * @interface IterableClusterInfoResource
 */
export interface IterableClusterInfoResource {
}

/**
 *
 * @export
 * @interface IterableDashboardResource
 */
export interface IterableDashboardResource {
}

/**
 *
 * @export
 * @interface IterableLaunchResource
 */
export interface IterableLaunchResource {
}

/**
 *
 * @export
 * @interface IterableLogResource
 */
export interface IterableLogResource {
}

/**
 *
 * @export
 * @interface IterableOwnedEntityResource
 */
export interface IterableOwnedEntityResource {
}

/**
 *
 * @export
 * @interface IterableProjectInfoResource
 */
export interface IterableProjectInfoResource {
}

/**
 *
 * @export
 * @interface IterableSearchLogRs
 */
export interface IterableSearchLogRs {
}

/**
 *
 * @export
 * @interface IterableSearchUserResource
 */
export interface IterableSearchUserResource {
}

/**
 *
 * @export
 * @interface IterableTestItemHistoryElement
 */
export interface IterableTestItemHistoryElement {
}

/**
 *
 * @export
 * @interface IterableTestItemResource
 */
export interface IterableTestItemResource {
}

/**
 *
 * @export
 * @interface IterableUserFilterResource
 */
export interface IterableUserFilterResource {
}

/**
 *
 * @export
 * @interface IterableUserResource
 */
export interface IterableUserResource {
}

/**
 *
 * @export
 * @interface Iterableobject
 */
export interface Iterableobject {
}

/**
 *
 * @export
 * @interface Iterablestring
 */
export interface Iterablestring {
}

/**
 *
 * @export
 * @interface LaunchImportRQ
 */
export interface LaunchImportRQ {
    /**
     *
     * @type {Array<ItemAttributesRQ>}
     * @memberof LaunchImportRQ
     */
    attributes?: Array<ItemAttributesRQ>;
    /**
     *
     * @type {string}
     * @memberof LaunchImportRQ
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof LaunchImportRQ
     */
    mode?: LaunchImportRQ.ModeEnum;
    /**
     *
     * @type {string}
     * @memberof LaunchImportRQ
     */
    name?: string;
    /**
     *
     * @type {Date}
     * @memberof LaunchImportRQ
     */
    startTime?: Date;
}

/**
 * @export
 * @namespace LaunchImportRQ
 */
export namespace LaunchImportRQ {
    /**
     * @export
     * @enum {string}
     */
    export enum ModeEnum {
        DEFAULT = <any>'DEFAULT',
        DEBUG = <any>'DEBUG'
    }
}

/**
 *
 * @export
 * @interface LaunchPathName
 */
export interface LaunchPathName {
    /**
     *
     * @type {string}
     * @memberof LaunchPathName
     */
    name?: string;
    /**
     *
     * @type {number}
     * @memberof LaunchPathName
     */
    number?: number;
}

/**
 *
 * @export
 * @interface LaunchResource
 */
export interface LaunchResource {
    /**
     *
     * @type {Array<string>}
     * @memberof LaunchResource
     */
    analysing?: Array<string>;
    /**
     *
     * @type {number}
     * @memberof LaunchResource
     */
    approximateDuration?: number;
    /**
     *
     * @type {Array<ItemAttributeResource>}
     * @memberof LaunchResource
     */
    attributes?: Array<ItemAttributeResource>;
    /**
     *
     * @type {string}
     * @memberof LaunchResource
     */
    description?: string;
    /**
     *
     * @type {Date}
     * @memberof LaunchResource
     */
    endTime?: Date;
    /**
     *
     * @type {boolean}
     * @memberof LaunchResource
     */
    hasRetries?: boolean;
    /**
     *
     * @type {number}
     * @memberof LaunchResource
     */
    id: number;
    /**
     *
     * @type {Date}
     * @memberof LaunchResource
     */
    lastModified?: Date;
    /**
     *
     * @type {any}
     * @memberof LaunchResource
     */
    metadata?: any;
    /**
     *
     * @type {string}
     * @memberof LaunchResource
     */
    mode?: LaunchResource.ModeEnum;
    /**
     *
     * @type {string}
     * @memberof LaunchResource
     */
    name: string;
    /**
     *
     * @type {number}
     * @memberof LaunchResource
     */
    number: number;
    /**
     *
     * @type {string}
     * @memberof LaunchResource
     */
    owner?: string;
    /**
     *
     * @type {boolean}
     * @memberof LaunchResource
     */
    rerun?: boolean;
    /**
     *
     * @type {Date}
     * @memberof LaunchResource
     */
    startTime: Date;
    /**
     *
     * @type {StatisticsResource}
     * @memberof LaunchResource
     */
    statistics?: StatisticsResource;
    /**
     *
     * @type {string}
     * @memberof LaunchResource
     */
    status: string;
    /**
     *
     * @type {string}
     * @memberof LaunchResource
     */
    uuid: string;
}

/**
 * @export
 * @namespace LaunchResource
 */
export namespace LaunchResource {
    /**
     * @export
     * @enum {string}
     */
    export enum ModeEnum {
        DEFAULT = <any>'DEFAULT',
        DEBUG = <any>'DEBUG'
    }
}

/**
 *
 * @export
 * @interface LaunchesPerUser
 */
export interface LaunchesPerUser {
    /**
     *
     * @type {number}
     * @memberof LaunchesPerUser
     */
    count?: number;
    /**
     *
     * @type {string}
     * @memberof LaunchesPerUser
     */
    fullName?: string;
}

/**
 *
 * @export
 * @interface LinkExternalIssueRQ
 */
export interface LinkExternalIssueRQ {
    /**
     *
     * @type {Array<ExternalSystemIssue>}
     * @memberof LinkExternalIssueRQ
     */
    issues?: Array<ExternalSystemIssue>;
    /**
     *
     * @type {Array<number>}
     * @memberof LinkExternalIssueRQ
     */
    testItemIds?: Array<number>;
}

/**
 *
 * @export
 * @interface LogEntry
 */
export interface LogEntry {
    /**
     *
     * @type {string}
     * @memberof LogEntry
     */
    level?: string;
    /**
     *
     * @type {string}
     * @memberof LogEntry
     */
    message?: string;
}

/**
 *
 * @export
 * @interface LogResource
 */
export interface LogResource {
    /**
     *
     * @type {BinaryContent}
     * @memberof LogResource
     */
    binaryContent?: BinaryContent;
    /**
     *
     * @type {number}
     * @memberof LogResource
     */
    id: number;
    /**
     *
     * @type {number}
     * @memberof LogResource
     */
    itemId?: number;
    /**
     *
     * @type {number}
     * @memberof LogResource
     */
    launchId?: number;
    /**
     *
     * @type {string}
     * @memberof LogResource
     */
    level?: LogResource.LevelEnum;
    /**
     *
     * @type {string}
     * @memberof LogResource
     */
    message?: string;
    /**
     *
     * @type {string}
     * @memberof LogResource
     */
    thumbnail?: string;
    /**
     *
     * @type {Date}
     * @memberof LogResource
     */
    time?: Date;
    /**
     *
     * @type {string}
     * @memberof LogResource
     */
    uuid: string;
}

/**
 * @export
 * @namespace LogResource
 */
export namespace LogResource {
    /**
     * @export
     * @enum {string}
     */
    export enum LevelEnum {
        Error = <any>'error',
        Warn = <any>'warn',
        Info = <any>'info',
        Debug = <any>'debug',
        Trace = <any>'trace',
        Fatal = <any>'fatal',
        Unknown = <any>'unknown'
    }
}

/**
 *
 * @export
 * @interface Mapstringint
 */
export interface Mapstringint {
    [key: string]: any;

}

/**
 *
 * @export
 * @interface MergeLaunchesRQ
 */
export interface MergeLaunchesRQ {
    /**
     *
     * @type {Array<ItemAttributeResource>}
     * @memberof MergeLaunchesRQ
     */
    attributes?: Array<ItemAttributeResource>;
    /**
     *
     * @type {string}
     * @memberof MergeLaunchesRQ
     */
    description?: string;
    /**
     *
     * @type {Date}
     * @memberof MergeLaunchesRQ
     */
    endTime?: Date;
    /**
     *
     * @type {boolean}
     * @memberof MergeLaunchesRQ
     */
    extendSuitesDescription: boolean;
    /**
     *
     * @type {Array<number>}
     * @memberof MergeLaunchesRQ
     */
    launches: Array<number>;
    /**
     *
     * @type {string}
     * @memberof MergeLaunchesRQ
     */
    mergeType?: MergeLaunchesRQ.MergeTypeEnum;
    /**
     *
     * @type {string}
     * @memberof MergeLaunchesRQ
     */
    mode?: MergeLaunchesRQ.ModeEnum;
    /**
     *
     * @type {string}
     * @memberof MergeLaunchesRQ
     */
    name: string;
    /**
     *
     * @type {Date}
     * @memberof MergeLaunchesRQ
     */
    startTime?: Date;
}

/**
 * @export
 * @namespace MergeLaunchesRQ
 */
export namespace MergeLaunchesRQ {
    /**
     * @export
     * @enum {string}
     */
    export enum MergeTypeEnum {
        BASIC = <any>'BASIC',
        DEEP = <any>'DEEP'
    }

    /**
     * @export
     * @enum {string}
     */
    export enum ModeEnum {
        DEFAULT = <any>'DEFAULT',
        DEBUG = <any>'DEBUG'
    }
}

/**
 *
 * @export
 * @interface ModelFile
 */
export interface ModelFile {
    /**
     *
     * @type {string}
     * @memberof ModelFile
     */
    name?: string;
}

/**
 *
 * @export
 * @interface NamedValue
 */
export interface NamedValue {
    /**
     *
     * @type {number}
     * @memberof NamedValue
     */
    id?: number;
    /**
     *
     * @type {string}
     * @memberof NamedValue
     */
    name?: string;
}

/**
 *
 * @export
 * @interface OperationCompletionRS
 */
export interface OperationCompletionRS {
    /**
     *
     * @type {string}
     * @memberof OperationCompletionRS
     */
    message?: string;
}

/**
 *
 * @export
 * @interface Order
 */
export interface Order {
    /**
     *
     * @type {boolean}
     * @memberof Order
     */
    isAsc: boolean;
    /**
     *
     * @type {string}
     * @memberof Order
     */
    sortingColumn: string;
}

/**
 *
 * @export
 * @interface OwnedEntityResource
 */
export interface OwnedEntityResource {
    /**
     *
     * @type {string}
     * @memberof OwnedEntityResource
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof OwnedEntityResource
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof OwnedEntityResource
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof OwnedEntityResource
     */
    owner?: string;
}

/**
 *
 * @export
 * @interface PagedLogResource
 */
export interface PagedLogResource {
    /**
     *
     * @type {BinaryContent}
     * @memberof PagedLogResource
     */
    binaryContent?: BinaryContent;
    /**
     *
     * @type {number}
     * @memberof PagedLogResource
     */
    id: number;
    /**
     *
     * @type {number}
     * @memberof PagedLogResource
     */
    itemId?: number;
    /**
     *
     * @type {number}
     * @memberof PagedLogResource
     */
    launchId?: number;
    /**
     *
     * @type {string}
     * @memberof PagedLogResource
     */
    level?: PagedLogResource.LevelEnum;
    /**
     *
     * @type {string}
     * @memberof PagedLogResource
     */
    message?: string;
    /**
     *
     * @type {Array<Entrylongint>}
     * @memberof PagedLogResource
     */
    pagesLocation?: Array<Entrylongint>;
    /**
     *
     * @type {string}
     * @memberof PagedLogResource
     */
    thumbnail?: string;
    /**
     *
     * @type {Date}
     * @memberof PagedLogResource
     */
    time?: Date;
    /**
     *
     * @type {string}
     * @memberof PagedLogResource
     */
    uuid: string;
}

/**
 * @export
 * @namespace PagedLogResource
 */
export namespace PagedLogResource {
    /**
     * @export
     * @enum {string}
     */
    export enum LevelEnum {
        Error = <any>'error',
        Warn = <any>'warn',
        Info = <any>'info',
        Debug = <any>'debug',
        Trace = <any>'trace',
        Fatal = <any>'fatal',
        Unknown = <any>'unknown'
    }
}

/**
 *
 * @export
 * @interface PagedResponseActivityEventResource
 */
export interface PagedResponseActivityEventResource {
    /**
     *
     * @type {Array<ActivityEventResource>}
     * @memberof PagedResponseActivityEventResource
     */
    items?: Array<ActivityEventResource>;
    /**
     *
     * @type {number}
     * @memberof PagedResponseActivityEventResource
     */
    limit?: number;
    /**
     *
     * @type {number}
     * @memberof PagedResponseActivityEventResource
     */
    offset?: number;
    /**
     *
     * @type {string}
     * @memberof PagedResponseActivityEventResource
     */
    order?: string;
    /**
     *
     * @type {string}
     * @memberof PagedResponseActivityEventResource
     */
    sort?: string;
    /**
     *
     * @type {number}
     * @memberof PagedResponseActivityEventResource
     */
    totalCount?: number;
}

/**
 *
 * @export
 * @interface ParameterResource
 */
export interface ParameterResource {
    /**
     *
     * @type {string}
     * @memberof ParameterResource
     */
    key: string;
    /**
     *
     * @type {string}
     * @memberof ParameterResource
     */
    value?: string;
}

/**
 *
 * @export
 * @interface PathNameResource
 */
export interface PathNameResource {
    /**
     *
     * @type {Array<ItemPathName>}
     * @memberof PathNameResource
     */
    itemPaths?: Array<ItemPathName>;
    /**
     *
     * @type {LaunchPathName}
     * @memberof PathNameResource
     */
    launchPathName?: LaunchPathName;
}

/**
 *
 * @export
 * @interface PatternTemplateResource
 */
export interface PatternTemplateResource {
    /**
     *
     * @type {boolean}
     * @memberof PatternTemplateResource
     */
    enabled?: boolean;
    /**
     *
     * @type {number}
     * @memberof PatternTemplateResource
     */
    id?: number;
    /**
     *
     * @type {string}
     * @memberof PatternTemplateResource
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof PatternTemplateResource
     */
    type?: string;
    /**
     *
     * @type {string}
     * @memberof PatternTemplateResource
     */
    value?: string;
}

/**
 *
 * @export
 * @interface Position
 */
export interface Position {
    /**
     *
     * @type {number}
     * @memberof Position
     */
    positionX?: number;
    /**
     *
     * @type {number}
     * @memberof Position
     */
    positionY?: number;
}

/**
 *
 * @export
 * @interface PostFormField
 */
export interface PostFormField {
    /**
     *
     * @type {string}
     * @memberof PostFormField
     */
    commandName?: string;
    /**
     *
     * @type {Array<AllowedValue>}
     * @memberof PostFormField
     */
    definedValues?: Array<AllowedValue>;
    /**
     *
     * @type {string}
     * @memberof PostFormField
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof PostFormField
     */
    fieldName?: string;
    /**
     *
     * @type {string}
     * @memberof PostFormField
     */
    fieldType?: string;
    /**
     *
     * @type {string}
     * @memberof PostFormField
     */
    id: string;
    /**
     *
     * @type {Array<NamedValue>}
     * @memberof PostFormField
     */
    namedValue?: Array<NamedValue>;
    /**
     *
     * @type {boolean}
     * @memberof PostFormField
     */
    required: boolean;
    /**
     *
     * @type {Array<string>}
     * @memberof PostFormField
     */
    value?: Array<string>;
}

/**
 *
 * @export
 * @interface PostTicketRQ
 */
export interface PostTicketRQ {
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof PostTicketRQ
     */
    backLinks: { [key: string]: string; };
    /**
     *
     * @type {string}
     * @memberof PostTicketRQ
     */
    domain?: string;
    /**
     *
     * @type {Array<PostFormField>}
     * @memberof PostTicketRQ
     */
    fields: Array<PostFormField>;
    /**
     *
     * @type {boolean}
     * @memberof PostTicketRQ
     */
    includeComments?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PostTicketRQ
     */
    includeData?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PostTicketRQ
     */
    includeLogs?: boolean;
    /**
     *
     * @type {number}
     * @memberof PostTicketRQ
     */
    item: number;
    /**
     *
     * @type {number}
     * @memberof PostTicketRQ
     */
    logQuantity?: number;
    /**
     *
     * @type {string}
     * @memberof PostTicketRQ
     */
    password?: string;
    /**
     *
     * @type {string}
     * @memberof PostTicketRQ
     */
    token?: string;
    /**
     *
     * @type {string}
     * @memberof PostTicketRQ
     */
    username?: string;
}

/**
 *
 * @export
 * @interface PreferenceResource
 */
export interface PreferenceResource {
    /**
     *
     * @type {Array<UserFilterResource>}
     * @memberof PreferenceResource
     */
    filters?: Array<UserFilterResource>;
    /**
     *
     * @type {number}
     * @memberof PreferenceResource
     */
    projectId: number;
    /**
     *
     * @type {number}
     * @memberof PreferenceResource
     */
    userId?: number;
}

/**
 *
 * @export
 * @interface ProjectConfiguration
 */
export interface ProjectConfiguration {
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof ProjectConfiguration
     */
    attributes: { [key: string]: string; };
    /**
     *
     * @type {ProjectNotificationConfigDTO}
     * @memberof ProjectConfiguration
     */
    notificationsConfiguration?: ProjectNotificationConfigDTO;
    /**
     *
     * @type {Array<PatternTemplateResource>}
     * @memberof ProjectConfiguration
     */
    patterns?: Array<PatternTemplateResource>;
    /**
     *
     * @type {{ [key: string]: Array<IssueSubTypeResource>; }}
     * @memberof ProjectConfiguration
     */
    subTypes?: { [key: string]: Array<IssueSubTypeResource>; };
}

/**
 *
 * @export
 * @interface ProjectConfigurationUpdate
 */
export interface ProjectConfigurationUpdate {
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof ProjectConfigurationUpdate
     */
    attributes: { [key: string]: string; };
}

/**
 *
 * @export
 * @interface ProjectInfoResource
 */
export interface ProjectInfoResource {
    /**
     *
     * @type {Date}
     * @memberof ProjectInfoResource
     */
    creationDate?: Date;
    /**
     *
     * @type {string}
     * @memberof ProjectInfoResource
     */
    entryType?: string;
    /**
     *
     * @type {number}
     * @memberof ProjectInfoResource
     */
    id?: number;
    /**
     *
     * @type {Date}
     * @memberof ProjectInfoResource
     */
    lastRun?: Date;
    /**
     *
     * @type {Array<LaunchesPerUser>}
     * @memberof ProjectInfoResource
     */
    launchesPerUser?: Array<LaunchesPerUser>;
    /**
     *
     * @type {string}
     * @memberof ProjectInfoResource
     */
    launchesPerWeek?: string;
    /**
     *
     * @type {number}
     * @memberof ProjectInfoResource
     */
    launchesQuantity?: number;
    /**
     *
     * @type {string}
     * @memberof ProjectInfoResource
     */
    organization?: string;
    /**
     *
     * @type {string}
     * @memberof ProjectInfoResource
     */
    projectName?: string;
    /**
     *
     * @type {number}
     * @memberof ProjectInfoResource
     */
    uniqueTickets?: number;
    /**
     *
     * @type {number}
     * @memberof ProjectInfoResource
     */
    usersQuantity?: number;
}

/**
 *
 * @export
 * @interface ProjectNotificationConfigDTO
 */
export interface ProjectNotificationConfigDTO {
    /**
     *
     * @type {Array<SenderCaseDTO>}
     * @memberof ProjectNotificationConfigDTO
     */
    cases?: Array<SenderCaseDTO>;
    /**
     *
     * @type {boolean}
     * @memberof ProjectNotificationConfigDTO
     */
    enabled?: boolean;
}

/**
 *
 * @export
 * @interface ProjectResource
 */
export interface ProjectResource {
    /**
     *
     * @type {number}
     * @memberof ProjectResource
     */
    allocatedStorage?: number;
    /**
     *
     * @type {ProjectConfiguration}
     * @memberof ProjectResource
     */
    configuration: ProjectConfiguration;
    /**
     *
     * @type {Date}
     * @memberof ProjectResource
     */
    creationDate?: Date;
    /**
     *
     * @type {string}
     * @memberof ProjectResource
     */
    entryType: string;
    /**
     *
     * @type {Array<IntegrationResource>}
     * @memberof ProjectResource
     */
    integrations?: Array<IntegrationResource>;
    /**
     *
     * @type {string}
     * @memberof ProjectResource
     */
    organization?: string;
    /**
     *
     * @type {number}
     * @memberof ProjectResource
     */
    projectId: number;
    /**
     *
     * @type {string}
     * @memberof ProjectResource
     */
    projectName: string;
    /**
     *
     * @type {Array<ProjectUser>}
     * @memberof ProjectResource
     */
    users?: Array<ProjectUser>;
}

/**
 *
 * @export
 * @interface ProjectSettingsResource
 */
export interface ProjectSettingsResource {
    /**
     *
     * @type {number}
     * @memberof ProjectSettingsResource
     */
    project: number;
    /**
     *
     * @type {{ [key: string]: Array<IssueSubTypeResource>; }}
     * @memberof ProjectSettingsResource
     */
    subTypes: { [key: string]: Array<IssueSubTypeResource>; };
}

/**
 *
 * @export
 * @interface ProjectUser
 */
export interface ProjectUser {
    /**
     *
     * @type {string}
     * @memberof ProjectUser
     */
    login?: string;
    /**
     *
     * @type {string}
     * @memberof ProjectUser
     */
    projectRole?: string;
}

/**
 *
 * @export
 * @interface ResetPasswordRQ
 */
export interface ResetPasswordRQ {
    /**
     *
     * @type {string}
     * @memberof ResetPasswordRQ
     */
    password: string;
    /**
     *
     * @type {string}
     * @memberof ResetPasswordRQ
     */
    uuid: string;
}

/**
 *
 * @export
 * @interface RestorePasswordRQ
 */
export interface RestorePasswordRQ {
    /**
     *
     * @type {string}
     * @memberof RestorePasswordRQ
     */
    email: string;
}

/**
 *
 * @export
 * @interface SaveLogRQ
 */
export interface SaveLogRQ {
    /**
     *
     * @type {any}
     * @memberof SaveLogRQ
     */
    file?: any;
    /**
     * UUID of test item owned this log
     * @type {string}
     * @memberof SaveLogRQ
     */
    itemUuid?: string;
    /**
     *
     * @type {string}
     * @memberof SaveLogRQ
     */
    launchUuid: string;
    /**
     *
     * @type {string}
     * @memberof SaveLogRQ
     */
    level?: SaveLogRQ.LevelEnum;
    /**
     *
     * @type {string}
     * @memberof SaveLogRQ
     */
    message?: string;
    /**
     *
     * @type {Date}
     * @memberof SaveLogRQ
     */
    time: Date;
    /**
     *
     * @type {string}
     * @memberof SaveLogRQ
     */
    uuid?: string;
}

/**
 * @export
 * @namespace SaveLogRQ
 */
export namespace SaveLogRQ {
    /**
     * @export
     * @enum {string}
     */
    export enum LevelEnum {
        Error = <any>'error',
        Warn = <any>'warn',
        Info = <any>'info',
        Debug = <any>'debug',
        Trace = <any>'trace',
        Fatal = <any>'fatal',
        Unknown = <any>'unknown'
    }
}

/**
 *
 * @export
 * @interface SearchCriteria
 */
export interface SearchCriteria {
    /**
     *
     * @type {string}
     * @memberof SearchCriteria
     */
    filterKey: string;
    /**
     *
     * @type {string}
     * @memberof SearchCriteria
     */
    operation?: SearchCriteria.OperationEnum;
    /**
     *
     * @type {string}
     * @memberof SearchCriteria
     */
    value: string;
}

/**
 * @export
 * @namespace SearchCriteria
 */
export namespace SearchCriteria {
    /**
     * @export
     * @enum {string}
     */
    export enum OperationEnum {
        EQ = <any>'EQ',
        NE = <any>'NE',
        CNT = <any>'CNT',
        NONCNT = <any>'NON_CNT',
        BTW = <any>'BTW',
        IN = <any>'IN'
    }
}

/**
 *
 * @export
 * @interface SearchCriteriaRQ
 */
export interface SearchCriteriaRQ {
    /**
     *
     * @type {Array<SearchCriteria>}
     * @memberof SearchCriteriaRQ
     */
    searchCriterias?: Array<SearchCriteria>;
}

/**
 *
 * @export
 * @interface SearchLogRq
 */
export interface SearchLogRq {
    /**
     *
     * @type {number}
     * @memberof SearchLogRq
     */
    filterId?: number;
    /**
     *
     * @type {string}
     * @memberof SearchLogRq
     */
    searchMode?: SearchLogRq.SearchModeEnum;
}

/**
 * @export
 * @namespace SearchLogRq
 */
export namespace SearchLogRq {
    /**
     * @export
     * @enum {string}
     */
    export enum SearchModeEnum {
        CurrentLaunch = <any>'currentLaunch',
        LaunchName = <any>'launchName',
        Filter = <any>'filter'
    }
}

/**
 *
 * @export
 * @interface SearchLogRs
 */
export interface SearchLogRs {
    /**
     *
     * @type {number}
     * @memberof SearchLogRs
     */
    duration?: number;
    /**
     *
     * @type {Issue}
     * @memberof SearchLogRs
     */
    issue?: Issue;
    /**
     *
     * @type {number}
     * @memberof SearchLogRs
     */
    itemId?: number;
    /**
     *
     * @type {string}
     * @memberof SearchLogRs
     */
    itemName?: string;
    /**
     *
     * @type {number}
     * @memberof SearchLogRs
     */
    launchId?: number;
    /**
     *
     * @type {Array<LogEntry>}
     * @memberof SearchLogRs
     */
    logs?: Array<LogEntry>;
    /**
     *
     * @type {string}
     * @memberof SearchLogRs
     */
    path?: string;
    /**
     *
     * @type {PathNameResource}
     * @memberof SearchLogRs
     */
    pathNames?: PathNameResource;
    /**
     *
     * @type {Array<string>}
     * @memberof SearchLogRs
     */
    patternTemplates?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof SearchLogRs
     */
    status?: string;
}

/**
 *
 * @export
 * @interface SearchUserResource
 */
export interface SearchUserResource {
    /**
     *
     * @type {string}
     * @memberof SearchUserResource
     */
    email: string;
    /**
     *
     * @type {string}
     * @memberof SearchUserResource
     */
    fullName?: string;
    /**
     *
     * @type {number}
     * @memberof SearchUserResource
     */
    id: number;
    /**
     *
     * @type {string}
     * @memberof SearchUserResource
     */
    login: string;
}

/**
 *
 * @export
 * @interface SenderCaseDTO
 */
export interface SenderCaseDTO {
    /**
     *
     * @type {Array<ItemAttributeResource>}
     * @memberof SenderCaseDTO
     */
    attributes?: Array<ItemAttributeResource>;
    /**
     *
     * @type {string}
     * @memberof SenderCaseDTO
     */
    attributesOperator?: SenderCaseDTO.AttributesOperatorEnum;
    /**
     *
     * @type {boolean}
     * @memberof SenderCaseDTO
     */
    enabled?: boolean;
    /**
     *
     * @type {number}
     * @memberof SenderCaseDTO
     */
    id?: number;
    /**
     *
     * @type {Array<string>}
     * @memberof SenderCaseDTO
     */
    launchNames?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof SenderCaseDTO
     */
    recipients?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof SenderCaseDTO
     */
    ruleName?: string;
    /**
     *
     * @type {string}
     * @memberof SenderCaseDTO
     */
    sendCase?: SenderCaseDTO.SendCaseEnum;
}

/**
 * @export
 * @namespace SenderCaseDTO
 */
export namespace SenderCaseDTO {
    /**
     * @export
     * @enum {string}
     */
    export enum AttributesOperatorEnum {
        AND = <any>'AND',
        OR = <any>'OR'
    }

    /**
     * @export
     * @enum {string}
     */
    export enum SendCaseEnum {
        ALWAYS = <any>'ALWAYS',
        FAILED = <any>'FAILED',
        MORE10 = <any>'MORE_10',
        MORE20 = <any>'MORE_20',
        MORE50 = <any>'MORE_50'
    }
}

/**
 *
 * @export
 * @interface Serializable
 */
export interface Serializable {
}

/**
 *
 * @export
 * @interface Size
 */
export interface Size {
    /**
     *
     * @type {number}
     * @memberof Size
     */
    height?: number;
    /**
     *
     * @type {number}
     * @memberof Size
     */
    width?: number;
}

/**
 *
 * @export
 * @interface StartLaunchRQ
 */
export interface StartLaunchRQ {
    /**
     *
     * @type {Array<ItemAttributesRQ>}
     * @memberof StartLaunchRQ
     */
    attributes?: Array<ItemAttributesRQ>;
    /**
     *
     * @type {string}
     * @memberof StartLaunchRQ
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof StartLaunchRQ
     */
    mode?: StartLaunchRQ.ModeEnum;
    /**
     *
     * @type {string}
     * @memberof StartLaunchRQ
     */
    name: string;
    /**
     *
     * @type {boolean}
     * @memberof StartLaunchRQ
     */
    rerun?: boolean;
    /**
     * UUID of desired launch to rerun
     * @type {string}
     * @memberof StartLaunchRQ
     */
    rerunOf?: string;
    /**
     *
     * @type {Date}
     * @memberof StartLaunchRQ
     */
    startTime: Date;
}

/**
 * @export
 * @namespace StartLaunchRQ
 */
export namespace StartLaunchRQ {
    /**
     * @export
     * @enum {string}
     */
    export enum ModeEnum {
        DEFAULT = <any>'DEFAULT',
        DEBUG = <any>'DEBUG'
    }
}

/**
 *
 * @export
 * @interface StartLaunchRS
 */
export interface StartLaunchRS {
    /**
     *
     * @type {string}
     * @memberof StartLaunchRS
     */
    id?: string;
    /**
     *
     * @type {number}
     * @memberof StartLaunchRS
     */
    number?: number;
}

/**
 *
 * @export
 * @interface StartTestItemRQ
 */
export interface StartTestItemRQ {
    /**
     *
     * @type {Array<ItemAttributesRQ>}
     * @memberof StartTestItemRQ
     */
    attributes?: Array<ItemAttributesRQ>;
    /**
     *
     * @type {string}
     * @memberof StartTestItemRQ
     */
    codeRef?: string;
    /**
     *
     * @type {string}
     * @memberof StartTestItemRQ
     */
    description?: string;
    /**
     *
     * @type {boolean}
     * @memberof StartTestItemRQ
     */
    hasStats?: boolean;
    /**
     * UUID of parent launch
     * @type {string}
     * @memberof StartTestItemRQ
     */
    launchUuid: string;
    /**
     *
     * @type {string}
     * @memberof StartTestItemRQ
     */
    name: string;
    /**
     *
     * @type {Array<ParameterResource>}
     * @memberof StartTestItemRQ
     */
    parameters?: Array<ParameterResource>;
    /**
     *
     * @type {boolean}
     * @memberof StartTestItemRQ
     */
    retry?: boolean;
    /**
     *
     * @type {string}
     * @memberof StartTestItemRQ
     */
    retryOf?: string;
    /**
     *
     * @type {Date}
     * @memberof StartTestItemRQ
     */
    startTime: Date;
    /**
     *
     * @type {string}
     * @memberof StartTestItemRQ
     */
    testCaseId?: string;
    /**
     *
     * @type {string}
     * @memberof StartTestItemRQ
     */
    type: StartTestItemRQ.TypeEnum;
    /**
     *
     * @type {string}
     * @memberof StartTestItemRQ
     */
    uniqueId?: string;
}

/**
 * @export
 * @namespace StartTestItemRQ
 */
export namespace StartTestItemRQ {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        SUITE = <any>'SUITE',
        STORY = <any>'STORY',
        TEST = <any>'TEST',
        SCENARIO = <any>'SCENARIO',
        STEP = <any>'STEP',
        BEFORECLASS = <any>'BEFORE_CLASS',
        BEFOREGROUPS = <any>'BEFORE_GROUPS',
        BEFOREMETHOD = <any>'BEFORE_METHOD',
        BEFORESUITE = <any>'BEFORE_SUITE',
        BEFORETEST = <any>'BEFORE_TEST',
        AFTERCLASS = <any>'AFTER_CLASS',
        AFTERGROUPS = <any>'AFTER_GROUPS',
        AFTERMETHOD = <any>'AFTER_METHOD',
        AFTERSUITE = <any>'AFTER_SUITE',
        AFTERTEST = <any>'AFTER_TEST'
    }
}

/**
 *
 * @export
 * @interface StatisticsResource
 */
export interface StatisticsResource {
    /**
     *
     * @type {{ [key: string]: { [key: string]: number; }; }}
     * @memberof StatisticsResource
     */
    defects?: { [key: string]: { [key: string]: number; }; };
    /**
     *
     * @type {{ [key: string]: number; }}
     * @memberof StatisticsResource
     */
    executions?: { [key: string]: number; };
}

/**
 *
 * @export
 * @interface SuggestInfo
 */
export interface SuggestInfo {
    /**
     *
     * @type {number}
     * @memberof SuggestInfo
     */
    clusterId?: number;
    /**
     *
     * @type {number}
     * @memberof SuggestInfo
     */
    esPosition?: number;
    /**
     *
     * @type {number}
     * @memberof SuggestInfo
     */
    esScore?: number;
    /**
     *
     * @type {boolean}
     * @memberof SuggestInfo
     */
    isMergedLog?: boolean;
    /**
     *
     * @type {string}
     * @memberof SuggestInfo
     */
    issueType?: string;
    /**
     *
     * @type {number}
     * @memberof SuggestInfo
     */
    launchId?: number;
    /**
     *
     * @type {string}
     * @memberof SuggestInfo
     */
    launchName?: string;
    /**
     *
     * @type {number}
     * @memberof SuggestInfo
     */
    launchNumber?: number;
    /**
     *
     * @type {number}
     * @memberof SuggestInfo
     */
    matchScore?: number;
    /**
     *
     * @type {string}
     * @memberof SuggestInfo
     */
    methodName?: string;
    /**
     *
     * @type {number}
     * @memberof SuggestInfo
     */
    minShouldMatch?: number;
    /**
     *
     * @type {string}
     * @memberof SuggestInfo
     */
    modelFeatureNames?: string;
    /**
     *
     * @type {string}
     * @memberof SuggestInfo
     */
    modelFeatureValues?: string;
    /**
     *
     * @type {string}
     * @memberof SuggestInfo
     */
    modelInfo?: string;
    /**
     *
     * @type {number}
     * @memberof SuggestInfo
     */
    processedTime?: number;
    /**
     *
     * @type {number}
     * @memberof SuggestInfo
     */
    project?: number;
    /**
     *
     * @type {number}
     * @memberof SuggestInfo
     */
    relevantItem?: number;
    /**
     *
     * @type {number}
     * @memberof SuggestInfo
     */
    relevantLogId?: number;
    /**
     *
     * @type {number}
     * @memberof SuggestInfo
     */
    resultPosition?: number;
    /**
     *
     * @type {number}
     * @memberof SuggestInfo
     */
    testItem?: number;
    /**
     *
     * @type {number}
     * @memberof SuggestInfo
     */
    testItemLogId?: number;
    /**
     *
     * @type {number}
     * @memberof SuggestInfo
     */
    usedLogLines?: number;
    /**
     *
     * @type {number}
     * @memberof SuggestInfo
     */
    userChoice?: number;
}

/**
 *
 * @export
 * @interface SuggestedItem
 */
export interface SuggestedItem {
    /**
     *
     * @type {Array<LogResource>}
     * @memberof SuggestedItem
     */
    logs?: Array<LogResource>;
    /**
     *
     * @type {SuggestInfo}
     * @memberof SuggestedItem
     */
    suggestRs?: SuggestInfo;
    /**
     *
     * @type {TestItemResource}
     * @memberof SuggestedItem
     */
    testItemResource?: TestItemResource;
}

/**
 *
 * @export
 * @interface TestItemHistoryElement
 */
export interface TestItemHistoryElement {
    /**
     *
     * @type {string}
     * @memberof TestItemHistoryElement
     */
    groupingField?: string;
    /**
     *
     * @type {Array<TestItemResource>}
     * @memberof TestItemHistoryElement
     */
    resources?: Array<TestItemResource>;
}

/**
 *
 * @export
 * @interface TestItemResource
 */
export interface TestItemResource {
    /**
     *
     * @type {Array<ItemAttributeResource>}
     * @memberof TestItemResource
     */
    attributes?: Array<ItemAttributeResource>;
    /**
     *
     * @type {string}
     * @memberof TestItemResource
     */
    codeRef?: string;
    /**
     *
     * @type {string}
     * @memberof TestItemResource
     */
    description?: string;
    /**
     *
     * @type {Date}
     * @memberof TestItemResource
     */
    endTime?: Date;
    /**
     *
     * @type {boolean}
     * @memberof TestItemResource
     */
    hasChildren?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof TestItemResource
     */
    hasStats?: boolean;
    /**
     *
     * @type {number}
     * @memberof TestItemResource
     */
    id?: number;
    /**
     *
     * @type {Issue}
     * @memberof TestItemResource
     */
    issue?: Issue;
    /**
     *
     * @type {number}
     * @memberof TestItemResource
     */
    launchId?: number;
    /**
     *
     * @type {string}
     * @memberof TestItemResource
     */
    launchStatus?: string;
    /**
     *
     * @type {string}
     * @memberof TestItemResource
     */
    name?: string;
    /**
     *
     * @type {Array<ParameterResource>}
     * @memberof TestItemResource
     */
    parameters?: Array<ParameterResource>;
    /**
     *
     * @type {number}
     * @memberof TestItemResource
     */
    parent?: number;
    /**
     *
     * @type {string}
     * @memberof TestItemResource
     */
    path?: string;
    /**
     *
     * @type {PathNameResource}
     * @memberof TestItemResource
     */
    pathNames?: PathNameResource;
    /**
     *
     * @type {Array<string>}
     * @memberof TestItemResource
     */
    patternTemplates?: Array<string>;
    /**
     *
     * @type {Array<TestItemResource>}
     * @memberof TestItemResource
     */
    retries?: Array<TestItemResource>;
    /**
     *
     * @type {Date}
     * @memberof TestItemResource
     */
    startTime?: Date;
    /**
     *
     * @type {StatisticsResource}
     * @memberof TestItemResource
     */
    statistics?: StatisticsResource;
    /**
     *
     * @type {string}
     * @memberof TestItemResource
     */
    status?: string;
    /**
     *
     * @type {number}
     * @memberof TestItemResource
     */
    testCaseHash?: number;
    /**
     *
     * @type {string}
     * @memberof TestItemResource
     */
    testCaseId?: string;
    /**
     *
     * @type {string}
     * @memberof TestItemResource
     */
    type?: string;
    /**
     *
     * @type {string}
     * @memberof TestItemResource
     */
    uniqueId?: string;
    /**
     *
     * @type {string}
     * @memberof TestItemResource
     */
    uuid?: string;
}

/**
 *
 * @export
 * @interface Ticket
 */
export interface Ticket {
    /**
     *
     * @type {string}
     * @memberof Ticket
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof Ticket
     */
    pluginName?: string;
    /**
     *
     * @type {string}
     * @memberof Ticket
     */
    status?: string;
    /**
     *
     * @type {string}
     * @memberof Ticket
     */
    summary?: string;
    /**
     *
     * @type {string}
     * @memberof Ticket
     */
    url?: string;
}

/**
 *
 * @export
 * @interface Timestamp
 */
export interface Timestamp {
    /**
     *
     * @type {number}
     * @memberof Timestamp
     */
    date?: number;
    /**
     *
     * @type {number}
     * @memberof Timestamp
     */
    day?: number;
    /**
     *
     * @type {number}
     * @memberof Timestamp
     */
    hours?: number;
    /**
     *
     * @type {number}
     * @memberof Timestamp
     */
    minutes?: number;
    /**
     *
     * @type {number}
     * @memberof Timestamp
     */
    month?: number;
    /**
     *
     * @type {number}
     * @memberof Timestamp
     */
    nanos?: number;
    /**
     *
     * @type {number}
     * @memberof Timestamp
     */
    seconds?: number;
    /**
     *
     * @type {number}
     * @memberof Timestamp
     */
    time?: number;
    /**
     *
     * @type {number}
     * @memberof Timestamp
     */
    timezoneOffset?: number;
    /**
     *
     * @type {number}
     * @memberof Timestamp
     */
    year?: number;
}

/**
 *
 * @export
 * @interface UnassignUsersRQ
 */
export interface UnassignUsersRQ {
    /**
     *
     * @type {Array<string>}
     * @memberof UnassignUsersRQ
     */
    userNames: Array<string>;
}

/**
 *
 * @export
 * @interface UnlinkExternalIssueRQ
 */
export interface UnlinkExternalIssueRQ {
    /**
     *
     * @type {Array<number>}
     * @memberof UnlinkExternalIssueRQ
     */
    testItemIds?: Array<number>;
    /**
     *
     * @type {Array<string>}
     * @memberof UnlinkExternalIssueRQ
     */
    ticketIds?: Array<string>;
}

/**
 *
 * @export
 * @interface UpdateDashboardRQ
 */
export interface UpdateDashboardRQ {
    /**
     *
     * @type {string}
     * @memberof UpdateDashboardRQ
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateDashboardRQ
     */
    name: string;
    /**
     *
     * @type {Array<WidgetObjectModel>}
     * @memberof UpdateDashboardRQ
     */
    updateWidgets?: Array<WidgetObjectModel>;
}

/**
 *
 * @export
 * @interface UpdateIssueSubTypeRQ
 */
export interface UpdateIssueSubTypeRQ {
    /**
     *
     * @type {Array<UpdateOneIssueSubTypeRQ>}
     * @memberof UpdateIssueSubTypeRQ
     */
    ids: Array<UpdateOneIssueSubTypeRQ>;
}

/**
 *
 * @export
 * @interface UpdateItemAttributeRQ
 */
export interface UpdateItemAttributeRQ {
    /**
     *
     * @type {string}
     * @memberof UpdateItemAttributeRQ
     */
    action?: UpdateItemAttributeRQ.ActionEnum;
    /**
     *
     * @type {ItemAttributeResource}
     * @memberof UpdateItemAttributeRQ
     */
    from?: ItemAttributeResource;
    /**
     *
     * @type {ItemAttributeResource}
     * @memberof UpdateItemAttributeRQ
     */
    to?: ItemAttributeResource;
}

/**
 * @export
 * @namespace UpdateItemAttributeRQ
 */
export namespace UpdateItemAttributeRQ {
    /**
     * @export
     * @enum {string}
     */
    export enum ActionEnum {
        DELETE = <any>'DELETE',
        UPDATE = <any>'UPDATE',
        CREATE = <any>'CREATE'
    }
}

/**
 *
 * @export
 * @interface UpdateLaunchRQ
 */
export interface UpdateLaunchRQ {
    /**
     *
     * @type {Array<ItemAttributeResource>}
     * @memberof UpdateLaunchRQ
     */
    attributes?: Array<ItemAttributeResource>;
    /**
     *
     * @type {string}
     * @memberof UpdateLaunchRQ
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateLaunchRQ
     */
    mode?: UpdateLaunchRQ.ModeEnum;
}

/**
 * @export
 * @namespace UpdateLaunchRQ
 */
export namespace UpdateLaunchRQ {
    /**
     * @export
     * @enum {string}
     */
    export enum ModeEnum {
        DEFAULT = <any>'DEFAULT',
        DEBUG = <any>'DEBUG'
    }
}

/**
 *
 * @export
 * @interface UpdateOneIssueSubTypeRQ
 */
export interface UpdateOneIssueSubTypeRQ {
    /**
     *
     * @type {string}
     * @memberof UpdateOneIssueSubTypeRQ
     */
    color?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateOneIssueSubTypeRQ
     */
    locator: string;
    /**
     *
     * @type {string}
     * @memberof UpdateOneIssueSubTypeRQ
     */
    longName?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateOneIssueSubTypeRQ
     */
    shortName?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateOneIssueSubTypeRQ
     */
    typeRef: string;
}

/**
 *
 * @export
 * @interface UpdatePatternTemplateRQ
 */
export interface UpdatePatternTemplateRQ {
    /**
     *
     * @type {boolean}
     * @memberof UpdatePatternTemplateRQ
     */
    enabled?: boolean;
    /**
     *
     * @type {string}
     * @memberof UpdatePatternTemplateRQ
     */
    name?: string;
}

/**
 *
 * @export
 * @interface UpdatePluginStateRQ
 */
export interface UpdatePluginStateRQ {
    /**
     *
     * @type {boolean}
     * @memberof UpdatePluginStateRQ
     */
    enabled?: boolean;
}

/**
 *
 * @export
 * @interface UpdateProjectRQ
 */
export interface UpdateProjectRQ {
    /**
     *
     * @type {ProjectConfigurationUpdate}
     * @memberof UpdateProjectRQ
     */
    configuration?: ProjectConfigurationUpdate;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof UpdateProjectRQ
     */
    users?: { [key: string]: string; };
}

/**
 *
 * @export
 * @interface UpdateTestItemRQ
 */
export interface UpdateTestItemRQ {
    /**
     *
     * @type {Array<ItemAttributeResource>}
     * @memberof UpdateTestItemRQ
     */
    attributes?: Array<ItemAttributeResource>;
    /**
     *
     * @type {string}
     * @memberof UpdateTestItemRQ
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateTestItemRQ
     */
    status?: string;
}

/**
 *
 * @export
 * @interface UpdateUserFilterRQ
 */
export interface UpdateUserFilterRQ {
    /**
     *
     * @type {Array<UserFilterCondition>}
     * @memberof UpdateUserFilterRQ
     */
    conditions: Array<UserFilterCondition>;
    /**
     *
     * @type {string}
     * @memberof UpdateUserFilterRQ
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof UpdateUserFilterRQ
     */
    name: string;
    /**
     *
     * @type {Array<Order>}
     * @memberof UpdateUserFilterRQ
     */
    orders: Array<Order>;
    /**
     *
     * @type {string}
     * @memberof UpdateUserFilterRQ
     */
    type: UpdateUserFilterRQ.TypeEnum;
}

/**
 * @export
 * @namespace UpdateUserFilterRQ
 */
export namespace UpdateUserFilterRQ {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Launch = <any>'launch',
        Testitem = <any>'testitem',
        Log = <any>'log'
    }
}

/**
 *
 * @export
 * @interface UserBidRS
 */
export interface UserBidRS {
    /**
     *
     * @type {string}
     * @memberof UserBidRS
     */
    email?: string;
    /**
     *
     * @type {boolean}
     * @memberof UserBidRS
     */
    isActive?: boolean;
    /**
     *
     * @type {string}
     * @memberof UserBidRS
     */
    uuid?: string;
}

/**
 *
 * @export
 * @interface UserFilterCondition
 */
export interface UserFilterCondition {
    /**
     *
     * @type {string}
     * @memberof UserFilterCondition
     */
    condition: string;
    /**
     *
     * @type {string}
     * @memberof UserFilterCondition
     */
    filteringField: string;
    /**
     *
     * @type {string}
     * @memberof UserFilterCondition
     */
    value: string;
}

/**
 *
 * @export
 * @interface UserFilterResource
 */
export interface UserFilterResource {
    /**
     *
     * @type {Array<UserFilterCondition>}
     * @memberof UserFilterResource
     */
    conditions: Array<UserFilterCondition>;
    /**
     *
     * @type {string}
     * @memberof UserFilterResource
     */
    description?: string;
    /**
     *
     * @type {number}
     * @memberof UserFilterResource
     */
    id: number;
    /**
     *
     * @type {string}
     * @memberof UserFilterResource
     */
    name: string;
    /**
     *
     * @type {Array<Order>}
     * @memberof UserFilterResource
     */
    orders: Array<Order>;
    /**
     *
     * @type {string}
     * @memberof UserFilterResource
     */
    owner: string;
    /**
     *
     * @type {string}
     * @memberof UserFilterResource
     */
    type: string;
}

/**
 *
 * @export
 * @interface UserResource
 */
export interface UserResource {
    /**
     *
     * @type {string}
     * @memberof UserResource
     */
    accountType?: string;
    /**
     *
     * @type {{ [key: string]: AssignedProject; }}
     * @memberof UserResource
     */
    assignedProjects?: { [key: string]: AssignedProject; };
    /**
     *
     * @type {string}
     * @memberof UserResource
     */
    email: string;
    /**
     *
     * @type {string}
     * @memberof UserResource
     */
    fullName?: string;
    /**
     *
     * @type {number}
     * @memberof UserResource
     */
    id: number;
    /**
     *
     * @type {any}
     * @memberof UserResource
     */
    metadata?: any;
    /**
     *
     * @type {string}
     * @memberof UserResource
     */
    photoId?: string;
    /**
     *
     * @type {boolean}
     * @memberof UserResource
     */
    photoLoaded?: boolean;
    /**
     *
     * @type {string}
     * @memberof UserResource
     */
    userId: string;
    /**
     *
     * @type {string}
     * @memberof UserResource
     */
    userRole?: string;
}

/**
 *
 * @export
 * @interface WidgetObjectModel
 */
export interface WidgetObjectModel {
    /**
     *
     * @type {number}
     * @memberof WidgetObjectModel
     */
    widgetId?: number;
    /**
     *
     * @type {string}
     * @memberof WidgetObjectModel
     */
    widgetName?: string;
    /**
     *
     * @type {any}
     * @memberof WidgetObjectModel
     */
    widgetOptions?: any;
    /**
     *
     * @type {Position}
     * @memberof WidgetObjectModel
     */
    widgetPosition?: Position;
    /**
     *
     * @type {Size}
     * @memberof WidgetObjectModel
     */
    widgetSize?: Size;
    /**
     *
     * @type {string}
     * @memberof WidgetObjectModel
     */
    widgetType?: string;
}

/**
 *
 * @export
 * @interface WidgetPreviewRQ
 */
export interface WidgetPreviewRQ {
    /**
     *
     * @type {ContentParameters}
     * @memberof WidgetPreviewRQ
     */
    contentParameters?: ContentParameters;
    /**
     *
     * @type {Array<number>}
     * @memberof WidgetPreviewRQ
     */
    filterIds?: Array<number>;
    /**
     *
     * @type {string}
     * @memberof WidgetPreviewRQ
     */
    widgetType: WidgetPreviewRQ.WidgetTypeEnum;
}

/**
 * @export
 * @namespace WidgetPreviewRQ
 */
export namespace WidgetPreviewRQ {
    /**
     * @export
     * @enum {string}
     */
    export enum WidgetTypeEnum {
        OldLineChart = <any>'oldLineChart',
        InvestigatedTrend = <any>'investigatedTrend',
        LaunchStatistics = <any>'launchStatistics',
        StatisticTrend = <any>'statisticTrend',
        CasesTrend = <any>'casesTrend',
        NotPassed = <any>'notPassed',
        OverallStatistics = <any>'overallStatistics',
        UniqueBugTable = <any>'uniqueBugTable',
        BugTrend = <any>'bugTrend',
        ActivityStream = <any>'activityStream',
        LaunchesComparisonChart = <any>'launchesComparisonChart',
        LaunchesDurationChart = <any>'launchesDurationChart',
        LaunchesTable = <any>'launchesTable',
        TopTestCases = <any>'topTestCases',
        FlakyTestCases = <any>'flakyTestCases',
        PassingRateSummary = <any>'passingRateSummary',
        PassingRatePerLaunch = <any>'passingRatePerLaunch',
        ProductStatus = <any>'productStatus',
        MostTimeConsuming = <any>'mostTimeConsuming',
        Cumulative = <any>'cumulative'
    }
}

/**
 *
 * @export
 * @interface WidgetRQ
 */
export interface WidgetRQ {
    /**
     *
     * @type {ContentParameters}
     * @memberof WidgetRQ
     */
    contentParameters?: ContentParameters;
    /**
     *
     * @type {string}
     * @memberof WidgetRQ
     */
    description?: string;
    /**
     *
     * @type {Array<number>}
     * @memberof WidgetRQ
     */
    filterIds?: Array<number>;
    /**
     *
     * @type {string}
     * @memberof WidgetRQ
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof WidgetRQ
     */
    widgetType: WidgetRQ.WidgetTypeEnum;
}

/**
 * @export
 * @namespace WidgetRQ
 */
export namespace WidgetRQ {
    /**
     * @export
     * @enum {string}
     */
    export enum WidgetTypeEnum {
        OldLineChart = <any>'oldLineChart',
        InvestigatedTrend = <any>'investigatedTrend',
        LaunchStatistics = <any>'launchStatistics',
        StatisticTrend = <any>'statisticTrend',
        CasesTrend = <any>'casesTrend',
        NotPassed = <any>'notPassed',
        OverallStatistics = <any>'overallStatistics',
        UniqueBugTable = <any>'uniqueBugTable',
        BugTrend = <any>'bugTrend',
        ActivityStream = <any>'activityStream',
        LaunchesComparisonChart = <any>'launchesComparisonChart',
        LaunchesDurationChart = <any>'launchesDurationChart',
        LaunchesTable = <any>'launchesTable',
        TopTestCases = <any>'topTestCases',
        FlakyTestCases = <any>'flakyTestCases',
        PassingRateSummary = <any>'passingRateSummary',
        PassingRatePerLaunch = <any>'passingRatePerLaunch',
        ProductStatus = <any>'productStatus',
        MostTimeConsuming = <any>'mostTimeConsuming',
        Cumulative = <any>'cumulative',
        TopPatternTemplates = <any>'topPatternTemplates',
        ComponentHealthCheck = <any>'componentHealthCheck',
        ComponentHealthCheckTable = <any>'componentHealthCheckTable'
    }
}

/**
 *
 * @export
 * @interface WidgetResource
 */
export interface WidgetResource {
    /**
     *
     * @type {Array<UserFilterResource>}
     * @memberof WidgetResource
     */
    appliedFilters?: Array<UserFilterResource>;
    /**
     *
     * @type {any}
     * @memberof WidgetResource
     */
    content?: any;
    /**
     *
     * @type {ContentParameters}
     * @memberof WidgetResource
     */
    contentParameters: ContentParameters;
    /**
     *
     * @type {string}
     * @memberof WidgetResource
     */
    description?: string;
    /**
     *
     * @type {number}
     * @memberof WidgetResource
     */
    id: number;
    /**
     *
     * @type {string}
     * @memberof WidgetResource
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof WidgetResource
     */
    owner?: string;
    /**
     *
     * @type {string}
     * @memberof WidgetResource
     */
    widgetType: WidgetResource.WidgetTypeEnum;
}

/**
 * @export
 * @namespace WidgetResource
 */
export namespace WidgetResource {
    /**
     * @export
     * @enum {string}
     */
    export enum WidgetTypeEnum {
        OldLineChart = <any>'oldLineChart',
        InvestigatedTrend = <any>'investigatedTrend',
        LaunchStatistics = <any>'launchStatistics',
        StatisticTrend = <any>'statisticTrend',
        CasesTrend = <any>'casesTrend',
        NotPassed = <any>'notPassed',
        OverallStatistics = <any>'overallStatistics',
        UniqueBugTable = <any>'uniqueBugTable',
        BugTrend = <any>'bugTrend',
        ActivityStream = <any>'activityStream',
        LaunchesComparisonChart = <any>'launchesComparisonChart',
        LaunchesDurationChart = <any>'launchesDurationChart',
        LaunchesTable = <any>'launchesTable',
        TopTestCases = <any>'topTestCases',
        FlakyTestCases = <any>'flakyTestCases',
        PassingRateSummary = <any>'passingRateSummary',
        PassingRatePerLaunch = <any>'passingRatePerLaunch',
        ProductStatus = <any>'productStatus',
        MostTimeConsuming = <any>'mostTimeConsuming',
        Cumulative = <any>'cumulative'
    }
}

/**
 *
 * @export
 * @interface YesNoRS
 */
export interface YesNoRS {
    /**
     *
     * @type {boolean}
     * @memberof YesNoRS
     */
    is?: boolean;
}


/**
 * ActivityControllerApi - fetch parameter creator
 * @export
 */
export const ActivityControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary getActivity
         * @param {number} activityId activityId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityUsingGET(activityId: number, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'activityId' is not null or undefined
            if (activityId === null || activityId === undefined) {
                throw new RequiredError('activityId', 'Required parameter activityId was null or undefined when calling getActivityUsingGET.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getActivityUsingGET.');
            }
            const localVarPath = `/v1/{projectName}/activity/{activityId}`
                .replace(`{${"activityId"}}`, encodeURIComponent(String(activityId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get activities for test item
         * @param {number} itemId itemId
         * @param {string} projectName projectName
         * @param {string} [filterEqAction] Filters by &#39;action&#39;
         * @param {Date} [filterEqCreatedAt] Filters by &#39;createdAt&#39;
         * @param {string} [filterEqEventName] Filters by &#39;eventName&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {number} [filterEqObjectId] Filters by &#39;objectId&#39;
         * @param {string} [filterEqObjectName] Filters by &#39;objectName&#39;
         * @param {string} [filterEqObjectType] Filters by &#39;objectType&#39;
         * @param {string} [filterEqPriority] Filters by &#39;priority&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {string} [filterEqProjectName] Filters by &#39;projectName&#39;
         * @param {number} [filterEqSubjectId] Filters by &#39;subjectId&#39;
         * @param {string} [filterEqSubjectName] Filters by &#39;subjectName&#39;
         * @param {string} [filterEqSubjectType] Filters by &#39;subjectType&#39;
         * @param {string} [filterEqUser] Filters by &#39;user&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestItemActivitiesUsingGET(itemId: number, projectName: string, filterEqAction?: string, filterEqCreatedAt?: Date, filterEqEventName?: string, filterEqId?: number, filterEqObjectId?: number, filterEqObjectName?: string, filterEqObjectType?: string, filterEqPriority?: string, filterEqProjectId?: number, filterEqProjectName?: string, filterEqSubjectId?: number, filterEqSubjectName?: string, filterEqSubjectType?: string, filterEqUser?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId', 'Required parameter itemId was null or undefined when calling getTestItemActivitiesUsingGET.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getTestItemActivitiesUsingGET.');
            }
            const localVarPath = `/v1/{projectName}/activity/item/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filterEqAction !== undefined) {
                localVarQueryParameter['filter.eq.action'] = filterEqAction;
            }

            if (filterEqCreatedAt !== undefined) {
                localVarQueryParameter['filter.eq.createdAt'] = (filterEqCreatedAt as any).toISOString();
            }

            if (filterEqEventName !== undefined) {
                localVarQueryParameter['filter.eq.eventName'] = filterEqEventName;
            }

            if (filterEqId !== undefined) {
                localVarQueryParameter['filter.eq.id'] = filterEqId;
            }

            if (filterEqObjectId !== undefined) {
                localVarQueryParameter['filter.eq.objectId'] = filterEqObjectId;
            }

            if (filterEqObjectName !== undefined) {
                localVarQueryParameter['filter.eq.objectName'] = filterEqObjectName;
            }

            if (filterEqObjectType !== undefined) {
                localVarQueryParameter['filter.eq.objectType'] = filterEqObjectType;
            }

            if (filterEqPriority !== undefined) {
                localVarQueryParameter['filter.eq.priority'] = filterEqPriority;
            }

            if (filterEqProjectId !== undefined) {
                localVarQueryParameter['filter.eq.projectId'] = filterEqProjectId;
            }

            if (filterEqProjectName !== undefined) {
                localVarQueryParameter['filter.eq.projectName'] = filterEqProjectName;
            }

            if (filterEqSubjectId !== undefined) {
                localVarQueryParameter['filter.eq.subjectId'] = filterEqSubjectId;
            }

            if (filterEqSubjectName !== undefined) {
                localVarQueryParameter['filter.eq.subjectName'] = filterEqSubjectName;
            }

            if (filterEqSubjectType !== undefined) {
                localVarQueryParameter['filter.eq.subjectType'] = filterEqSubjectType;
            }

            if (filterEqUser !== undefined) {
                localVarQueryParameter['filter.eq.user'] = filterEqUser;
            }

            if (pagePage !== undefined) {
                localVarQueryParameter['page.page'] = pagePage;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page.size'] = pageSize;
            }

            if (pageSort) {
                localVarQueryParameter['page.sort'] = pageSort;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivityControllerApi - functional programming interface
 * @export
 */
export const ActivityControllerApiFp = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary getActivity
         * @param {number} activityId activityId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityUsingGET(activityId: number, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ActivityResource> {
            const localVarFetchArgs = ActivityControllerApiFetchParamCreator(configuration).getActivityUsingGET(activityId, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get activities for test item
         * @param {number} itemId itemId
         * @param {string} projectName projectName
         * @param {string} [filterEqAction] Filters by &#39;action&#39;
         * @param {Date} [filterEqCreatedAt] Filters by &#39;createdAt&#39;
         * @param {string} [filterEqEventName] Filters by &#39;eventName&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {number} [filterEqObjectId] Filters by &#39;objectId&#39;
         * @param {string} [filterEqObjectName] Filters by &#39;objectName&#39;
         * @param {string} [filterEqObjectType] Filters by &#39;objectType&#39;
         * @param {string} [filterEqPriority] Filters by &#39;priority&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {string} [filterEqProjectName] Filters by &#39;projectName&#39;
         * @param {number} [filterEqSubjectId] Filters by &#39;subjectId&#39;
         * @param {string} [filterEqSubjectName] Filters by &#39;subjectName&#39;
         * @param {string} [filterEqSubjectType] Filters by &#39;subjectType&#39;
         * @param {string} [filterEqUser] Filters by &#39;user&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestItemActivitiesUsingGET(itemId: number, projectName: string, filterEqAction?: string, filterEqCreatedAt?: Date, filterEqEventName?: string, filterEqId?: number, filterEqObjectId?: number, filterEqObjectName?: string, filterEqObjectType?: string, filterEqPriority?: string, filterEqProjectId?: number, filterEqProjectName?: string, filterEqSubjectId?: number, filterEqSubjectName?: string, filterEqSubjectType?: string, filterEqUser?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<IterableActivityEventResource> {
            const localVarFetchArgs = ActivityControllerApiFetchParamCreator(configuration).getTestItemActivitiesUsingGET(itemId, projectName, filterEqAction, filterEqCreatedAt, filterEqEventName, filterEqId, filterEqObjectId, filterEqObjectName, filterEqObjectType, filterEqPriority, filterEqProjectId, filterEqProjectName, filterEqSubjectId, filterEqSubjectName, filterEqSubjectType, filterEqUser, pagePage, pageSize, pageSort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ActivityControllerApi - factory interface
 * @export
 */
export const ActivityControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary getActivity
         * @param {number} activityId activityId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityUsingGET(activityId: number, projectName: string, options?: any) {
            return ActivityControllerApiFp(configuration).getActivityUsingGET(activityId, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get activities for test item
         * @param {number} itemId itemId
         * @param {string} projectName projectName
         * @param {string} [filterEqAction] Filters by &#39;action&#39;
         * @param {Date} [filterEqCreatedAt] Filters by &#39;createdAt&#39;
         * @param {string} [filterEqEventName] Filters by &#39;eventName&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {number} [filterEqObjectId] Filters by &#39;objectId&#39;
         * @param {string} [filterEqObjectName] Filters by &#39;objectName&#39;
         * @param {string} [filterEqObjectType] Filters by &#39;objectType&#39;
         * @param {string} [filterEqPriority] Filters by &#39;priority&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {string} [filterEqProjectName] Filters by &#39;projectName&#39;
         * @param {number} [filterEqSubjectId] Filters by &#39;subjectId&#39;
         * @param {string} [filterEqSubjectName] Filters by &#39;subjectName&#39;
         * @param {string} [filterEqSubjectType] Filters by &#39;subjectType&#39;
         * @param {string} [filterEqUser] Filters by &#39;user&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestItemActivitiesUsingGET(itemId: number, projectName: string, filterEqAction?: string, filterEqCreatedAt?: Date, filterEqEventName?: string, filterEqId?: number, filterEqObjectId?: number, filterEqObjectName?: string, filterEqObjectType?: string, filterEqPriority?: string, filterEqProjectId?: number, filterEqProjectName?: string, filterEqSubjectId?: number, filterEqSubjectName?: string, filterEqSubjectType?: string, filterEqUser?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any) {
            return ActivityControllerApiFp(configuration).getTestItemActivitiesUsingGET(itemId, projectName, filterEqAction, filterEqCreatedAt, filterEqEventName, filterEqId, filterEqObjectId, filterEqObjectName, filterEqObjectType, filterEqPriority, filterEqProjectId, filterEqProjectName, filterEqSubjectId, filterEqSubjectName, filterEqSubjectType, filterEqUser, pagePage, pageSize, pageSort, options)(fetch, basePath);
        },
    };
};

/**
 * ActivityControllerApi - object-oriented interface
 * @export
 * @class ActivityControllerApi
 * @extends {BaseAPI}
 */
export class ActivityControllerApi extends BaseAPI {
    /**
     *
     * @summary getActivity
     * @param {number} activityId activityId
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityControllerApi
     */
    public getActivityUsingGET(activityId: number, projectName: string, options?: any) {
        return ActivityControllerApiFp(this.configuration).getActivityUsingGET(activityId, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get activities for test item
     * @param {number} itemId itemId
     * @param {string} projectName projectName
     * @param {string} [filterEqAction] Filters by &#39;action&#39;
     * @param {Date} [filterEqCreatedAt] Filters by &#39;createdAt&#39;
     * @param {string} [filterEqEventName] Filters by &#39;eventName&#39;
     * @param {number} [filterEqId] Filters by &#39;id&#39;
     * @param {number} [filterEqObjectId] Filters by &#39;objectId&#39;
     * @param {string} [filterEqObjectName] Filters by &#39;objectName&#39;
     * @param {string} [filterEqObjectType] Filters by &#39;objectType&#39;
     * @param {string} [filterEqPriority] Filters by &#39;priority&#39;
     * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
     * @param {string} [filterEqProjectName] Filters by &#39;projectName&#39;
     * @param {number} [filterEqSubjectId] Filters by &#39;subjectId&#39;
     * @param {string} [filterEqSubjectName] Filters by &#39;subjectName&#39;
     * @param {string} [filterEqSubjectType] Filters by &#39;subjectType&#39;
     * @param {string} [filterEqUser] Filters by &#39;user&#39;
     * @param {number} [pagePage] Results page you want to retrieve (0..N)
     * @param {number} [pageSize] Number of records per page
     * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityControllerApi
     */
    public getTestItemActivitiesUsingGET(itemId: number, projectName: string, filterEqAction?: string, filterEqCreatedAt?: Date, filterEqEventName?: string, filterEqId?: number, filterEqObjectId?: number, filterEqObjectName?: string, filterEqObjectType?: string, filterEqPriority?: string, filterEqProjectId?: number, filterEqProjectName?: string, filterEqSubjectId?: number, filterEqSubjectName?: string, filterEqSubjectType?: string, filterEqUser?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any) {
        return ActivityControllerApiFp(this.configuration).getTestItemActivitiesUsingGET(itemId, projectName, filterEqAction, filterEqCreatedAt, filterEqEventName, filterEqId, filterEqObjectId, filterEqObjectName, filterEqObjectType, filterEqPriority, filterEqProjectId, filterEqProjectName, filterEqSubjectId, filterEqSubjectName, filterEqSubjectType, filterEqUser, pagePage, pageSize, pageSort, options)(this.fetch, this.basePath);
    }

}

/**
 * ActivityEventControllerApi - fetch parameter creator
 * @export
 */
export const ActivityEventControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Get activities by search criteria
         * @param {number} limit limit
         * @param {number} offset offset
         * @param {'ASC' | 'DESC'} order order
         * @param {SearchCriteriaRQ} searchCriteria searchCriteria
         * @param {string} sort sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivitiesUsingPOST(limit: number, offset: number, order: 'ASC' | 'DESC', searchCriteria: SearchCriteriaRQ, sort: string, options: any = {}): FetchArgs {
            // verify required parameter 'limit' is not null or undefined
            if (limit === null || limit === undefined) {
                throw new RequiredError('limit', 'Required parameter limit was null or undefined when calling getActivitiesUsingPOST.');
            }
            // verify required parameter 'offset' is not null or undefined
            if (offset === null || offset === undefined) {
                throw new RequiredError('offset', 'Required parameter offset was null or undefined when calling getActivitiesUsingPOST.');
            }
            // verify required parameter 'order' is not null or undefined
            if (order === null || order === undefined) {
                throw new RequiredError('order', 'Required parameter order was null or undefined when calling getActivitiesUsingPOST.');
            }
            // verify required parameter 'searchCriteria' is not null or undefined
            if (searchCriteria === null || searchCriteria === undefined) {
                throw new RequiredError('searchCriteria', 'Required parameter searchCriteria was null or undefined when calling getActivitiesUsingPOST.');
            }
            // verify required parameter 'sort' is not null or undefined
            if (sort === null || sort === undefined) {
                throw new RequiredError('sort', 'Required parameter sort was null or undefined when calling getActivitiesUsingPOST.');
            }
            const localVarPath = `/v1/activities/searches`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SearchCriteriaRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(searchCriteria || {}) : (searchCriteria || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only for current project
         * @summary Load project activities subjectNames by filter
         * @param {string} filterCntSubjectName filter.cnt.subjectName
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectSubjectNameUsingGET(filterCntSubjectName: string, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'filterCntSubjectName' is not null or undefined
            if (filterCntSubjectName === null || filterCntSubjectName === undefined) {
                throw new RequiredError('filterCntSubjectName', 'Required parameter filterCntSubjectName was null or undefined when calling getProjectSubjectNameUsingGET.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getProjectSubjectNameUsingGET.');
            }
            const localVarPath = `/v1/activities/{projectName}/subjectName`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filterCntSubjectName !== undefined) {
                localVarQueryParameter['filter.cnt.subjectName'] = filterCntSubjectName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivityEventControllerApi - functional programming interface
 * @export
 */
export const ActivityEventControllerApiFp = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Get activities by search criteria
         * @param {number} limit limit
         * @param {number} offset offset
         * @param {'ASC' | 'DESC'} order order
         * @param {SearchCriteriaRQ} searchCriteria searchCriteria
         * @param {string} sort sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivitiesUsingPOST(limit: number, offset: number, order: 'ASC' | 'DESC', searchCriteria: SearchCriteriaRQ, sort: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PagedResponseActivityEventResource> {
            const localVarFetchArgs = ActivityEventControllerApiFetchParamCreator(configuration).getActivitiesUsingPOST(limit, offset, order, searchCriteria, sort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Only for current project
         * @summary Load project activities subjectNames by filter
         * @param {string} filterCntSubjectName filter.cnt.subjectName
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectSubjectNameUsingGET(filterCntSubjectName: string, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = ActivityEventControllerApiFetchParamCreator(configuration).getProjectSubjectNameUsingGET(filterCntSubjectName, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ActivityEventControllerApi - factory interface
 * @export
 */
export const ActivityEventControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Get activities by search criteria
         * @param {number} limit limit
         * @param {number} offset offset
         * @param {'ASC' | 'DESC'} order order
         * @param {SearchCriteriaRQ} searchCriteria searchCriteria
         * @param {string} sort sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivitiesUsingPOST(limit: number, offset: number, order: 'ASC' | 'DESC', searchCriteria: SearchCriteriaRQ, sort: string, options?: any) {
            return ActivityEventControllerApiFp(configuration).getActivitiesUsingPOST(limit, offset, order, searchCriteria, sort, options)(fetch, basePath);
        },
        /**
         * Only for current project
         * @summary Load project activities subjectNames by filter
         * @param {string} filterCntSubjectName filter.cnt.subjectName
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectSubjectNameUsingGET(filterCntSubjectName: string, projectName: string, options?: any) {
            return ActivityEventControllerApiFp(configuration).getProjectSubjectNameUsingGET(filterCntSubjectName, projectName, options)(fetch, basePath);
        },
    };
};

/**
 * ActivityEventControllerApi - object-oriented interface
 * @export
 * @class ActivityEventControllerApi
 * @extends {BaseAPI}
 */
export class ActivityEventControllerApi extends BaseAPI {
    /**
     *
     * @summary Get activities by search criteria
     * @param {number} limit limit
     * @param {number} offset offset
     * @param {'ASC' | 'DESC'} order order
     * @param {SearchCriteriaRQ} searchCriteria searchCriteria
     * @param {string} sort sort
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityEventControllerApi
     */
    public getActivitiesUsingPOST(limit: number, offset: number, order: 'ASC' | 'DESC', searchCriteria: SearchCriteriaRQ, sort: string, options?: any) {
        return ActivityEventControllerApiFp(this.configuration).getActivitiesUsingPOST(limit, offset, order, searchCriteria, sort, options)(this.fetch, this.basePath);
    }

    /**
     * Only for current project
     * @summary Load project activities subjectNames by filter
     * @param {string} filterCntSubjectName filter.cnt.subjectName
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivityEventControllerApi
     */
    public getProjectSubjectNameUsingGET(filterCntSubjectName: string, projectName: string, options?: any) {
        return ActivityEventControllerApiFp(this.configuration).getProjectSubjectNameUsingGET(filterCntSubjectName, projectName, options)(this.fetch, this.basePath);
    }

}

/**
 * BugTrackingSystemControllerApi - fetch parameter creator
 * @export
 */
export const BugTrackingSystemControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Post ticket to the bts integration
         * @param {number} integrationId integrationId
         * @param {string} projectName projectName
         * @param {PostTicketRQ} ticketRQ ticketRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIssueUsingPOST(integrationId: number, projectName: string, ticketRQ: PostTicketRQ, options: any = {}): FetchArgs {
            // verify required parameter 'integrationId' is not null or undefined
            if (integrationId === null || integrationId === undefined) {
                throw new RequiredError('integrationId', 'Required parameter integrationId was null or undefined when calling createIssueUsingPOST.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling createIssueUsingPOST.');
            }
            // verify required parameter 'ticketRQ' is not null or undefined
            if (ticketRQ === null || ticketRQ === undefined) {
                throw new RequiredError('ticketRQ', 'Required parameter ticketRQ was null or undefined when calling createIssueUsingPOST.');
            }
            const localVarPath = `/v1/bts/{projectName}/{integrationId}/ticket`
                .replace(`{${"integrationId"}}`, encodeURIComponent(String(integrationId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PostTicketRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(ticketRQ || {}) : (ticketRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get list of existed issue types in bts
         * @param {number} integrationId integrationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowableIssueTypesUsingGET(integrationId: number, options: any = {}): FetchArgs {
            // verify required parameter 'integrationId' is not null or undefined
            if (integrationId === null || integrationId === undefined) {
                throw new RequiredError('integrationId', 'Required parameter integrationId was null or undefined when calling getAllowableIssueTypesUsingGET.');
            }
            const localVarPath = `/v1/bts/{integrationId}/issue_types`
                .replace(`{${"integrationId"}}`, encodeURIComponent(String(integrationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get list of allowable issue types for bug tracking system
         * @param {number} integrationId integrationId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowableIssueTypesUsingGET1(integrationId: number, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'integrationId' is not null or undefined
            if (integrationId === null || integrationId === undefined) {
                throw new RequiredError('integrationId', 'Required parameter integrationId was null or undefined when calling getAllowableIssueTypesUsingGET1.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getAllowableIssueTypesUsingGET1.');
            }
            const localVarPath = `/v1/bts/{projectName}/{integrationId}/issue_types`
                .replace(`{${"integrationId"}}`, encodeURIComponent(String(integrationId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get list of fields required for posting ticket
         * @param {number} integrationId integrationId
         * @param {string} issueType issueType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSetOfIntegrationSystemFieldsUsingGET(integrationId: number, issueType: string, options: any = {}): FetchArgs {
            // verify required parameter 'integrationId' is not null or undefined
            if (integrationId === null || integrationId === undefined) {
                throw new RequiredError('integrationId', 'Required parameter integrationId was null or undefined when calling getSetOfIntegrationSystemFieldsUsingGET.');
            }
            // verify required parameter 'issueType' is not null or undefined
            if (issueType === null || issueType === undefined) {
                throw new RequiredError('issueType', 'Required parameter issueType was null or undefined when calling getSetOfIntegrationSystemFieldsUsingGET.');
            }
            const localVarPath = `/v1/bts/{integrationId}/fields-set`
                .replace(`{${"integrationId"}}`, encodeURIComponent(String(integrationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (issueType !== undefined) {
                localVarQueryParameter['issueType'] = issueType;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get list of fields required for posting ticket in concrete integration
         * @param {number} integrationId integrationId
         * @param {string} issueType issueType
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSetOfIntegrationSystemFieldsUsingGET1(integrationId: number, issueType: string, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'integrationId' is not null or undefined
            if (integrationId === null || integrationId === undefined) {
                throw new RequiredError('integrationId', 'Required parameter integrationId was null or undefined when calling getSetOfIntegrationSystemFieldsUsingGET1.');
            }
            // verify required parameter 'issueType' is not null or undefined
            if (issueType === null || issueType === undefined) {
                throw new RequiredError('issueType', 'Required parameter issueType was null or undefined when calling getSetOfIntegrationSystemFieldsUsingGET1.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getSetOfIntegrationSystemFieldsUsingGET1.');
            }
            const localVarPath = `/v1/bts/{projectName}/{integrationId}/fields-set`
                .replace(`{${"integrationId"}}`, encodeURIComponent(String(integrationId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (issueType !== undefined) {
                localVarQueryParameter['issueType'] = issueType;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get ticket from the bts integration
         * @param {string} btsProject btsProject
         * @param {string} btsUrl btsUrl
         * @param {string} projectName projectName
         * @param {string} ticketId ticketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicketUsingGET(btsProject: string, btsUrl: string, projectName: string, ticketId: string, options: any = {}): FetchArgs {
            // verify required parameter 'btsProject' is not null or undefined
            if (btsProject === null || btsProject === undefined) {
                throw new RequiredError('btsProject', 'Required parameter btsProject was null or undefined when calling getTicketUsingGET.');
            }
            // verify required parameter 'btsUrl' is not null or undefined
            if (btsUrl === null || btsUrl === undefined) {
                throw new RequiredError('btsUrl', 'Required parameter btsUrl was null or undefined when calling getTicketUsingGET.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getTicketUsingGET.');
            }
            // verify required parameter 'ticketId' is not null or undefined
            if (ticketId === null || ticketId === undefined) {
                throw new RequiredError('ticketId', 'Required parameter ticketId was null or undefined when calling getTicketUsingGET.');
            }
            const localVarPath = `/v1/bts/{projectName}/ticket/{ticketId}`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)))
                .replace(`{${"ticketId"}}`, encodeURIComponent(String(ticketId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (btsProject !== undefined) {
                localVarQueryParameter['btsProject'] = btsProject;
            }

            if (btsUrl !== undefined) {
                localVarQueryParameter['btsUrl'] = btsUrl;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BugTrackingSystemControllerApi - functional programming interface
 * @export
 */
export const BugTrackingSystemControllerApiFp = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Post ticket to the bts integration
         * @param {number} integrationId integrationId
         * @param {string} projectName projectName
         * @param {PostTicketRQ} ticketRQ ticketRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIssueUsingPOST(integrationId: number, projectName: string, ticketRQ: PostTicketRQ, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Ticket> {
            const localVarFetchArgs = BugTrackingSystemControllerApiFetchParamCreator(configuration).createIssueUsingPOST(integrationId, projectName, ticketRQ, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get list of existed issue types in bts
         * @param {number} integrationId integrationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowableIssueTypesUsingGET(integrationId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = BugTrackingSystemControllerApiFetchParamCreator(configuration).getAllowableIssueTypesUsingGET(integrationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get list of allowable issue types for bug tracking system
         * @param {number} integrationId integrationId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowableIssueTypesUsingGET1(integrationId: number, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = BugTrackingSystemControllerApiFetchParamCreator(configuration).getAllowableIssueTypesUsingGET1(integrationId, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get list of fields required for posting ticket
         * @param {number} integrationId integrationId
         * @param {string} issueType issueType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSetOfIntegrationSystemFieldsUsingGET(integrationId: number, issueType: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PostFormField>> {
            const localVarFetchArgs = BugTrackingSystemControllerApiFetchParamCreator(configuration).getSetOfIntegrationSystemFieldsUsingGET(integrationId, issueType, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get list of fields required for posting ticket in concrete integration
         * @param {number} integrationId integrationId
         * @param {string} issueType issueType
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSetOfIntegrationSystemFieldsUsingGET1(integrationId: number, issueType: string, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PostFormField>> {
            const localVarFetchArgs = BugTrackingSystemControllerApiFetchParamCreator(configuration).getSetOfIntegrationSystemFieldsUsingGET1(integrationId, issueType, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get ticket from the bts integration
         * @param {string} btsProject btsProject
         * @param {string} btsUrl btsUrl
         * @param {string} projectName projectName
         * @param {string} ticketId ticketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicketUsingGET(btsProject: string, btsUrl: string, projectName: string, ticketId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Ticket> {
            const localVarFetchArgs = BugTrackingSystemControllerApiFetchParamCreator(configuration).getTicketUsingGET(btsProject, btsUrl, projectName, ticketId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BugTrackingSystemControllerApi - factory interface
 * @export
 */
export const BugTrackingSystemControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Post ticket to the bts integration
         * @param {number} integrationId integrationId
         * @param {string} projectName projectName
         * @param {PostTicketRQ} ticketRQ ticketRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIssueUsingPOST(integrationId: number, projectName: string, ticketRQ: PostTicketRQ, options?: any) {
            return BugTrackingSystemControllerApiFp(configuration).createIssueUsingPOST(integrationId, projectName, ticketRQ, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get list of existed issue types in bts
         * @param {number} integrationId integrationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowableIssueTypesUsingGET(integrationId: number, options?: any) {
            return BugTrackingSystemControllerApiFp(configuration).getAllowableIssueTypesUsingGET(integrationId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get list of allowable issue types for bug tracking system
         * @param {number} integrationId integrationId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllowableIssueTypesUsingGET1(integrationId: number, projectName: string, options?: any) {
            return BugTrackingSystemControllerApiFp(configuration).getAllowableIssueTypesUsingGET1(integrationId, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get list of fields required for posting ticket
         * @param {number} integrationId integrationId
         * @param {string} issueType issueType
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSetOfIntegrationSystemFieldsUsingGET(integrationId: number, issueType: string, options?: any) {
            return BugTrackingSystemControllerApiFp(configuration).getSetOfIntegrationSystemFieldsUsingGET(integrationId, issueType, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get list of fields required for posting ticket in concrete integration
         * @param {number} integrationId integrationId
         * @param {string} issueType issueType
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSetOfIntegrationSystemFieldsUsingGET1(integrationId: number, issueType: string, projectName: string, options?: any) {
            return BugTrackingSystemControllerApiFp(configuration).getSetOfIntegrationSystemFieldsUsingGET1(integrationId, issueType, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get ticket from the bts integration
         * @param {string} btsProject btsProject
         * @param {string} btsUrl btsUrl
         * @param {string} projectName projectName
         * @param {string} ticketId ticketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicketUsingGET(btsProject: string, btsUrl: string, projectName: string, ticketId: string, options?: any) {
            return BugTrackingSystemControllerApiFp(configuration).getTicketUsingGET(btsProject, btsUrl, projectName, ticketId, options)(fetch, basePath);
        },
    };
};

/**
 * BugTrackingSystemControllerApi - object-oriented interface
 * @export
 * @class BugTrackingSystemControllerApi
 * @extends {BaseAPI}
 */
export class BugTrackingSystemControllerApi extends BaseAPI {
    /**
     *
     * @summary Post ticket to the bts integration
     * @param {number} integrationId integrationId
     * @param {string} projectName projectName
     * @param {PostTicketRQ} ticketRQ ticketRQ
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BugTrackingSystemControllerApi
     */
    public createIssueUsingPOST(integrationId: number, projectName: string, ticketRQ: PostTicketRQ, options?: any) {
        return BugTrackingSystemControllerApiFp(this.configuration).createIssueUsingPOST(integrationId, projectName, ticketRQ, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get list of existed issue types in bts
     * @param {number} integrationId integrationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BugTrackingSystemControllerApi
     */
    public getAllowableIssueTypesUsingGET(integrationId: number, options?: any) {
        return BugTrackingSystemControllerApiFp(this.configuration).getAllowableIssueTypesUsingGET(integrationId, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get list of allowable issue types for bug tracking system
     * @param {number} integrationId integrationId
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BugTrackingSystemControllerApi
     */
    public getAllowableIssueTypesUsingGET1(integrationId: number, projectName: string, options?: any) {
        return BugTrackingSystemControllerApiFp(this.configuration).getAllowableIssueTypesUsingGET1(integrationId, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get list of fields required for posting ticket
     * @param {number} integrationId integrationId
     * @param {string} issueType issueType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BugTrackingSystemControllerApi
     */
    public getSetOfIntegrationSystemFieldsUsingGET(integrationId: number, issueType: string, options?: any) {
        return BugTrackingSystemControllerApiFp(this.configuration).getSetOfIntegrationSystemFieldsUsingGET(integrationId, issueType, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get list of fields required for posting ticket in concrete integration
     * @param {number} integrationId integrationId
     * @param {string} issueType issueType
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BugTrackingSystemControllerApi
     */
    public getSetOfIntegrationSystemFieldsUsingGET1(integrationId: number, issueType: string, projectName: string, options?: any) {
        return BugTrackingSystemControllerApiFp(this.configuration).getSetOfIntegrationSystemFieldsUsingGET1(integrationId, issueType, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get ticket from the bts integration
     * @param {string} btsProject btsProject
     * @param {string} btsUrl btsUrl
     * @param {string} projectName projectName
     * @param {string} ticketId ticketId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BugTrackingSystemControllerApi
     */
    public getTicketUsingGET(btsProject: string, btsUrl: string, projectName: string, ticketId: string, options?: any) {
        return BugTrackingSystemControllerApiFp(this.configuration).getTicketUsingGET(btsProject, btsUrl, projectName, ticketId, options)(this.fetch, this.basePath);
    }

}

/**
 * DashboardControllerApi - fetch parameter creator
 * @export
 */
export const DashboardControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Add widget to specified dashboard
         * @param {AddWidgetRq} addWidgetRq addWidgetRq
         * @param {number} dashboardId dashboardId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWidgetUsingPUT(addWidgetRq: AddWidgetRq, dashboardId: number, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'addWidgetRq' is not null or undefined
            if (addWidgetRq === null || addWidgetRq === undefined) {
                throw new RequiredError('addWidgetRq', 'Required parameter addWidgetRq was null or undefined when calling addWidgetUsingPUT.');
            }
            // verify required parameter 'dashboardId' is not null or undefined
            if (dashboardId === null || dashboardId === undefined) {
                throw new RequiredError('dashboardId', 'Required parameter dashboardId was null or undefined when calling addWidgetUsingPUT.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling addWidgetUsingPUT.');
            }
            const localVarPath = `/v1/{projectName}/dashboard/{dashboardId}/add`
                .replace(`{${"dashboardId"}}`, encodeURIComponent(String(dashboardId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'PUT'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddWidgetRq" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(addWidgetRq || {}) : (addWidgetRq || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create dashboard for specified project
         * @param {CreateDashboardRQ} createRQ createRQ
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDashboardUsingPOST(createRQ: CreateDashboardRQ, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'createRQ' is not null or undefined
            if (createRQ === null || createRQ === undefined) {
                throw new RequiredError('createRQ', 'Required parameter createRQ was null or undefined when calling createDashboardUsingPOST.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling createDashboardUsingPOST.');
            }
            const localVarPath = `/v1/{projectName}/dashboard`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateDashboardRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(createRQ || {}) : (createRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete specified dashboard by ID for specified project
         * @param {number} dashboardId dashboardId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboardUsingDELETE(dashboardId: number, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'dashboardId' is not null or undefined
            if (dashboardId === null || dashboardId === undefined) {
                throw new RequiredError('dashboardId', 'Required parameter dashboardId was null or undefined when calling deleteDashboardUsingDELETE.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling deleteDashboardUsingDELETE.');
            }
            const localVarPath = `/v1/{projectName}/dashboard/{dashboardId}`
                .replace(`{${"dashboardId"}}`, encodeURIComponent(String(dashboardId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'DELETE'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all permitted dashboard resources for specified project
         * @param {string} projectName projectName
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {string} [filterEqName] Filters by &#39;name&#39;
         * @param {string} [filterEqOwner] Filters by &#39;owner&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDashboardsUsingGET(projectName: string, filterEqId?: number, filterEqName?: string, filterEqOwner?: string, filterEqProjectId?: number, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getAllDashboardsUsingGET.');
            }
            const localVarPath = `/v1/{projectName}/dashboard`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filterEqId !== undefined) {
                localVarQueryParameter['filter.eq.id'] = filterEqId;
            }

            if (filterEqName !== undefined) {
                localVarQueryParameter['filter.eq.name'] = filterEqName;
            }

            if (filterEqOwner !== undefined) {
                localVarQueryParameter['filter.eq.owner'] = filterEqOwner;
            }

            if (filterEqProjectId !== undefined) {
                localVarQueryParameter['filter.eq.projectId'] = filterEqProjectId;
            }

            if (pagePage !== undefined) {
                localVarQueryParameter['page.page'] = pagePage;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page.size'] = pageSize;
            }

            if (pageSort) {
                localVarQueryParameter['page.sort'] = pageSort;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get specified dashboard by ID for specified project
         * @param {number} dashboardId dashboardId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardUsingGET(dashboardId: number, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'dashboardId' is not null or undefined
            if (dashboardId === null || dashboardId === undefined) {
                throw new RequiredError('dashboardId', 'Required parameter dashboardId was null or undefined when calling getDashboardUsingGET.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getDashboardUsingGET.');
            }
            const localVarPath = `/v1/{projectName}/dashboard/{dashboardId}`
                .replace(`{${"dashboardId"}}`, encodeURIComponent(String(dashboardId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Remove widget from specified dashboard
         * @param {number} dashboardId dashboardId
         * @param {string} projectName projectName
         * @param {number} widgetId widgetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWidgetUsingDELETE(dashboardId: number, projectName: string, widgetId: number, options: any = {}): FetchArgs {
            // verify required parameter 'dashboardId' is not null or undefined
            if (dashboardId === null || dashboardId === undefined) {
                throw new RequiredError('dashboardId', 'Required parameter dashboardId was null or undefined when calling removeWidgetUsingDELETE.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling removeWidgetUsingDELETE.');
            }
            // verify required parameter 'widgetId' is not null or undefined
            if (widgetId === null || widgetId === undefined) {
                throw new RequiredError('widgetId', 'Required parameter widgetId was null or undefined when calling removeWidgetUsingDELETE.');
            }
            const localVarPath = `/v1/{projectName}/dashboard/{dashboardId}/{widgetId}`
                .replace(`{${"dashboardId"}}`, encodeURIComponent(String(dashboardId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)))
                .replace(`{${"widgetId"}}`, encodeURIComponent(String(widgetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'DELETE'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update specified dashboard for specified project
         * @param {number} dashboardId dashboardId
         * @param {string} projectName projectName
         * @param {UpdateDashboardRQ} updateRQ updateRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDashboardUsingPUT(dashboardId: number, projectName: string, updateRQ: UpdateDashboardRQ, options: any = {}): FetchArgs {
            // verify required parameter 'dashboardId' is not null or undefined
            if (dashboardId === null || dashboardId === undefined) {
                throw new RequiredError('dashboardId', 'Required parameter dashboardId was null or undefined when calling updateDashboardUsingPUT.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling updateDashboardUsingPUT.');
            }
            // verify required parameter 'updateRQ' is not null or undefined
            if (updateRQ === null || updateRQ === undefined) {
                throw new RequiredError('updateRQ', 'Required parameter updateRQ was null or undefined when calling updateDashboardUsingPUT.');
            }
            const localVarPath = `/v1/{projectName}/dashboard/{dashboardId}`
                .replace(`{${"dashboardId"}}`, encodeURIComponent(String(dashboardId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'PUT'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateDashboardRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(updateRQ || {}) : (updateRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DashboardControllerApi - functional programming interface
 * @export
 */
export const DashboardControllerApiFp = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Add widget to specified dashboard
         * @param {AddWidgetRq} addWidgetRq addWidgetRq
         * @param {number} dashboardId dashboardId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWidgetUsingPUT(addWidgetRq: AddWidgetRq, dashboardId: number, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = DashboardControllerApiFetchParamCreator(configuration).addWidgetUsingPUT(addWidgetRq, dashboardId, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create dashboard for specified project
         * @param {CreateDashboardRQ} createRQ createRQ
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDashboardUsingPOST(createRQ: CreateDashboardRQ, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EntryCreatedRS> {
            const localVarFetchArgs = DashboardControllerApiFetchParamCreator(configuration).createDashboardUsingPOST(createRQ, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete specified dashboard by ID for specified project
         * @param {number} dashboardId dashboardId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboardUsingDELETE(dashboardId: number, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = DashboardControllerApiFetchParamCreator(configuration).deleteDashboardUsingDELETE(dashboardId, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all permitted dashboard resources for specified project
         * @param {string} projectName projectName
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {string} [filterEqName] Filters by &#39;name&#39;
         * @param {string} [filterEqOwner] Filters by &#39;owner&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDashboardsUsingGET(projectName: string, filterEqId?: number, filterEqName?: string, filterEqOwner?: string, filterEqProjectId?: number, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<IterableDashboardResource> {
            const localVarFetchArgs = DashboardControllerApiFetchParamCreator(configuration).getAllDashboardsUsingGET(projectName, filterEqId, filterEqName, filterEqOwner, filterEqProjectId, pagePage, pageSize, pageSort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get specified dashboard by ID for specified project
         * @param {number} dashboardId dashboardId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardUsingGET(dashboardId: number, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DashboardResource> {
            const localVarFetchArgs = DashboardControllerApiFetchParamCreator(configuration).getDashboardUsingGET(dashboardId, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Remove widget from specified dashboard
         * @param {number} dashboardId dashboardId
         * @param {string} projectName projectName
         * @param {number} widgetId widgetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWidgetUsingDELETE(dashboardId: number, projectName: string, widgetId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = DashboardControllerApiFetchParamCreator(configuration).removeWidgetUsingDELETE(dashboardId, projectName, widgetId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update specified dashboard for specified project
         * @param {number} dashboardId dashboardId
         * @param {string} projectName projectName
         * @param {UpdateDashboardRQ} updateRQ updateRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDashboardUsingPUT(dashboardId: number, projectName: string, updateRQ: UpdateDashboardRQ, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = DashboardControllerApiFetchParamCreator(configuration).updateDashboardUsingPUT(dashboardId, projectName, updateRQ, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DashboardControllerApi - factory interface
 * @export
 */
export const DashboardControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Add widget to specified dashboard
         * @param {AddWidgetRq} addWidgetRq addWidgetRq
         * @param {number} dashboardId dashboardId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWidgetUsingPUT(addWidgetRq: AddWidgetRq, dashboardId: number, projectName: string, options?: any) {
            return DashboardControllerApiFp(configuration).addWidgetUsingPUT(addWidgetRq, dashboardId, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create dashboard for specified project
         * @param {CreateDashboardRQ} createRQ createRQ
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDashboardUsingPOST(createRQ: CreateDashboardRQ, projectName: string, options?: any) {
            return DashboardControllerApiFp(configuration).createDashboardUsingPOST(createRQ, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete specified dashboard by ID for specified project
         * @param {number} dashboardId dashboardId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDashboardUsingDELETE(dashboardId: number, projectName: string, options?: any) {
            return DashboardControllerApiFp(configuration).deleteDashboardUsingDELETE(dashboardId, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get all permitted dashboard resources for specified project
         * @param {string} projectName projectName
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {string} [filterEqName] Filters by &#39;name&#39;
         * @param {string} [filterEqOwner] Filters by &#39;owner&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDashboardsUsingGET(projectName: string, filterEqId?: number, filterEqName?: string, filterEqOwner?: string, filterEqProjectId?: number, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any) {
            return DashboardControllerApiFp(configuration).getAllDashboardsUsingGET(projectName, filterEqId, filterEqName, filterEqOwner, filterEqProjectId, pagePage, pageSize, pageSort, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get specified dashboard by ID for specified project
         * @param {number} dashboardId dashboardId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardUsingGET(dashboardId: number, projectName: string, options?: any) {
            return DashboardControllerApiFp(configuration).getDashboardUsingGET(dashboardId, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Remove widget from specified dashboard
         * @param {number} dashboardId dashboardId
         * @param {string} projectName projectName
         * @param {number} widgetId widgetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWidgetUsingDELETE(dashboardId: number, projectName: string, widgetId: number, options?: any) {
            return DashboardControllerApiFp(configuration).removeWidgetUsingDELETE(dashboardId, projectName, widgetId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update specified dashboard for specified project
         * @param {number} dashboardId dashboardId
         * @param {string} projectName projectName
         * @param {UpdateDashboardRQ} updateRQ updateRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDashboardUsingPUT(dashboardId: number, projectName: string, updateRQ: UpdateDashboardRQ, options?: any) {
            return DashboardControllerApiFp(configuration).updateDashboardUsingPUT(dashboardId, projectName, updateRQ, options)(fetch, basePath);
        },
    };
};

/**
 * DashboardControllerApi - object-oriented interface
 * @export
 * @class DashboardControllerApi
 * @extends {BaseAPI}
 */
export class DashboardControllerApi extends BaseAPI {
    /**
     *
     * @summary Add widget to specified dashboard
     * @param {AddWidgetRq} addWidgetRq addWidgetRq
     * @param {number} dashboardId dashboardId
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardControllerApi
     */
    public addWidgetUsingPUT(addWidgetRq: AddWidgetRq, dashboardId: number, projectName: string, options?: any) {
        return DashboardControllerApiFp(this.configuration).addWidgetUsingPUT(addWidgetRq, dashboardId, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Create dashboard for specified project
     * @param {CreateDashboardRQ} createRQ createRQ
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardControllerApi
     */
    public createDashboardUsingPOST(createRQ: CreateDashboardRQ, projectName: string, options?: any) {
        return DashboardControllerApiFp(this.configuration).createDashboardUsingPOST(createRQ, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete specified dashboard by ID for specified project
     * @param {number} dashboardId dashboardId
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardControllerApi
     */
    public deleteDashboardUsingDELETE(dashboardId: number, projectName: string, options?: any) {
        return DashboardControllerApiFp(this.configuration).deleteDashboardUsingDELETE(dashboardId, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get all permitted dashboard resources for specified project
     * @param {string} projectName projectName
     * @param {number} [filterEqId] Filters by &#39;id&#39;
     * @param {string} [filterEqName] Filters by &#39;name&#39;
     * @param {string} [filterEqOwner] Filters by &#39;owner&#39;
     * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
     * @param {number} [pagePage] Results page you want to retrieve (0..N)
     * @param {number} [pageSize] Number of records per page
     * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardControllerApi
     */
    public getAllDashboardsUsingGET(projectName: string, filterEqId?: number, filterEqName?: string, filterEqOwner?: string, filterEqProjectId?: number, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any) {
        return DashboardControllerApiFp(this.configuration).getAllDashboardsUsingGET(projectName, filterEqId, filterEqName, filterEqOwner, filterEqProjectId, pagePage, pageSize, pageSort, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get specified dashboard by ID for specified project
     * @param {number} dashboardId dashboardId
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardControllerApi
     */
    public getDashboardUsingGET(dashboardId: number, projectName: string, options?: any) {
        return DashboardControllerApiFp(this.configuration).getDashboardUsingGET(dashboardId, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Remove widget from specified dashboard
     * @param {number} dashboardId dashboardId
     * @param {string} projectName projectName
     * @param {number} widgetId widgetId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardControllerApi
     */
    public removeWidgetUsingDELETE(dashboardId: number, projectName: string, widgetId: number, options?: any) {
        return DashboardControllerApiFp(this.configuration).removeWidgetUsingDELETE(dashboardId, projectName, widgetId, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Update specified dashboard for specified project
     * @param {number} dashboardId dashboardId
     * @param {string} projectName projectName
     * @param {UpdateDashboardRQ} updateRQ updateRQ
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardControllerApi
     */
    public updateDashboardUsingPUT(dashboardId: number, projectName: string, updateRQ: UpdateDashboardRQ, options?: any) {
        return DashboardControllerApiFp(this.configuration).updateDashboardUsingPUT(dashboardId, projectName, updateRQ, options)(this.fetch, this.basePath);
    }

}

/**
 * DemoDataControllerApi - fetch parameter creator
 * @export
 */
export const DemoDataControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary generate
         * @param {DemoDataRq} demoDataRq demoDataRq
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateUsingPOST(demoDataRq: DemoDataRq, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'demoDataRq' is not null or undefined
            if (demoDataRq === null || demoDataRq === undefined) {
                throw new RequiredError('demoDataRq', 'Required parameter demoDataRq was null or undefined when calling generateUsingPOST.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling generateUsingPOST.');
            }
            const localVarPath = `/v1/demo/{projectName}/generate`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DemoDataRq" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(demoDataRq || {}) : (demoDataRq || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DemoDataControllerApi - functional programming interface
 * @export
 */
export const DemoDataControllerApiFp = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary generate
         * @param {DemoDataRq} demoDataRq demoDataRq
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateUsingPOST(demoDataRq: DemoDataRq, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DemoDataRs> {
            const localVarFetchArgs = DemoDataControllerApiFetchParamCreator(configuration).generateUsingPOST(demoDataRq, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DemoDataControllerApi - factory interface
 * @export
 */
export const DemoDataControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary generate
         * @param {DemoDataRq} demoDataRq demoDataRq
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateUsingPOST(demoDataRq: DemoDataRq, projectName: string, options?: any) {
            return DemoDataControllerApiFp(configuration).generateUsingPOST(demoDataRq, projectName, options)(fetch, basePath);
        },
    };
};

/**
 * DemoDataControllerApi - object-oriented interface
 * @export
 * @class DemoDataControllerApi
 * @extends {BaseAPI}
 */
export class DemoDataControllerApi extends BaseAPI {
    /**
     *
     * @summary generate
     * @param {DemoDataRq} demoDataRq demoDataRq
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemoDataControllerApi
     */
    public generateUsingPOST(demoDataRq: DemoDataRq, projectName: string, options?: any) {
        return DemoDataControllerApiFp(this.configuration).generateUsingPOST(demoDataRq, projectName, options)(this.fetch, this.basePath);
    }

}

/**
 * DeprecatedUserControllerApi - fetch parameter creator
 * @export
 */
export const DeprecatedUserControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Change own password (DEPRECATED)
         * @param {ChangePasswordRQ} changePasswordRQ changePasswordRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePasswordUsingPOST(changePasswordRQ: ChangePasswordRQ, options: any = {}): FetchArgs {
            // verify required parameter 'changePasswordRQ' is not null or undefined
            if (changePasswordRQ === null || changePasswordRQ === undefined) {
                throw new RequiredError('changePasswordRQ', 'Required parameter changePasswordRQ was null or undefined when calling changePasswordUsingPOST.');
            }
            const localVarPath = `/v1/user/password/change`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ChangePasswordRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(changePasswordRQ || {}) : (changePasswordRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create new Api Key for current user (DEPRECATED)
         * @param {ApiKeyRQ} apiKeyRQ apiKeyRQ
         * @param {number} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKeyUsingPOST(apiKeyRQ: ApiKeyRQ, userId: number, options: any = {}): FetchArgs {
            // verify required parameter 'apiKeyRQ' is not null or undefined
            if (apiKeyRQ === null || apiKeyRQ === undefined) {
                throw new RequiredError('apiKeyRQ', 'Required parameter apiKeyRQ was null or undefined when calling createApiKeyUsingPOST.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId', 'Required parameter userId was null or undefined when calling createApiKeyUsingPOST.');
            }
            const localVarPath = `/v1/user/{userId}/api-keys`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ApiKeyRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(apiKeyRQ || {}) : (apiKeyRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Register invitation for user who will be created (DEPRECATED)
         * @param {CreateUserRQ} createUserRQ createUserRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserBidUsingPOST(createUserRQ: CreateUserRQ, options: any = {}): FetchArgs {
            // verify required parameter 'createUserRQ' is not null or undefined
            if (createUserRQ === null || createUserRQ === undefined) {
                throw new RequiredError('createUserRQ', 'Required parameter createUserRQ was null or undefined when calling createUserBidUsingPOST.');
            }
            const localVarPath = `/v1/user/bid`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateUserRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(createUserRQ || {}) : (createUserRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allowable only for users with administrator role
         * @summary Create specified user (DEPRECATED)
         * @param {CreateUserRQFull} rq rq
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserByAdminUsingPOST(rq: CreateUserRQFull, options: any = {}): FetchArgs {
            // verify required parameter 'rq' is not null or undefined
            if (rq === null || rq === undefined) {
                throw new RequiredError('rq', 'Required parameter rq was null or undefined when calling createUserByAdminUsingPOST.');
            }
            const localVarPath = `/v1/user`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateUserRQFull" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(rq || {}) : (rq || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Activate invitation and create user in system (DEPRECATED)
         * @param {CreateUserRQConfirm} request request
         * @param {string} uuid uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserUsingPOST(request: CreateUserRQConfirm, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request', 'Required parameter request was null or undefined when calling createUserUsingPOST.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid', 'Required parameter uuid was null or undefined when calling createUserUsingPOST.');
            }
            const localVarPath = `/v1/user/registration`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateUserRQConfirm" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete specified Api Key (DEPRECATED)
         * @param {number} keyId keyId
         * @param {number} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKeyUsingDELETE(keyId: number, userId: number, options: any = {}): FetchArgs {
            // verify required parameter 'keyId' is not null or undefined
            if (keyId === null || keyId === undefined) {
                throw new RequiredError('keyId', 'Required parameter keyId was null or undefined when calling deleteApiKeyUsingDELETE.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId', 'Required parameter userId was null or undefined when calling deleteApiKeyUsingDELETE.');
            }
            const localVarPath = `/v1/user/{userId}/api-keys/{keyId}`
                .replace(`{${"keyId"}}`, encodeURIComponent(String(keyId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'DELETE'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete specified user (DEPRECATED)
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserUsingDELETE(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling deleteUserUsingDELETE.');
            }
            const localVarPath = `/v1/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'DELETE'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete specified users by ids (DEPRECATED)
         * @param {DeleteBulkRQ} deleteBulkRQ deleteBulkRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsersUsingDELETE(deleteBulkRQ: DeleteBulkRQ, options: any = {}): FetchArgs {
            // verify required parameter 'deleteBulkRQ' is not null or undefined
            if (deleteBulkRQ === null || deleteBulkRQ === undefined) {
                throw new RequiredError('deleteBulkRQ', 'Required parameter deleteBulkRQ was null or undefined when calling deleteUsersUsingDELETE.');
            }
            const localVarPath = `/v1/user`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'DELETE'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DeleteBulkRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(deleteBulkRQ || {}) : (deleteBulkRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only for administrators and profile's owner
         * @summary Edit specified user (DEPRECATED)
         * @param {EditUserRQ} editUserRQ editUserRQ
         * @param {string} login login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUserUsingPUT(editUserRQ: EditUserRQ, login: string, options: any = {}): FetchArgs {
            // verify required parameter 'editUserRQ' is not null or undefined
            if (editUserRQ === null || editUserRQ === undefined) {
                throw new RequiredError('editUserRQ', 'Required parameter editUserRQ was null or undefined when calling editUserUsingPUT.');
            }
            // verify required parameter 'login' is not null or undefined
            if (login === null || login === undefined) {
                throw new RequiredError('login', 'Required parameter login was null or undefined when calling editUserUsingPUT.');
            }
            const localVarPath = `/v1/user/{login}`
                .replace(`{${"login"}}`, encodeURIComponent(String(login)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'PUT'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EditUserRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(editUserRQ || {}) : (editUserRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allowable only for users with administrator role
         * @summary Exports information about all users (DEPRECATED)
         * @param {string} [filterEqEmail] Filters by &#39;email&#39;
         * @param {boolean} [filterEqExpired] Filters by &#39;expired&#39;
         * @param {string} [filterEqFullName] Filters by &#39;fullName&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {number} [filterEqLastLogin] Filters by &#39;lastLogin&#39;
         * @param {Array<any>} [filterEqProject] Filters by &#39;project&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {string} [filterEqRole] Filters by &#39;role&#39;
         * @param {number} [filterEqSynchronizationDate] Filters by &#39;synchronizationDate&#39;
         * @param {string} [filterEqType] Filters by &#39;type&#39;
         * @param {string} [filterEqUser] Filters by &#39;user&#39;
         * @param {'csv'} [view] view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportUsingGET(filterEqEmail?: string, filterEqExpired?: boolean, filterEqFullName?: string, filterEqId?: number, filterEqLastLogin?: number, filterEqProject?: Array<any>, filterEqProjectId?: number, filterEqRole?: string, filterEqSynchronizationDate?: number, filterEqType?: string, filterEqUser?: string, view?: 'csv', options: any = {}): FetchArgs {
            const localVarPath = `/v1/user/export`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filterEqEmail !== undefined) {
                localVarQueryParameter['filter.eq.email'] = filterEqEmail;
            }

            if (filterEqExpired !== undefined) {
                localVarQueryParameter['filter.eq.expired'] = filterEqExpired;
            }

            if (filterEqFullName !== undefined) {
                localVarQueryParameter['filter.eq.fullName'] = filterEqFullName;
            }

            if (filterEqId !== undefined) {
                localVarQueryParameter['filter.eq.id'] = filterEqId;
            }

            if (filterEqLastLogin !== undefined) {
                localVarQueryParameter['filter.eq.lastLogin'] = filterEqLastLogin;
            }

            if (filterEqProject) {
                localVarQueryParameter['filter.eq.project'] = filterEqProject;
            }

            if (filterEqProjectId !== undefined) {
                localVarQueryParameter['filter.eq.projectId'] = filterEqProjectId;
            }

            if (filterEqRole !== undefined) {
                localVarQueryParameter['filter.eq.role'] = filterEqRole;
            }

            if (filterEqSynchronizationDate !== undefined) {
                localVarQueryParameter['filter.eq.synchronizationDate'] = filterEqSynchronizationDate;
            }

            if (filterEqType !== undefined) {
                localVarQueryParameter['filter.eq.type'] = filterEqType;
            }

            if (filterEqUser !== undefined) {
                localVarQueryParameter['filter.eq.user'] = filterEqUser;
            }

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only for administrators
         * @summary Find users by term (DEPRECATED)
         * @param {string} term term
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUsersUsingGET(term: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'term' is not null or undefined
            if (term === null || term === undefined) {
                throw new RequiredError('term', 'Required parameter term was null or undefined when calling findUsersUsingGET.');
            }
            const localVarPath = `/v1/user/search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pagePage !== undefined) {
                localVarQueryParameter['page.page'] = pagePage;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page.size'] = pageSize;
            }

            if (pageSort) {
                localVarQueryParameter['page.sort'] = pageSort;
            }

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return information about current logged-in user (DEPRECATED)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyselfUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/v1/user`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return information about current logged-in user (DEPRECATED)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyselfUsingGET1(options: any = {}): FetchArgs {
            const localVarPath = `/v1/user/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get user's registration info (DEPRECATED)
         * @param {string} uuid uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBidInfoUsingGET(uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid', 'Required parameter uuid was null or undefined when calling getUserBidInfoUsingGET.');
            }
            const localVarPath = `/v1/user/registration`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get user's projects (DEPRECATED)
         * @param {string} userName userName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserProjectsUsingGET(userName: string, options: any = {}): FetchArgs {
            // verify required parameter 'userName' is not null or undefined
            if (userName === null || userName === undefined) {
                throw new RequiredError('userName', 'Required parameter userName was null or undefined when calling getUserProjectsUsingGET.');
            }
            const localVarPath = `/v1/user/{userName}/projects`
                .replace(`{${"userName"}}`, encodeURIComponent(String(userName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only for administrators and profile's owner
         * @summary Return information about specified user (DEPRECATED)
         * @param {string} login login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserUsingGET(login: string, options: any = {}): FetchArgs {
            // verify required parameter 'login' is not null or undefined
            if (login === null || login === undefined) {
                throw new RequiredError('login', 'Required parameter login was null or undefined when calling getUserUsingGET.');
            }
            const localVarPath = `/v1/user/{login}`
                .replace(`{${"login"}}`, encodeURIComponent(String(login)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get List of users Api Keys (DEPRECATED)
         * @param {number} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersApiKeysUsingGET(userId: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId', 'Required parameter userId was null or undefined when calling getUsersApiKeysUsingGET.');
            }
            const localVarPath = `/v1/user/{userId}/api-keys`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allowable only for users with administrator role
         * @summary Return information about all users (DEPRECATED)
         * @param {string} [filterEqEmail] Filters by &#39;email&#39;
         * @param {boolean} [filterEqExpired] Filters by &#39;expired&#39;
         * @param {string} [filterEqFullName] Filters by &#39;fullName&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {number} [filterEqLastLogin] Filters by &#39;lastLogin&#39;
         * @param {Array<any>} [filterEqProject] Filters by &#39;project&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {string} [filterEqRole] Filters by &#39;role&#39;
         * @param {number} [filterEqSynchronizationDate] Filters by &#39;synchronizationDate&#39;
         * @param {string} [filterEqType] Filters by &#39;type&#39;
         * @param {string} [filterEqUser] Filters by &#39;user&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUsingGET(filterEqEmail?: string, filterEqExpired?: boolean, filterEqFullName?: string, filterEqId?: number, filterEqLastLogin?: number, filterEqProject?: Array<any>, filterEqProjectId?: number, filterEqRole?: string, filterEqSynchronizationDate?: number, filterEqType?: string, filterEqUser?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/v1/user/all`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filterEqEmail !== undefined) {
                localVarQueryParameter['filter.eq.email'] = filterEqEmail;
            }

            if (filterEqExpired !== undefined) {
                localVarQueryParameter['filter.eq.expired'] = filterEqExpired;
            }

            if (filterEqFullName !== undefined) {
                localVarQueryParameter['filter.eq.fullName'] = filterEqFullName;
            }

            if (filterEqId !== undefined) {
                localVarQueryParameter['filter.eq.id'] = filterEqId;
            }

            if (filterEqLastLogin !== undefined) {
                localVarQueryParameter['filter.eq.lastLogin'] = filterEqLastLogin;
            }

            if (filterEqProject) {
                localVarQueryParameter['filter.eq.project'] = filterEqProject;
            }

            if (filterEqProjectId !== undefined) {
                localVarQueryParameter['filter.eq.projectId'] = filterEqProjectId;
            }

            if (filterEqRole !== undefined) {
                localVarQueryParameter['filter.eq.role'] = filterEqRole;
            }

            if (filterEqSynchronizationDate !== undefined) {
                localVarQueryParameter['filter.eq.synchronizationDate'] = filterEqSynchronizationDate;
            }

            if (filterEqType !== undefined) {
                localVarQueryParameter['filter.eq.type'] = filterEqType;
            }

            if (filterEqUser !== undefined) {
                localVarQueryParameter['filter.eq.user'] = filterEqUser;
            }

            if (pagePage !== undefined) {
                localVarQueryParameter['page.page'] = pagePage;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page.size'] = pageSize;
            }

            if (pageSort) {
                localVarQueryParameter['page.sort'] = pageSort;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Check if a restore password bid exists (DEPRECATED)
         * @param {string} uuid uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isRestorePasswordBidExistUsingGET(uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid', 'Required parameter uuid was null or undefined when calling isRestorePasswordBidExistUsingGET.');
            }
            const localVarPath = `/v1/user/password/reset/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Reset password (DEPRECATED
         * @param {ResetPasswordRQ} rq rq
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPasswordUsingPOST(rq: ResetPasswordRQ, options: any = {}): FetchArgs {
            // verify required parameter 'rq' is not null or undefined
            if (rq === null || rq === undefined) {
                throw new RequiredError('rq', 'Required parameter rq was null or undefined when calling resetPasswordUsingPOST.');
            }
            const localVarPath = `/v1/user/password/reset`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ResetPasswordRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(rq || {}) : (rq || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a restore password request (DEPRECATED)
         * @param {RestorePasswordRQ} rq rq
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restorePasswordUsingPOST(rq: RestorePasswordRQ, options: any = {}): FetchArgs {
            // verify required parameter 'rq' is not null or undefined
            if (rq === null || rq === undefined) {
                throw new RequiredError('rq', 'Required parameter rq was null or undefined when calling restorePasswordUsingPOST.');
            }
            const localVarPath = `/v1/user/password/restore`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RestorePasswordRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(rq || {}) : (rq || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Validate registration information (DEPRECATED)
         * @param {string} [email] email
         * @param {string} [username] username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateInfoUsingGET(email?: string, username?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v1/user/registration/info`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeprecatedUserControllerApi - functional programming interface
 * @export
 */
export const DeprecatedUserControllerApiFp = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Change own password (DEPRECATED)
         * @param {ChangePasswordRQ} changePasswordRQ changePasswordRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePasswordUsingPOST(changePasswordRQ: ChangePasswordRQ, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = DeprecatedUserControllerApiFetchParamCreator(configuration).changePasswordUsingPOST(changePasswordRQ, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create new Api Key for current user (DEPRECATED)
         * @param {ApiKeyRQ} apiKeyRQ apiKeyRQ
         * @param {number} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKeyUsingPOST(apiKeyRQ: ApiKeyRQ, userId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiKeyRS> {
            const localVarFetchArgs = DeprecatedUserControllerApiFetchParamCreator(configuration).createApiKeyUsingPOST(apiKeyRQ, userId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Register invitation for user who will be created (DEPRECATED)
         * @param {CreateUserRQ} createUserRQ createUserRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserBidUsingPOST(createUserRQ: CreateUserRQ, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateUserBidRS> {
            const localVarFetchArgs = DeprecatedUserControllerApiFetchParamCreator(configuration).createUserBidUsingPOST(createUserRQ, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Allowable only for users with administrator role
         * @summary Create specified user (DEPRECATED)
         * @param {CreateUserRQFull} rq rq
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserByAdminUsingPOST(rq: CreateUserRQFull, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateUserRS> {
            const localVarFetchArgs = DeprecatedUserControllerApiFetchParamCreator(configuration).createUserByAdminUsingPOST(rq, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Activate invitation and create user in system (DEPRECATED)
         * @param {CreateUserRQConfirm} request request
         * @param {string} uuid uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserUsingPOST(request: CreateUserRQConfirm, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateUserRS> {
            const localVarFetchArgs = DeprecatedUserControllerApiFetchParamCreator(configuration).createUserUsingPOST(request, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete specified Api Key (DEPRECATED)
         * @param {number} keyId keyId
         * @param {number} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKeyUsingDELETE(keyId: number, userId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = DeprecatedUserControllerApiFetchParamCreator(configuration).deleteApiKeyUsingDELETE(keyId, userId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete specified user (DEPRECATED)
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserUsingDELETE(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = DeprecatedUserControllerApiFetchParamCreator(configuration).deleteUserUsingDELETE(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete specified users by ids (DEPRECATED)
         * @param {DeleteBulkRQ} deleteBulkRQ deleteBulkRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsersUsingDELETE(deleteBulkRQ: DeleteBulkRQ, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteBulkRS> {
            const localVarFetchArgs = DeprecatedUserControllerApiFetchParamCreator(configuration).deleteUsersUsingDELETE(deleteBulkRQ, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Only for administrators and profile's owner
         * @summary Edit specified user (DEPRECATED)
         * @param {EditUserRQ} editUserRQ editUserRQ
         * @param {string} login login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUserUsingPUT(editUserRQ: EditUserRQ, login: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = DeprecatedUserControllerApiFetchParamCreator(configuration).editUserUsingPUT(editUserRQ, login, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Allowable only for users with administrator role
         * @summary Exports information about all users (DEPRECATED)
         * @param {string} [filterEqEmail] Filters by &#39;email&#39;
         * @param {boolean} [filterEqExpired] Filters by &#39;expired&#39;
         * @param {string} [filterEqFullName] Filters by &#39;fullName&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {number} [filterEqLastLogin] Filters by &#39;lastLogin&#39;
         * @param {Array<any>} [filterEqProject] Filters by &#39;project&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {string} [filterEqRole] Filters by &#39;role&#39;
         * @param {number} [filterEqSynchronizationDate] Filters by &#39;synchronizationDate&#39;
         * @param {string} [filterEqType] Filters by &#39;type&#39;
         * @param {string} [filterEqUser] Filters by &#39;user&#39;
         * @param {'csv'} [view] view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportUsingGET(filterEqEmail?: string, filterEqExpired?: boolean, filterEqFullName?: string, filterEqId?: number, filterEqLastLogin?: number, filterEqProject?: Array<any>, filterEqProjectId?: number, filterEqRole?: string, filterEqSynchronizationDate?: number, filterEqType?: string, filterEqUser?: string, view?: 'csv', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DeprecatedUserControllerApiFetchParamCreator(configuration).exportUsingGET(filterEqEmail, filterEqExpired, filterEqFullName, filterEqId, filterEqLastLogin, filterEqProject, filterEqProjectId, filterEqRole, filterEqSynchronizationDate, filterEqType, filterEqUser, view, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Only for administrators
         * @summary Find users by term (DEPRECATED)
         * @param {string} term term
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUsersUsingGET(term: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<IterableUserResource> {
            const localVarFetchArgs = DeprecatedUserControllerApiFetchParamCreator(configuration).findUsersUsingGET(term, pagePage, pageSize, pageSort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Return information about current logged-in user (DEPRECATED)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyselfUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserResource> {
            const localVarFetchArgs = DeprecatedUserControllerApiFetchParamCreator(configuration).getMyselfUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Return information about current logged-in user (DEPRECATED)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyselfUsingGET1(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserResource> {
            const localVarFetchArgs = DeprecatedUserControllerApiFetchParamCreator(configuration).getMyselfUsingGET1(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get user's registration info (DEPRECATED)
         * @param {string} uuid uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBidInfoUsingGET(uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserBidRS> {
            const localVarFetchArgs = DeprecatedUserControllerApiFetchParamCreator(configuration).getUserBidInfoUsingGET(uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get user's projects (DEPRECATED)
         * @param {string} userName userName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserProjectsUsingGET(userName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{
            [key: string]: AssignedProject;
        }> {
            const localVarFetchArgs = DeprecatedUserControllerApiFetchParamCreator(configuration).getUserProjectsUsingGET(userName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Only for administrators and profile's owner
         * @summary Return information about specified user (DEPRECATED)
         * @param {string} login login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserUsingGET(login: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserResource> {
            const localVarFetchArgs = DeprecatedUserControllerApiFetchParamCreator(configuration).getUserUsingGET(login, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get List of users Api Keys (DEPRECATED)
         * @param {number} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersApiKeysUsingGET(userId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiKeysRS> {
            const localVarFetchArgs = DeprecatedUserControllerApiFetchParamCreator(configuration).getUsersApiKeysUsingGET(userId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Allowable only for users with administrator role
         * @summary Return information about all users (DEPRECATED)
         * @param {string} [filterEqEmail] Filters by &#39;email&#39;
         * @param {boolean} [filterEqExpired] Filters by &#39;expired&#39;
         * @param {string} [filterEqFullName] Filters by &#39;fullName&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {number} [filterEqLastLogin] Filters by &#39;lastLogin&#39;
         * @param {Array<any>} [filterEqProject] Filters by &#39;project&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {string} [filterEqRole] Filters by &#39;role&#39;
         * @param {number} [filterEqSynchronizationDate] Filters by &#39;synchronizationDate&#39;
         * @param {string} [filterEqType] Filters by &#39;type&#39;
         * @param {string} [filterEqUser] Filters by &#39;user&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUsingGET(filterEqEmail?: string, filterEqExpired?: boolean, filterEqFullName?: string, filterEqId?: number, filterEqLastLogin?: number, filterEqProject?: Array<any>, filterEqProjectId?: number, filterEqRole?: string, filterEqSynchronizationDate?: number, filterEqType?: string, filterEqUser?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<IterableUserResource> {
            const localVarFetchArgs = DeprecatedUserControllerApiFetchParamCreator(configuration).getUsersUsingGET(filterEqEmail, filterEqExpired, filterEqFullName, filterEqId, filterEqLastLogin, filterEqProject, filterEqProjectId, filterEqRole, filterEqSynchronizationDate, filterEqType, filterEqUser, pagePage, pageSize, pageSort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Check if a restore password bid exists (DEPRECATED)
         * @param {string} uuid uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isRestorePasswordBidExistUsingGET(uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<YesNoRS> {
            const localVarFetchArgs = DeprecatedUserControllerApiFetchParamCreator(configuration).isRestorePasswordBidExistUsingGET(uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Reset password (DEPRECATED
         * @param {ResetPasswordRQ} rq rq
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPasswordUsingPOST(rq: ResetPasswordRQ, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = DeprecatedUserControllerApiFetchParamCreator(configuration).resetPasswordUsingPOST(rq, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create a restore password request (DEPRECATED)
         * @param {RestorePasswordRQ} rq rq
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restorePasswordUsingPOST(rq: RestorePasswordRQ, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = DeprecatedUserControllerApiFetchParamCreator(configuration).restorePasswordUsingPOST(rq, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Validate registration information (DEPRECATED)
         * @param {string} [email] email
         * @param {string} [username] username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateInfoUsingGET(email?: string, username?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<YesNoRS> {
            const localVarFetchArgs = DeprecatedUserControllerApiFetchParamCreator(configuration).validateInfoUsingGET(email, username, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DeprecatedUserControllerApi - factory interface
 * @export
 */
export const DeprecatedUserControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Change own password (DEPRECATED)
         * @param {ChangePasswordRQ} changePasswordRQ changePasswordRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePasswordUsingPOST(changePasswordRQ: ChangePasswordRQ, options?: any) {
            return DeprecatedUserControllerApiFp(configuration).changePasswordUsingPOST(changePasswordRQ, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create new Api Key for current user (DEPRECATED)
         * @param {ApiKeyRQ} apiKeyRQ apiKeyRQ
         * @param {number} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKeyUsingPOST(apiKeyRQ: ApiKeyRQ, userId: number, options?: any) {
            return DeprecatedUserControllerApiFp(configuration).createApiKeyUsingPOST(apiKeyRQ, userId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Register invitation for user who will be created (DEPRECATED)
         * @param {CreateUserRQ} createUserRQ createUserRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserBidUsingPOST(createUserRQ: CreateUserRQ, options?: any) {
            return DeprecatedUserControllerApiFp(configuration).createUserBidUsingPOST(createUserRQ, options)(fetch, basePath);
        },
        /**
         * Allowable only for users with administrator role
         * @summary Create specified user (DEPRECATED)
         * @param {CreateUserRQFull} rq rq
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserByAdminUsingPOST(rq: CreateUserRQFull, options?: any) {
            return DeprecatedUserControllerApiFp(configuration).createUserByAdminUsingPOST(rq, options)(fetch, basePath);
        },
        /**
         *
         * @summary Activate invitation and create user in system (DEPRECATED)
         * @param {CreateUserRQConfirm} request request
         * @param {string} uuid uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserUsingPOST(request: CreateUserRQConfirm, uuid: string, options?: any) {
            return DeprecatedUserControllerApiFp(configuration).createUserUsingPOST(request, uuid, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete specified Api Key (DEPRECATED)
         * @param {number} keyId keyId
         * @param {number} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKeyUsingDELETE(keyId: number, userId: number, options?: any) {
            return DeprecatedUserControllerApiFp(configuration).deleteApiKeyUsingDELETE(keyId, userId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete specified user (DEPRECATED)
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserUsingDELETE(id: number, options?: any) {
            return DeprecatedUserControllerApiFp(configuration).deleteUserUsingDELETE(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete specified users by ids (DEPRECATED)
         * @param {DeleteBulkRQ} deleteBulkRQ deleteBulkRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsersUsingDELETE(deleteBulkRQ: DeleteBulkRQ, options?: any) {
            return DeprecatedUserControllerApiFp(configuration).deleteUsersUsingDELETE(deleteBulkRQ, options)(fetch, basePath);
        },
        /**
         * Only for administrators and profile's owner
         * @summary Edit specified user (DEPRECATED)
         * @param {EditUserRQ} editUserRQ editUserRQ
         * @param {string} login login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUserUsingPUT(editUserRQ: EditUserRQ, login: string, options?: any) {
            return DeprecatedUserControllerApiFp(configuration).editUserUsingPUT(editUserRQ, login, options)(fetch, basePath);
        },
        /**
         * Allowable only for users with administrator role
         * @summary Exports information about all users (DEPRECATED)
         * @param {string} [filterEqEmail] Filters by &#39;email&#39;
         * @param {boolean} [filterEqExpired] Filters by &#39;expired&#39;
         * @param {string} [filterEqFullName] Filters by &#39;fullName&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {number} [filterEqLastLogin] Filters by &#39;lastLogin&#39;
         * @param {Array<any>} [filterEqProject] Filters by &#39;project&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {string} [filterEqRole] Filters by &#39;role&#39;
         * @param {number} [filterEqSynchronizationDate] Filters by &#39;synchronizationDate&#39;
         * @param {string} [filterEqType] Filters by &#39;type&#39;
         * @param {string} [filterEqUser] Filters by &#39;user&#39;
         * @param {'csv'} [view] view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportUsingGET(filterEqEmail?: string, filterEqExpired?: boolean, filterEqFullName?: string, filterEqId?: number, filterEqLastLogin?: number, filterEqProject?: Array<any>, filterEqProjectId?: number, filterEqRole?: string, filterEqSynchronizationDate?: number, filterEqType?: string, filterEqUser?: string, view?: 'csv', options?: any) {
            return DeprecatedUserControllerApiFp(configuration).exportUsingGET(filterEqEmail, filterEqExpired, filterEqFullName, filterEqId, filterEqLastLogin, filterEqProject, filterEqProjectId, filterEqRole, filterEqSynchronizationDate, filterEqType, filterEqUser, view, options)(fetch, basePath);
        },
        /**
         * Only for administrators
         * @summary Find users by term (DEPRECATED)
         * @param {string} term term
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUsersUsingGET(term: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any) {
            return DeprecatedUserControllerApiFp(configuration).findUsersUsingGET(term, pagePage, pageSize, pageSort, options)(fetch, basePath);
        },
        /**
         *
         * @summary Return information about current logged-in user (DEPRECATED)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyselfUsingGET(options?: any) {
            return DeprecatedUserControllerApiFp(configuration).getMyselfUsingGET(options)(fetch, basePath);
        },
        /**
         *
         * @summary Return information about current logged-in user (DEPRECATED)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyselfUsingGET1(options?: any) {
            return DeprecatedUserControllerApiFp(configuration).getMyselfUsingGET1(options)(fetch, basePath);
        },
        /**
         *
         * @summary Get user's registration info (DEPRECATED)
         * @param {string} uuid uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBidInfoUsingGET(uuid: string, options?: any) {
            return DeprecatedUserControllerApiFp(configuration).getUserBidInfoUsingGET(uuid, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get user's projects (DEPRECATED)
         * @param {string} userName userName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserProjectsUsingGET(userName: string, options?: any) {
            return DeprecatedUserControllerApiFp(configuration).getUserProjectsUsingGET(userName, options)(fetch, basePath);
        },
        /**
         * Only for administrators and profile's owner
         * @summary Return information about specified user (DEPRECATED)
         * @param {string} login login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserUsingGET(login: string, options?: any) {
            return DeprecatedUserControllerApiFp(configuration).getUserUsingGET(login, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get List of users Api Keys (DEPRECATED)
         * @param {number} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersApiKeysUsingGET(userId: number, options?: any) {
            return DeprecatedUserControllerApiFp(configuration).getUsersApiKeysUsingGET(userId, options)(fetch, basePath);
        },
        /**
         * Allowable only for users with administrator role
         * @summary Return information about all users (DEPRECATED)
         * @param {string} [filterEqEmail] Filters by &#39;email&#39;
         * @param {boolean} [filterEqExpired] Filters by &#39;expired&#39;
         * @param {string} [filterEqFullName] Filters by &#39;fullName&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {number} [filterEqLastLogin] Filters by &#39;lastLogin&#39;
         * @param {Array<any>} [filterEqProject] Filters by &#39;project&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {string} [filterEqRole] Filters by &#39;role&#39;
         * @param {number} [filterEqSynchronizationDate] Filters by &#39;synchronizationDate&#39;
         * @param {string} [filterEqType] Filters by &#39;type&#39;
         * @param {string} [filterEqUser] Filters by &#39;user&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUsingGET(filterEqEmail?: string, filterEqExpired?: boolean, filterEqFullName?: string, filterEqId?: number, filterEqLastLogin?: number, filterEqProject?: Array<any>, filterEqProjectId?: number, filterEqRole?: string, filterEqSynchronizationDate?: number, filterEqType?: string, filterEqUser?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any) {
            return DeprecatedUserControllerApiFp(configuration).getUsersUsingGET(filterEqEmail, filterEqExpired, filterEqFullName, filterEqId, filterEqLastLogin, filterEqProject, filterEqProjectId, filterEqRole, filterEqSynchronizationDate, filterEqType, filterEqUser, pagePage, pageSize, pageSort, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check if a restore password bid exists (DEPRECATED)
         * @param {string} uuid uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isRestorePasswordBidExistUsingGET(uuid: string, options?: any) {
            return DeprecatedUserControllerApiFp(configuration).isRestorePasswordBidExistUsingGET(uuid, options)(fetch, basePath);
        },
        /**
         *
         * @summary Reset password (DEPRECATED
         * @param {ResetPasswordRQ} rq rq
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPasswordUsingPOST(rq: ResetPasswordRQ, options?: any) {
            return DeprecatedUserControllerApiFp(configuration).resetPasswordUsingPOST(rq, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a restore password request (DEPRECATED)
         * @param {RestorePasswordRQ} rq rq
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restorePasswordUsingPOST(rq: RestorePasswordRQ, options?: any) {
            return DeprecatedUserControllerApiFp(configuration).restorePasswordUsingPOST(rq, options)(fetch, basePath);
        },
        /**
         *
         * @summary Validate registration information (DEPRECATED)
         * @param {string} [email] email
         * @param {string} [username] username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateInfoUsingGET(email?: string, username?: string, options?: any) {
            return DeprecatedUserControllerApiFp(configuration).validateInfoUsingGET(email, username, options)(fetch, basePath);
        },
    };
};

/**
 * DeprecatedUserControllerApi - object-oriented interface
 * @export
 * @class DeprecatedUserControllerApi
 * @extends {BaseAPI}
 */
export class DeprecatedUserControllerApi extends BaseAPI {
    /**
     *
     * @summary Change own password (DEPRECATED)
     * @param {ChangePasswordRQ} changePasswordRQ changePasswordRQ
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeprecatedUserControllerApi
     */
    public changePasswordUsingPOST(changePasswordRQ: ChangePasswordRQ, options?: any) {
        return DeprecatedUserControllerApiFp(this.configuration).changePasswordUsingPOST(changePasswordRQ, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Create new Api Key for current user (DEPRECATED)
     * @param {ApiKeyRQ} apiKeyRQ apiKeyRQ
     * @param {number} userId userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeprecatedUserControllerApi
     */
    public createApiKeyUsingPOST(apiKeyRQ: ApiKeyRQ, userId: number, options?: any) {
        return DeprecatedUserControllerApiFp(this.configuration).createApiKeyUsingPOST(apiKeyRQ, userId, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Register invitation for user who will be created (DEPRECATED)
     * @param {CreateUserRQ} createUserRQ createUserRQ
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeprecatedUserControllerApi
     */
    public createUserBidUsingPOST(createUserRQ: CreateUserRQ, options?: any) {
        return DeprecatedUserControllerApiFp(this.configuration).createUserBidUsingPOST(createUserRQ, options)(this.fetch, this.basePath);
    }

    /**
     * Allowable only for users with administrator role
     * @summary Create specified user (DEPRECATED)
     * @param {CreateUserRQFull} rq rq
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeprecatedUserControllerApi
     */
    public createUserByAdminUsingPOST(rq: CreateUserRQFull, options?: any) {
        return DeprecatedUserControllerApiFp(this.configuration).createUserByAdminUsingPOST(rq, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Activate invitation and create user in system (DEPRECATED)
     * @param {CreateUserRQConfirm} request request
     * @param {string} uuid uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeprecatedUserControllerApi
     */
    public createUserUsingPOST(request: CreateUserRQConfirm, uuid: string, options?: any) {
        return DeprecatedUserControllerApiFp(this.configuration).createUserUsingPOST(request, uuid, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete specified Api Key (DEPRECATED)
     * @param {number} keyId keyId
     * @param {number} userId userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeprecatedUserControllerApi
     */
    public deleteApiKeyUsingDELETE(keyId: number, userId: number, options?: any) {
        return DeprecatedUserControllerApiFp(this.configuration).deleteApiKeyUsingDELETE(keyId, userId, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete specified user (DEPRECATED)
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeprecatedUserControllerApi
     */
    public deleteUserUsingDELETE(id: number, options?: any) {
        return DeprecatedUserControllerApiFp(this.configuration).deleteUserUsingDELETE(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete specified users by ids (DEPRECATED)
     * @param {DeleteBulkRQ} deleteBulkRQ deleteBulkRQ
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeprecatedUserControllerApi
     */
    public deleteUsersUsingDELETE(deleteBulkRQ: DeleteBulkRQ, options?: any) {
        return DeprecatedUserControllerApiFp(this.configuration).deleteUsersUsingDELETE(deleteBulkRQ, options)(this.fetch, this.basePath);
    }

    /**
     * Only for administrators and profile's owner
     * @summary Edit specified user (DEPRECATED)
     * @param {EditUserRQ} editUserRQ editUserRQ
     * @param {string} login login
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeprecatedUserControllerApi
     */
    public editUserUsingPUT(editUserRQ: EditUserRQ, login: string, options?: any) {
        return DeprecatedUserControllerApiFp(this.configuration).editUserUsingPUT(editUserRQ, login, options)(this.fetch, this.basePath);
    }

    /**
     * Allowable only for users with administrator role
     * @summary Exports information about all users (DEPRECATED)
     * @param {string} [filterEqEmail] Filters by &#39;email&#39;
     * @param {boolean} [filterEqExpired] Filters by &#39;expired&#39;
     * @param {string} [filterEqFullName] Filters by &#39;fullName&#39;
     * @param {number} [filterEqId] Filters by &#39;id&#39;
     * @param {number} [filterEqLastLogin] Filters by &#39;lastLogin&#39;
     * @param {Array<any>} [filterEqProject] Filters by &#39;project&#39;
     * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
     * @param {string} [filterEqRole] Filters by &#39;role&#39;
     * @param {number} [filterEqSynchronizationDate] Filters by &#39;synchronizationDate&#39;
     * @param {string} [filterEqType] Filters by &#39;type&#39;
     * @param {string} [filterEqUser] Filters by &#39;user&#39;
     * @param {'csv'} [view] view
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeprecatedUserControllerApi
     */
    public exportUsingGET(filterEqEmail?: string, filterEqExpired?: boolean, filterEqFullName?: string, filterEqId?: number, filterEqLastLogin?: number, filterEqProject?: Array<any>, filterEqProjectId?: number, filterEqRole?: string, filterEqSynchronizationDate?: number, filterEqType?: string, filterEqUser?: string, view?: 'csv', options?: any) {
        return DeprecatedUserControllerApiFp(this.configuration).exportUsingGET(filterEqEmail, filterEqExpired, filterEqFullName, filterEqId, filterEqLastLogin, filterEqProject, filterEqProjectId, filterEqRole, filterEqSynchronizationDate, filterEqType, filterEqUser, view, options)(this.fetch, this.basePath);
    }

    /**
     * Only for administrators
     * @summary Find users by term (DEPRECATED)
     * @param {string} term term
     * @param {number} [pagePage] Results page you want to retrieve (0..N)
     * @param {number} [pageSize] Number of records per page
     * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeprecatedUserControllerApi
     */
    public findUsersUsingGET(term: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any) {
        return DeprecatedUserControllerApiFp(this.configuration).findUsersUsingGET(term, pagePage, pageSize, pageSort, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Return information about current logged-in user (DEPRECATED)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeprecatedUserControllerApi
     */
    public getMyselfUsingGET(options?: any) {
        return DeprecatedUserControllerApiFp(this.configuration).getMyselfUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Return information about current logged-in user (DEPRECATED)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeprecatedUserControllerApi
     */
    public getMyselfUsingGET1(options?: any) {
        return DeprecatedUserControllerApiFp(this.configuration).getMyselfUsingGET1(options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get user's registration info (DEPRECATED)
     * @param {string} uuid uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeprecatedUserControllerApi
     */
    public getUserBidInfoUsingGET(uuid: string, options?: any) {
        return DeprecatedUserControllerApiFp(this.configuration).getUserBidInfoUsingGET(uuid, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get user's projects (DEPRECATED)
     * @param {string} userName userName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeprecatedUserControllerApi
     */
    public getUserProjectsUsingGET(userName: string, options?: any) {
        return DeprecatedUserControllerApiFp(this.configuration).getUserProjectsUsingGET(userName, options)(this.fetch, this.basePath);
    }

    /**
     * Only for administrators and profile's owner
     * @summary Return information about specified user (DEPRECATED)
     * @param {string} login login
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeprecatedUserControllerApi
     */
    public getUserUsingGET(login: string, options?: any) {
        return DeprecatedUserControllerApiFp(this.configuration).getUserUsingGET(login, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get List of users Api Keys (DEPRECATED)
     * @param {number} userId userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeprecatedUserControllerApi
     */
    public getUsersApiKeysUsingGET(userId: number, options?: any) {
        return DeprecatedUserControllerApiFp(this.configuration).getUsersApiKeysUsingGET(userId, options)(this.fetch, this.basePath);
    }

    /**
     * Allowable only for users with administrator role
     * @summary Return information about all users (DEPRECATED)
     * @param {string} [filterEqEmail] Filters by &#39;email&#39;
     * @param {boolean} [filterEqExpired] Filters by &#39;expired&#39;
     * @param {string} [filterEqFullName] Filters by &#39;fullName&#39;
     * @param {number} [filterEqId] Filters by &#39;id&#39;
     * @param {number} [filterEqLastLogin] Filters by &#39;lastLogin&#39;
     * @param {Array<any>} [filterEqProject] Filters by &#39;project&#39;
     * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
     * @param {string} [filterEqRole] Filters by &#39;role&#39;
     * @param {number} [filterEqSynchronizationDate] Filters by &#39;synchronizationDate&#39;
     * @param {string} [filterEqType] Filters by &#39;type&#39;
     * @param {string} [filterEqUser] Filters by &#39;user&#39;
     * @param {number} [pagePage] Results page you want to retrieve (0..N)
     * @param {number} [pageSize] Number of records per page
     * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeprecatedUserControllerApi
     */
    public getUsersUsingGET(filterEqEmail?: string, filterEqExpired?: boolean, filterEqFullName?: string, filterEqId?: number, filterEqLastLogin?: number, filterEqProject?: Array<any>, filterEqProjectId?: number, filterEqRole?: string, filterEqSynchronizationDate?: number, filterEqType?: string, filterEqUser?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any) {
        return DeprecatedUserControllerApiFp(this.configuration).getUsersUsingGET(filterEqEmail, filterEqExpired, filterEqFullName, filterEqId, filterEqLastLogin, filterEqProject, filterEqProjectId, filterEqRole, filterEqSynchronizationDate, filterEqType, filterEqUser, pagePage, pageSize, pageSort, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Check if a restore password bid exists (DEPRECATED)
     * @param {string} uuid uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeprecatedUserControllerApi
     */
    public isRestorePasswordBidExistUsingGET(uuid: string, options?: any) {
        return DeprecatedUserControllerApiFp(this.configuration).isRestorePasswordBidExistUsingGET(uuid, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Reset password (DEPRECATED
     * @param {ResetPasswordRQ} rq rq
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeprecatedUserControllerApi
     */
    public resetPasswordUsingPOST(rq: ResetPasswordRQ, options?: any) {
        return DeprecatedUserControllerApiFp(this.configuration).resetPasswordUsingPOST(rq, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Create a restore password request (DEPRECATED)
     * @param {RestorePasswordRQ} rq rq
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeprecatedUserControllerApi
     */
    public restorePasswordUsingPOST(rq: RestorePasswordRQ, options?: any) {
        return DeprecatedUserControllerApiFp(this.configuration).restorePasswordUsingPOST(rq, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Validate registration information (DEPRECATED)
     * @param {string} [email] email
     * @param {string} [username] username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeprecatedUserControllerApi
     */
    public validateInfoUsingGET(email?: string, username?: string, options?: any) {
        return DeprecatedUserControllerApiFp(this.configuration).validateInfoUsingGET(email, username, options)(this.fetch, this.basePath);
    }

}

/**
 * FileStorageControllerApi - fetch parameter creator
 * @export
 */
export const FileStorageControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Delete user's photo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePhotoUsingDELETE(options: any = {}): FetchArgs {
            const localVarPath = `/v1/data/photo`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'DELETE'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary getFile
         * @param {number} dataId dataId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileUsingGET(dataId: number, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'dataId' is not null or undefined
            if (dataId === null || dataId === undefined) {
                throw new RequiredError('dataId', 'Required parameter dataId was null or undefined when calling getFileUsingGET.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getFileUsingGET.');
            }
            const localVarPath = `/v1/data/{projectName}/{dataId}`
                .replace(`{${"dataId"}}`, encodeURIComponent(String(dataId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get photo of current user
         * @param {boolean} [loadThumbnail] loadThumbnail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyPhotoUsingGET(loadThumbnail?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/v1/data/photo`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (loadThumbnail !== undefined) {
                localVarQueryParameter['loadThumbnail'] = loadThumbnail;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get user's photo
         * @param {string} id id
         * @param {string} projectName projectName
         * @param {boolean} [loadThumbnail] loadThumbnail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPhotoUsingGET(id: string, projectName: string, loadThumbnail?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling getUserPhotoUsingGET.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getUserPhotoUsingGET.');
            }
            const localVarPath = `/v1/data/{projectName}/userphoto`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (loadThumbnail !== undefined) {
                localVarQueryParameter['loadThumbnail'] = loadThumbnail;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Remove attachments from file storage according to uploaded csv file
         * @param {any} file file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAttachmentsByCsvUsingPOST(file: any, options: any = {}): FetchArgs {
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file', 'Required parameter file was null or undefined when calling removeAttachmentsByCsvUsingPOST.');
            }
            const localVarPath = `/v1/data/clean`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Upload user's photo
         * @param {any} file file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPhotoUsingPOST(file: any, options: any = {}): FetchArgs {
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file', 'Required parameter file was null or undefined when calling uploadPhotoUsingPOST.');
            }
            const localVarPath = `/v1/data/photo`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FileStorageControllerApi - functional programming interface
 * @export
 */
export const FileStorageControllerApiFp = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Delete user's photo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePhotoUsingDELETE(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = FileStorageControllerApiFetchParamCreator(configuration).deletePhotoUsingDELETE(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary getFile
         * @param {number} dataId dataId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileUsingGET(dataId: number, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = FileStorageControllerApiFetchParamCreator(configuration).getFileUsingGET(dataId, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get photo of current user
         * @param {boolean} [loadThumbnail] loadThumbnail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyPhotoUsingGET(loadThumbnail?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = FileStorageControllerApiFetchParamCreator(configuration).getMyPhotoUsingGET(loadThumbnail, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get user's photo
         * @param {string} id id
         * @param {string} projectName projectName
         * @param {boolean} [loadThumbnail] loadThumbnail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPhotoUsingGET(id: string, projectName: string, loadThumbnail?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = FileStorageControllerApiFetchParamCreator(configuration).getUserPhotoUsingGET(id, projectName, loadThumbnail, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Remove attachments from file storage according to uploaded csv file
         * @param {any} file file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAttachmentsByCsvUsingPOST(file: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = FileStorageControllerApiFetchParamCreator(configuration).removeAttachmentsByCsvUsingPOST(file, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Upload user's photo
         * @param {any} file file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPhotoUsingPOST(file: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = FileStorageControllerApiFetchParamCreator(configuration).uploadPhotoUsingPOST(file, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * FileStorageControllerApi - factory interface
 * @export
 */
export const FileStorageControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Delete user's photo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePhotoUsingDELETE(options?: any) {
            return FileStorageControllerApiFp(configuration).deletePhotoUsingDELETE(options)(fetch, basePath);
        },
        /**
         *
         * @summary getFile
         * @param {number} dataId dataId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileUsingGET(dataId: number, projectName: string, options?: any) {
            return FileStorageControllerApiFp(configuration).getFileUsingGET(dataId, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get photo of current user
         * @param {boolean} [loadThumbnail] loadThumbnail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyPhotoUsingGET(loadThumbnail?: boolean, options?: any) {
            return FileStorageControllerApiFp(configuration).getMyPhotoUsingGET(loadThumbnail, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get user's photo
         * @param {string} id id
         * @param {string} projectName projectName
         * @param {boolean} [loadThumbnail] loadThumbnail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPhotoUsingGET(id: string, projectName: string, loadThumbnail?: boolean, options?: any) {
            return FileStorageControllerApiFp(configuration).getUserPhotoUsingGET(id, projectName, loadThumbnail, options)(fetch, basePath);
        },
        /**
         *
         * @summary Remove attachments from file storage according to uploaded csv file
         * @param {any} file file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAttachmentsByCsvUsingPOST(file: any, options?: any) {
            return FileStorageControllerApiFp(configuration).removeAttachmentsByCsvUsingPOST(file, options)(fetch, basePath);
        },
        /**
         *
         * @summary Upload user's photo
         * @param {any} file file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPhotoUsingPOST(file: any, options?: any) {
            return FileStorageControllerApiFp(configuration).uploadPhotoUsingPOST(file, options)(fetch, basePath);
        },
    };
};

/**
 * FileStorageControllerApi - object-oriented interface
 * @export
 * @class FileStorageControllerApi
 * @extends {BaseAPI}
 */
export class FileStorageControllerApi extends BaseAPI {
    /**
     *
     * @summary Delete user's photo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileStorageControllerApi
     */
    public deletePhotoUsingDELETE(options?: any) {
        return FileStorageControllerApiFp(this.configuration).deletePhotoUsingDELETE(options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary getFile
     * @param {number} dataId dataId
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileStorageControllerApi
     */
    public getFileUsingGET(dataId: number, projectName: string, options?: any) {
        return FileStorageControllerApiFp(this.configuration).getFileUsingGET(dataId, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get photo of current user
     * @param {boolean} [loadThumbnail] loadThumbnail
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileStorageControllerApi
     */
    public getMyPhotoUsingGET(loadThumbnail?: boolean, options?: any) {
        return FileStorageControllerApiFp(this.configuration).getMyPhotoUsingGET(loadThumbnail, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get user's photo
     * @param {string} id id
     * @param {string} projectName projectName
     * @param {boolean} [loadThumbnail] loadThumbnail
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileStorageControllerApi
     */
    public getUserPhotoUsingGET(id: string, projectName: string, loadThumbnail?: boolean, options?: any) {
        return FileStorageControllerApiFp(this.configuration).getUserPhotoUsingGET(id, projectName, loadThumbnail, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Remove attachments from file storage according to uploaded csv file
     * @param {any} file file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileStorageControllerApi
     */
    public removeAttachmentsByCsvUsingPOST(file: any, options?: any) {
        return FileStorageControllerApiFp(this.configuration).removeAttachmentsByCsvUsingPOST(file, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Upload user's photo
     * @param {any} file file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileStorageControllerApi
     */
    public uploadPhotoUsingPOST(file: any, options?: any) {
        return FileStorageControllerApiFp(this.configuration).uploadPhotoUsingPOST(file, options)(this.fetch, this.basePath);
    }

}

/**
 * IntegrationControllerApi - fetch parameter creator
 * @export
 */
export const IntegrationControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create global Report Portal integration instance
         * @param {IntegrationRQ} createRequest createRequest
         * @param {string} pluginName pluginName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGlobalIntegrationUsingPOST(createRequest: IntegrationRQ, pluginName: string, options: any = {}): FetchArgs {
            // verify required parameter 'createRequest' is not null or undefined
            if (createRequest === null || createRequest === undefined) {
                throw new RequiredError('createRequest', 'Required parameter createRequest was null or undefined when calling createGlobalIntegrationUsingPOST.');
            }
            // verify required parameter 'pluginName' is not null or undefined
            if (pluginName === null || pluginName === undefined) {
                throw new RequiredError('pluginName', 'Required parameter pluginName was null or undefined when calling createGlobalIntegrationUsingPOST.');
            }
            const localVarPath = `/v1/integration/{pluginName}`
                .replace(`{${"pluginName"}}`, encodeURIComponent(String(pluginName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"IntegrationRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(createRequest || {}) : (createRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create project Report Portal integration instance
         * @param {IntegrationRQ} createRequest createRequest
         * @param {string} pluginName pluginName
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectIntegrationUsingPOST(createRequest: IntegrationRQ, pluginName: string, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'createRequest' is not null or undefined
            if (createRequest === null || createRequest === undefined) {
                throw new RequiredError('createRequest', 'Required parameter createRequest was null or undefined when calling createProjectIntegrationUsingPOST.');
            }
            // verify required parameter 'pluginName' is not null or undefined
            if (pluginName === null || pluginName === undefined) {
                throw new RequiredError('pluginName', 'Required parameter pluginName was null or undefined when calling createProjectIntegrationUsingPOST.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling createProjectIntegrationUsingPOST.');
            }
            const localVarPath = `/v1/integration/{projectName}/{pluginName}`
                .replace(`{${"pluginName"}}`, encodeURIComponent(String(pluginName)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"IntegrationRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(createRequest || {}) : (createRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete all global integrations by type
         * @param {string} type type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllIntegrationsUsingDELETE(type: string, options: any = {}): FetchArgs {
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type', 'Required parameter type was null or undefined when calling deleteAllIntegrationsUsingDELETE.');
            }
            const localVarPath = `/v1/integration/all/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'DELETE'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete all integrations assigned to specified project
         * @param {string} projectName projectName
         * @param {string} type type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllProjectIntegrationsUsingDELETE(projectName: string, type: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling deleteAllProjectIntegrationsUsingDELETE.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type', 'Required parameter type was null or undefined when calling deleteAllProjectIntegrationsUsingDELETE.');
            }
            const localVarPath = `/v1/integration/{projectName}/all/{type}`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'DELETE'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete global integration instance
         * @param {number} integrationId integrationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGlobalIntegrationUsingDELETE(integrationId: number, options: any = {}): FetchArgs {
            // verify required parameter 'integrationId' is not null or undefined
            if (integrationId === null || integrationId === undefined) {
                throw new RequiredError('integrationId', 'Required parameter integrationId was null or undefined when calling deleteGlobalIntegrationUsingDELETE.');
            }
            const localVarPath = `/v1/integration/{integrationId}`
                .replace(`{${"integrationId"}}`, encodeURIComponent(String(integrationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'DELETE'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete project integration instance
         * @param {number} integrationId integrationId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectIntegrationUsingDELETE(integrationId: number, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'integrationId' is not null or undefined
            if (integrationId === null || integrationId === undefined) {
                throw new RequiredError('integrationId', 'Required parameter integrationId was null or undefined when calling deleteProjectIntegrationUsingDELETE.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling deleteProjectIntegrationUsingDELETE.');
            }
            const localVarPath = `/v1/integration/{projectName}/{integrationId}`
                .replace(`{${"integrationId"}}`, encodeURIComponent(String(integrationId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'DELETE'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Execute command to the integration instance
         * @param {string} command command
         * @param {any} executionParams executionParams
         * @param {number} integrationId integrationId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeIntegrationCommandUsingPUT(command: string, executionParams: any, integrationId: number, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'command' is not null or undefined
            if (command === null || command === undefined) {
                throw new RequiredError('command', 'Required parameter command was null or undefined when calling executeIntegrationCommandUsingPUT.');
            }
            // verify required parameter 'executionParams' is not null or undefined
            if (executionParams === null || executionParams === undefined) {
                throw new RequiredError('executionParams', 'Required parameter executionParams was null or undefined when calling executeIntegrationCommandUsingPUT.');
            }
            // verify required parameter 'integrationId' is not null or undefined
            if (integrationId === null || integrationId === undefined) {
                throw new RequiredError('integrationId', 'Required parameter integrationId was null or undefined when calling executeIntegrationCommandUsingPUT.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling executeIntegrationCommandUsingPUT.');
            }
            const localVarPath = `/v1/integration/{projectName}/{integrationId}/{command}`
                .replace(`{${"command"}}`, encodeURIComponent(String(command)))
                .replace(`{${"integrationId"}}`, encodeURIComponent(String(integrationId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'PUT'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(executionParams || {}) : (executionParams || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get global Report Portal integration instance
         * @param {number} integrationId integrationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGlobalIntegrationUsingGET(integrationId: number, options: any = {}): FetchArgs {
            // verify required parameter 'integrationId' is not null or undefined
            if (integrationId === null || integrationId === undefined) {
                throw new RequiredError('integrationId', 'Required parameter integrationId was null or undefined when calling getGlobalIntegrationUsingGET.');
            }
            const localVarPath = `/v1/integration/{integrationId}`
                .replace(`{${"integrationId"}}`, encodeURIComponent(String(integrationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get available global integrations for plugin
         * @param {string} pluginName pluginName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGlobalIntegrationsUsingGET(pluginName: string, options: any = {}): FetchArgs {
            // verify required parameter 'pluginName' is not null or undefined
            if (pluginName === null || pluginName === undefined) {
                throw new RequiredError('pluginName', 'Required parameter pluginName was null or undefined when calling getGlobalIntegrationsUsingGET.');
            }
            const localVarPath = `/v1/integration/global/all/{pluginName}`
                .replace(`{${"pluginName"}}`, encodeURIComponent(String(pluginName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get available global integrations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGlobalIntegrationsUsingGET1(options: any = {}): FetchArgs {
            const localVarPath = `/v1/integration/global/all`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get integration instance
         * @param {number} integrationId integrationId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectIntegrationUsingGET(integrationId: number, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'integrationId' is not null or undefined
            if (integrationId === null || integrationId === undefined) {
                throw new RequiredError('integrationId', 'Required parameter integrationId was null or undefined when calling getProjectIntegrationUsingGET.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getProjectIntegrationUsingGET.');
            }
            const localVarPath = `/v1/integration/{projectName}/{integrationId}`
                .replace(`{${"integrationId"}}`, encodeURIComponent(String(integrationId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get available project integrations for plugin
         * @param {string} pluginName pluginName
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectIntegrationsUsingGET(pluginName: string, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'pluginName' is not null or undefined
            if (pluginName === null || pluginName === undefined) {
                throw new RequiredError('pluginName', 'Required parameter pluginName was null or undefined when calling getProjectIntegrationsUsingGET.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getProjectIntegrationsUsingGET.');
            }
            const localVarPath = `/v1/integration/project/{projectName}/all/{pluginName}`
                .replace(`{${"pluginName"}}`, encodeURIComponent(String(pluginName)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get available project integrations
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectIntegrationsUsingGET1(projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getProjectIntegrationsUsingGET1.');
            }
            const localVarPath = `/v1/integration/project/{projectName}/all`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Test connection to the global integration
         * @param {number} integrationId integrationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testIntegrationConnectionUsingGET(integrationId: number, options: any = {}): FetchArgs {
            // verify required parameter 'integrationId' is not null or undefined
            if (integrationId === null || integrationId === undefined) {
                throw new RequiredError('integrationId', 'Required parameter integrationId was null or undefined when calling testIntegrationConnectionUsingGET.');
            }
            const localVarPath = `/v1/integration/{integrationId}/connection/test`
                .replace(`{${"integrationId"}}`, encodeURIComponent(String(integrationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Test connection to the integration through the project config
         * @param {number} integrationId integrationId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testIntegrationConnectionUsingGET1(integrationId: number, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'integrationId' is not null or undefined
            if (integrationId === null || integrationId === undefined) {
                throw new RequiredError('integrationId', 'Required parameter integrationId was null or undefined when calling testIntegrationConnectionUsingGET1.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling testIntegrationConnectionUsingGET1.');
            }
            const localVarPath = `/v1/integration/{projectName}/{integrationId}/connection/test`
                .replace(`{${"integrationId"}}`, encodeURIComponent(String(integrationId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update global Report Portal integration instance
         * @param {number} integrationId integrationId
         * @param {IntegrationRQ} updateRequest updateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGlobalIntegrationUsingPUT(integrationId: number, updateRequest: IntegrationRQ, options: any = {}): FetchArgs {
            // verify required parameter 'integrationId' is not null or undefined
            if (integrationId === null || integrationId === undefined) {
                throw new RequiredError('integrationId', 'Required parameter integrationId was null or undefined when calling updateGlobalIntegrationUsingPUT.');
            }
            // verify required parameter 'updateRequest' is not null or undefined
            if (updateRequest === null || updateRequest === undefined) {
                throw new RequiredError('updateRequest', 'Required parameter updateRequest was null or undefined when calling updateGlobalIntegrationUsingPUT.');
            }
            const localVarPath = `/v1/integration/{integrationId}`
                .replace(`{${"integrationId"}}`, encodeURIComponent(String(integrationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'PUT'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"IntegrationRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(updateRequest || {}) : (updateRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update project integration instance
         * @param {number} integrationId integrationId
         * @param {string} projectName projectName
         * @param {IntegrationRQ} updateRequest updateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectIntegrationUsingPUT(integrationId: number, projectName: string, updateRequest: IntegrationRQ, options: any = {}): FetchArgs {
            // verify required parameter 'integrationId' is not null or undefined
            if (integrationId === null || integrationId === undefined) {
                throw new RequiredError('integrationId', 'Required parameter integrationId was null or undefined when calling updateProjectIntegrationUsingPUT.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling updateProjectIntegrationUsingPUT.');
            }
            // verify required parameter 'updateRequest' is not null or undefined
            if (updateRequest === null || updateRequest === undefined) {
                throw new RequiredError('updateRequest', 'Required parameter updateRequest was null or undefined when calling updateProjectIntegrationUsingPUT.');
            }
            const localVarPath = `/v1/integration/{projectName}/{integrationId}`
                .replace(`{${"integrationId"}}`, encodeURIComponent(String(integrationId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'PUT'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"IntegrationRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(updateRequest || {}) : (updateRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IntegrationControllerApi - functional programming interface
 * @export
 */
export const IntegrationControllerApiFp = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create global Report Portal integration instance
         * @param {IntegrationRQ} createRequest createRequest
         * @param {string} pluginName pluginName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGlobalIntegrationUsingPOST(createRequest: IntegrationRQ, pluginName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EntryCreatedRS> {
            const localVarFetchArgs = IntegrationControllerApiFetchParamCreator(configuration).createGlobalIntegrationUsingPOST(createRequest, pluginName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create project Report Portal integration instance
         * @param {IntegrationRQ} createRequest createRequest
         * @param {string} pluginName pluginName
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectIntegrationUsingPOST(createRequest: IntegrationRQ, pluginName: string, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EntryCreatedRS> {
            const localVarFetchArgs = IntegrationControllerApiFetchParamCreator(configuration).createProjectIntegrationUsingPOST(createRequest, pluginName, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete all global integrations by type
         * @param {string} type type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllIntegrationsUsingDELETE(type: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = IntegrationControllerApiFetchParamCreator(configuration).deleteAllIntegrationsUsingDELETE(type, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete all integrations assigned to specified project
         * @param {string} projectName projectName
         * @param {string} type type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllProjectIntegrationsUsingDELETE(projectName: string, type: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = IntegrationControllerApiFetchParamCreator(configuration).deleteAllProjectIntegrationsUsingDELETE(projectName, type, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete global integration instance
         * @param {number} integrationId integrationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGlobalIntegrationUsingDELETE(integrationId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = IntegrationControllerApiFetchParamCreator(configuration).deleteGlobalIntegrationUsingDELETE(integrationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete project integration instance
         * @param {number} integrationId integrationId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectIntegrationUsingDELETE(integrationId: number, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = IntegrationControllerApiFetchParamCreator(configuration).deleteProjectIntegrationUsingDELETE(integrationId, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Execute command to the integration instance
         * @param {string} command command
         * @param {any} executionParams executionParams
         * @param {number} integrationId integrationId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeIntegrationCommandUsingPUT(command: string, executionParams: any, integrationId: number, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = IntegrationControllerApiFetchParamCreator(configuration).executeIntegrationCommandUsingPUT(command, executionParams, integrationId, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get global Report Portal integration instance
         * @param {number} integrationId integrationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGlobalIntegrationUsingGET(integrationId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<IntegrationResource> {
            const localVarFetchArgs = IntegrationControllerApiFetchParamCreator(configuration).getGlobalIntegrationUsingGET(integrationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get available global integrations for plugin
         * @param {string} pluginName pluginName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGlobalIntegrationsUsingGET(pluginName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<IntegrationResource>> {
            const localVarFetchArgs = IntegrationControllerApiFetchParamCreator(configuration).getGlobalIntegrationsUsingGET(pluginName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get available global integrations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGlobalIntegrationsUsingGET1(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<IntegrationResource>> {
            const localVarFetchArgs = IntegrationControllerApiFetchParamCreator(configuration).getGlobalIntegrationsUsingGET1(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get integration instance
         * @param {number} integrationId integrationId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectIntegrationUsingGET(integrationId: number, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<IntegrationResource> {
            const localVarFetchArgs = IntegrationControllerApiFetchParamCreator(configuration).getProjectIntegrationUsingGET(integrationId, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get available project integrations for plugin
         * @param {string} pluginName pluginName
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectIntegrationsUsingGET(pluginName: string, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<IntegrationResource>> {
            const localVarFetchArgs = IntegrationControllerApiFetchParamCreator(configuration).getProjectIntegrationsUsingGET(pluginName, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get available project integrations
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectIntegrationsUsingGET1(projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<IntegrationResource>> {
            const localVarFetchArgs = IntegrationControllerApiFetchParamCreator(configuration).getProjectIntegrationsUsingGET1(projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Test connection to the global integration
         * @param {number} integrationId integrationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testIntegrationConnectionUsingGET(integrationId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = IntegrationControllerApiFetchParamCreator(configuration).testIntegrationConnectionUsingGET(integrationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Test connection to the integration through the project config
         * @param {number} integrationId integrationId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testIntegrationConnectionUsingGET1(integrationId: number, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = IntegrationControllerApiFetchParamCreator(configuration).testIntegrationConnectionUsingGET1(integrationId, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update global Report Portal integration instance
         * @param {number} integrationId integrationId
         * @param {IntegrationRQ} updateRequest updateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGlobalIntegrationUsingPUT(integrationId: number, updateRequest: IntegrationRQ, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = IntegrationControllerApiFetchParamCreator(configuration).updateGlobalIntegrationUsingPUT(integrationId, updateRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update project integration instance
         * @param {number} integrationId integrationId
         * @param {string} projectName projectName
         * @param {IntegrationRQ} updateRequest updateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectIntegrationUsingPUT(integrationId: number, projectName: string, updateRequest: IntegrationRQ, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = IntegrationControllerApiFetchParamCreator(configuration).updateProjectIntegrationUsingPUT(integrationId, projectName, updateRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * IntegrationControllerApi - factory interface
 * @export
 */
export const IntegrationControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Create global Report Portal integration instance
         * @param {IntegrationRQ} createRequest createRequest
         * @param {string} pluginName pluginName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGlobalIntegrationUsingPOST(createRequest: IntegrationRQ, pluginName: string, options?: any) {
            return IntegrationControllerApiFp(configuration).createGlobalIntegrationUsingPOST(createRequest, pluginName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create project Report Portal integration instance
         * @param {IntegrationRQ} createRequest createRequest
         * @param {string} pluginName pluginName
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectIntegrationUsingPOST(createRequest: IntegrationRQ, pluginName: string, projectName: string, options?: any) {
            return IntegrationControllerApiFp(configuration).createProjectIntegrationUsingPOST(createRequest, pluginName, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete all global integrations by type
         * @param {string} type type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllIntegrationsUsingDELETE(type: string, options?: any) {
            return IntegrationControllerApiFp(configuration).deleteAllIntegrationsUsingDELETE(type, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete all integrations assigned to specified project
         * @param {string} projectName projectName
         * @param {string} type type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllProjectIntegrationsUsingDELETE(projectName: string, type: string, options?: any) {
            return IntegrationControllerApiFp(configuration).deleteAllProjectIntegrationsUsingDELETE(projectName, type, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete global integration instance
         * @param {number} integrationId integrationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGlobalIntegrationUsingDELETE(integrationId: number, options?: any) {
            return IntegrationControllerApiFp(configuration).deleteGlobalIntegrationUsingDELETE(integrationId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete project integration instance
         * @param {number} integrationId integrationId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectIntegrationUsingDELETE(integrationId: number, projectName: string, options?: any) {
            return IntegrationControllerApiFp(configuration).deleteProjectIntegrationUsingDELETE(integrationId, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Execute command to the integration instance
         * @param {string} command command
         * @param {any} executionParams executionParams
         * @param {number} integrationId integrationId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeIntegrationCommandUsingPUT(command: string, executionParams: any, integrationId: number, projectName: string, options?: any) {
            return IntegrationControllerApiFp(configuration).executeIntegrationCommandUsingPUT(command, executionParams, integrationId, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get global Report Portal integration instance
         * @param {number} integrationId integrationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGlobalIntegrationUsingGET(integrationId: number, options?: any) {
            return IntegrationControllerApiFp(configuration).getGlobalIntegrationUsingGET(integrationId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get available global integrations for plugin
         * @param {string} pluginName pluginName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGlobalIntegrationsUsingGET(pluginName: string, options?: any) {
            return IntegrationControllerApiFp(configuration).getGlobalIntegrationsUsingGET(pluginName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get available global integrations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGlobalIntegrationsUsingGET1(options?: any) {
            return IntegrationControllerApiFp(configuration).getGlobalIntegrationsUsingGET1(options)(fetch, basePath);
        },
        /**
         *
         * @summary Get integration instance
         * @param {number} integrationId integrationId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectIntegrationUsingGET(integrationId: number, projectName: string, options?: any) {
            return IntegrationControllerApiFp(configuration).getProjectIntegrationUsingGET(integrationId, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get available project integrations for plugin
         * @param {string} pluginName pluginName
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectIntegrationsUsingGET(pluginName: string, projectName: string, options?: any) {
            return IntegrationControllerApiFp(configuration).getProjectIntegrationsUsingGET(pluginName, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get available project integrations
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectIntegrationsUsingGET1(projectName: string, options?: any) {
            return IntegrationControllerApiFp(configuration).getProjectIntegrationsUsingGET1(projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Test connection to the global integration
         * @param {number} integrationId integrationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testIntegrationConnectionUsingGET(integrationId: number, options?: any) {
            return IntegrationControllerApiFp(configuration).testIntegrationConnectionUsingGET(integrationId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Test connection to the integration through the project config
         * @param {number} integrationId integrationId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testIntegrationConnectionUsingGET1(integrationId: number, projectName: string, options?: any) {
            return IntegrationControllerApiFp(configuration).testIntegrationConnectionUsingGET1(integrationId, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update global Report Portal integration instance
         * @param {number} integrationId integrationId
         * @param {IntegrationRQ} updateRequest updateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGlobalIntegrationUsingPUT(integrationId: number, updateRequest: IntegrationRQ, options?: any) {
            return IntegrationControllerApiFp(configuration).updateGlobalIntegrationUsingPUT(integrationId, updateRequest, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update project integration instance
         * @param {number} integrationId integrationId
         * @param {string} projectName projectName
         * @param {IntegrationRQ} updateRequest updateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectIntegrationUsingPUT(integrationId: number, projectName: string, updateRequest: IntegrationRQ, options?: any) {
            return IntegrationControllerApiFp(configuration).updateProjectIntegrationUsingPUT(integrationId, projectName, updateRequest, options)(fetch, basePath);
        },
    };
};

/**
 * IntegrationControllerApi - object-oriented interface
 * @export
 * @class IntegrationControllerApi
 * @extends {BaseAPI}
 */
export class IntegrationControllerApi extends BaseAPI {
    /**
     *
     * @summary Create global Report Portal integration instance
     * @param {IntegrationRQ} createRequest createRequest
     * @param {string} pluginName pluginName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationControllerApi
     */
    public createGlobalIntegrationUsingPOST(createRequest: IntegrationRQ, pluginName: string, options?: any) {
        return IntegrationControllerApiFp(this.configuration).createGlobalIntegrationUsingPOST(createRequest, pluginName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Create project Report Portal integration instance
     * @param {IntegrationRQ} createRequest createRequest
     * @param {string} pluginName pluginName
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationControllerApi
     */
    public createProjectIntegrationUsingPOST(createRequest: IntegrationRQ, pluginName: string, projectName: string, options?: any) {
        return IntegrationControllerApiFp(this.configuration).createProjectIntegrationUsingPOST(createRequest, pluginName, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete all global integrations by type
     * @param {string} type type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationControllerApi
     */
    public deleteAllIntegrationsUsingDELETE(type: string, options?: any) {
        return IntegrationControllerApiFp(this.configuration).deleteAllIntegrationsUsingDELETE(type, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete all integrations assigned to specified project
     * @param {string} projectName projectName
     * @param {string} type type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationControllerApi
     */
    public deleteAllProjectIntegrationsUsingDELETE(projectName: string, type: string, options?: any) {
        return IntegrationControllerApiFp(this.configuration).deleteAllProjectIntegrationsUsingDELETE(projectName, type, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete global integration instance
     * @param {number} integrationId integrationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationControllerApi
     */
    public deleteGlobalIntegrationUsingDELETE(integrationId: number, options?: any) {
        return IntegrationControllerApiFp(this.configuration).deleteGlobalIntegrationUsingDELETE(integrationId, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete project integration instance
     * @param {number} integrationId integrationId
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationControllerApi
     */
    public deleteProjectIntegrationUsingDELETE(integrationId: number, projectName: string, options?: any) {
        return IntegrationControllerApiFp(this.configuration).deleteProjectIntegrationUsingDELETE(integrationId, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Execute command to the integration instance
     * @param {string} command command
     * @param {any} executionParams executionParams
     * @param {number} integrationId integrationId
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationControllerApi
     */
    public executeIntegrationCommandUsingPUT(command: string, executionParams: any, integrationId: number, projectName: string, options?: any) {
        return IntegrationControllerApiFp(this.configuration).executeIntegrationCommandUsingPUT(command, executionParams, integrationId, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get global Report Portal integration instance
     * @param {number} integrationId integrationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationControllerApi
     */
    public getGlobalIntegrationUsingGET(integrationId: number, options?: any) {
        return IntegrationControllerApiFp(this.configuration).getGlobalIntegrationUsingGET(integrationId, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get available global integrations for plugin
     * @param {string} pluginName pluginName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationControllerApi
     */
    public getGlobalIntegrationsUsingGET(pluginName: string, options?: any) {
        return IntegrationControllerApiFp(this.configuration).getGlobalIntegrationsUsingGET(pluginName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get available global integrations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationControllerApi
     */
    public getGlobalIntegrationsUsingGET1(options?: any) {
        return IntegrationControllerApiFp(this.configuration).getGlobalIntegrationsUsingGET1(options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get integration instance
     * @param {number} integrationId integrationId
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationControllerApi
     */
    public getProjectIntegrationUsingGET(integrationId: number, projectName: string, options?: any) {
        return IntegrationControllerApiFp(this.configuration).getProjectIntegrationUsingGET(integrationId, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get available project integrations for plugin
     * @param {string} pluginName pluginName
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationControllerApi
     */
    public getProjectIntegrationsUsingGET(pluginName: string, projectName: string, options?: any) {
        return IntegrationControllerApiFp(this.configuration).getProjectIntegrationsUsingGET(pluginName, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get available project integrations
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationControllerApi
     */
    public getProjectIntegrationsUsingGET1(projectName: string, options?: any) {
        return IntegrationControllerApiFp(this.configuration).getProjectIntegrationsUsingGET1(projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Test connection to the global integration
     * @param {number} integrationId integrationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationControllerApi
     */
    public testIntegrationConnectionUsingGET(integrationId: number, options?: any) {
        return IntegrationControllerApiFp(this.configuration).testIntegrationConnectionUsingGET(integrationId, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Test connection to the integration through the project config
     * @param {number} integrationId integrationId
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationControllerApi
     */
    public testIntegrationConnectionUsingGET1(integrationId: number, projectName: string, options?: any) {
        return IntegrationControllerApiFp(this.configuration).testIntegrationConnectionUsingGET1(integrationId, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Update global Report Portal integration instance
     * @param {number} integrationId integrationId
     * @param {IntegrationRQ} updateRequest updateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationControllerApi
     */
    public updateGlobalIntegrationUsingPUT(integrationId: number, updateRequest: IntegrationRQ, options?: any) {
        return IntegrationControllerApiFp(this.configuration).updateGlobalIntegrationUsingPUT(integrationId, updateRequest, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Update project integration instance
     * @param {number} integrationId integrationId
     * @param {string} projectName projectName
     * @param {IntegrationRQ} updateRequest updateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationControllerApi
     */
    public updateProjectIntegrationUsingPUT(integrationId: number, projectName: string, updateRequest: IntegrationRQ, options?: any) {
        return IntegrationControllerApiFp(this.configuration).updateProjectIntegrationUsingPUT(integrationId, projectName, updateRequest, options)(this.fetch, this.basePath);
    }

}

/**
 * LaunchAsyncControllerApi - fetch parameter creator
 * @export
 */
export const LaunchAsyncControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Finish launch for specified project
         * @param {FinishExecutionRQ} finishLaunchRQ finishLaunchRQ
         * @param {string} launchId launchId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finishLaunchUsingPUT(finishLaunchRQ: FinishExecutionRQ, launchId: string, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'finishLaunchRQ' is not null or undefined
            if (finishLaunchRQ === null || finishLaunchRQ === undefined) {
                throw new RequiredError('finishLaunchRQ', 'Required parameter finishLaunchRQ was null or undefined when calling finishLaunchUsingPUT.');
            }
            // verify required parameter 'launchId' is not null or undefined
            if (launchId === null || launchId === undefined) {
                throw new RequiredError('launchId', 'Required parameter launchId was null or undefined when calling finishLaunchUsingPUT.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling finishLaunchUsingPUT.');
            }
            const localVarPath = `/v2/{projectName}/launch/{launchId}/finish`
                .replace(`{${"launchId"}}`, encodeURIComponent(String(launchId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'PUT'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"FinishExecutionRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(finishLaunchRQ || {}) : (finishLaunchRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Merge set of specified launches in common one
         * @param {MergeLaunchesRQ} mergeLaunchesRQ Merge launches request body
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeLaunchesUsingPOST(mergeLaunchesRQ: MergeLaunchesRQ, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'mergeLaunchesRQ' is not null or undefined
            if (mergeLaunchesRQ === null || mergeLaunchesRQ === undefined) {
                throw new RequiredError('mergeLaunchesRQ', 'Required parameter mergeLaunchesRQ was null or undefined when calling mergeLaunchesUsingPOST.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling mergeLaunchesUsingPOST.');
            }
            const localVarPath = `/v2/{projectName}/launch/merge`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MergeLaunchesRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(mergeLaunchesRQ || {}) : (mergeLaunchesRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Starts launch for specified project
         * @param {string} projectName projectName
         * @param {StartLaunchRQ} startLaunchRQ Start launch request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startLaunchUsingPOST(projectName: string, startLaunchRQ: StartLaunchRQ, options: any = {}): FetchArgs {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling startLaunchUsingPOST.');
            }
            // verify required parameter 'startLaunchRQ' is not null or undefined
            if (startLaunchRQ === null || startLaunchRQ === undefined) {
                throw new RequiredError('startLaunchRQ', 'Required parameter startLaunchRQ was null or undefined when calling startLaunchUsingPOST.');
            }
            const localVarPath = `/v2/{projectName}/launch`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"StartLaunchRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(startLaunchRQ || {}) : (startLaunchRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LaunchAsyncControllerApi - functional programming interface
 * @export
 */
export const LaunchAsyncControllerApiFp = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Finish launch for specified project
         * @param {FinishExecutionRQ} finishLaunchRQ finishLaunchRQ
         * @param {string} launchId launchId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finishLaunchUsingPUT(finishLaunchRQ: FinishExecutionRQ, launchId: string, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FinishLaunchRS> {
            const localVarFetchArgs = LaunchAsyncControllerApiFetchParamCreator(configuration).finishLaunchUsingPUT(finishLaunchRQ, launchId, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Merge set of specified launches in common one
         * @param {MergeLaunchesRQ} mergeLaunchesRQ Merge launches request body
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeLaunchesUsingPOST(mergeLaunchesRQ: MergeLaunchesRQ, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LaunchResource> {
            const localVarFetchArgs = LaunchAsyncControllerApiFetchParamCreator(configuration).mergeLaunchesUsingPOST(mergeLaunchesRQ, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Starts launch for specified project
         * @param {string} projectName projectName
         * @param {StartLaunchRQ} startLaunchRQ Start launch request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startLaunchUsingPOST(projectName: string, startLaunchRQ: StartLaunchRQ, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StartLaunchRS> {
            const localVarFetchArgs = LaunchAsyncControllerApiFetchParamCreator(configuration).startLaunchUsingPOST(projectName, startLaunchRQ, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LaunchAsyncControllerApi - factory interface
 * @export
 */
export const LaunchAsyncControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Finish launch for specified project
         * @param {FinishExecutionRQ} finishLaunchRQ finishLaunchRQ
         * @param {string} launchId launchId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finishLaunchUsingPUT(finishLaunchRQ: FinishExecutionRQ, launchId: string, projectName: string, options?: any) {
            return LaunchAsyncControllerApiFp(configuration).finishLaunchUsingPUT(finishLaunchRQ, launchId, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Merge set of specified launches in common one
         * @param {MergeLaunchesRQ} mergeLaunchesRQ Merge launches request body
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeLaunchesUsingPOST(mergeLaunchesRQ: MergeLaunchesRQ, projectName: string, options?: any) {
            return LaunchAsyncControllerApiFp(configuration).mergeLaunchesUsingPOST(mergeLaunchesRQ, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Starts launch for specified project
         * @param {string} projectName projectName
         * @param {StartLaunchRQ} startLaunchRQ Start launch request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startLaunchUsingPOST(projectName: string, startLaunchRQ: StartLaunchRQ, options?: any) {
            return LaunchAsyncControllerApiFp(configuration).startLaunchUsingPOST(projectName, startLaunchRQ, options)(fetch, basePath);
        },
    };
};

/**
 * LaunchAsyncControllerApi - object-oriented interface
 * @export
 * @class LaunchAsyncControllerApi
 * @extends {BaseAPI}
 */
export class LaunchAsyncControllerApi extends BaseAPI {
    /**
     *
     * @summary Finish launch for specified project
     * @param {FinishExecutionRQ} finishLaunchRQ finishLaunchRQ
     * @param {string} launchId launchId
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaunchAsyncControllerApi
     */
    public finishLaunchUsingPUT(finishLaunchRQ: FinishExecutionRQ, launchId: string, projectName: string, options?: any) {
        return LaunchAsyncControllerApiFp(this.configuration).finishLaunchUsingPUT(finishLaunchRQ, launchId, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Merge set of specified launches in common one
     * @param {MergeLaunchesRQ} mergeLaunchesRQ Merge launches request body
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaunchAsyncControllerApi
     */
    public mergeLaunchesUsingPOST(mergeLaunchesRQ: MergeLaunchesRQ, projectName: string, options?: any) {
        return LaunchAsyncControllerApiFp(this.configuration).mergeLaunchesUsingPOST(mergeLaunchesRQ, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Starts launch for specified project
     * @param {string} projectName projectName
     * @param {StartLaunchRQ} startLaunchRQ Start launch request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaunchAsyncControllerApi
     */
    public startLaunchUsingPOST(projectName: string, startLaunchRQ: StartLaunchRQ, options?: any) {
        return LaunchAsyncControllerApiFp(this.configuration).startLaunchUsingPOST(projectName, startLaunchRQ, options)(this.fetch, this.basePath);
    }

}

/**
 * LaunchControllerApi - fetch parameter creator
 * @export
 */
export const LaunchControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Force finish launch
         * @param {string} projectName projectName
         * @param {BulkRQlongFinishExecutionRQ} rq rq
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkForceFinishUsingPUT(projectName: string, rq: BulkRQlongFinishExecutionRQ, options: any = {}): FetchArgs {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling bulkForceFinishUsingPUT.');
            }
            // verify required parameter 'rq' is not null or undefined
            if (rq === null || rq === undefined) {
                throw new RequiredError('rq', 'Required parameter rq was null or undefined when calling bulkForceFinishUsingPUT.');
            }
            const localVarPath = `/v1/{projectName}/launch/stop`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'PUT'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BulkRQlongFinishExecutionRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(rq || {}) : (rq || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Bulk update attributes and description
         * @param {BulkInfoUpdateRQ} bulkInfoUpdateRQ bulkInfoUpdateRQ
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateUsingPUT(bulkInfoUpdateRQ: BulkInfoUpdateRQ, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'bulkInfoUpdateRQ' is not null or undefined
            if (bulkInfoUpdateRQ === null || bulkInfoUpdateRQ === undefined) {
                throw new RequiredError('bulkInfoUpdateRQ', 'Required parameter bulkInfoUpdateRQ was null or undefined when calling bulkUpdateUsingPUT.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling bulkUpdateUsingPUT.');
            }
            const localVarPath = `/v1/{projectName}/launch/info`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'PUT'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BulkInfoUpdateRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(bulkInfoUpdateRQ || {}) : (bulkInfoUpdateRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Compare launches
         * @param {Array<number>} ids ids
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compareLaunchesUsingGET(ids: Array<number>, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'ids' is not null or undefined
            if (ids === null || ids === undefined) {
                throw new RequiredError('ids', 'Required parameter ids was null or undefined when calling compareLaunchesUsingGET.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling compareLaunchesUsingGET.');
            }
            const localVarPath = `/v1/{projectName}/launch/compare`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create launch clusters
         * @param {CreateClustersRQ} createClustersRQ createClustersRQ
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClustersUsingPOST(createClustersRQ: CreateClustersRQ, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'createClustersRQ' is not null or undefined
            if (createClustersRQ === null || createClustersRQ === undefined) {
                throw new RequiredError('createClustersRQ', 'Required parameter createClustersRQ was null or undefined when calling createClustersUsingPOST.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling createClustersUsingPOST.');
            }
            const localVarPath = `/v1/{projectName}/launch/cluster`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateClustersRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(createClustersRQ || {}) : (createClustersRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete specified launch by ID
         * @param {number} launchId launchId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLaunchUsingDELETE(launchId: number, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'launchId' is not null or undefined
            if (launchId === null || launchId === undefined) {
                throw new RequiredError('launchId', 'Required parameter launchId was null or undefined when calling deleteLaunchUsingDELETE.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling deleteLaunchUsingDELETE.');
            }
            const localVarPath = `/v1/{projectName}/launch/{launchId}`
                .replace(`{${"launchId"}}`, encodeURIComponent(String(launchId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'DELETE'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete specified launches by ids
         * @param {DeleteBulkRQ} deleteBulkRQ deleteBulkRQ
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLaunchesUsingDELETE(deleteBulkRQ: DeleteBulkRQ, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'deleteBulkRQ' is not null or undefined
            if (deleteBulkRQ === null || deleteBulkRQ === undefined) {
                throw new RequiredError('deleteBulkRQ', 'Required parameter deleteBulkRQ was null or undefined when calling deleteLaunchesUsingDELETE.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling deleteLaunchesUsingDELETE.');
            }
            const localVarPath = `/v1/{projectName}/launch`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'DELETE'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DeleteBulkRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(deleteBulkRQ || {}) : (deleteBulkRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Finish launch for specified project
         * @param {FinishExecutionRQ} finishLaunchRQ finishLaunchRQ
         * @param {string} launchId launchId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finishLaunchUsingPUT1(finishLaunchRQ: FinishExecutionRQ, launchId: string, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'finishLaunchRQ' is not null or undefined
            if (finishLaunchRQ === null || finishLaunchRQ === undefined) {
                throw new RequiredError('finishLaunchRQ', 'Required parameter finishLaunchRQ was null or undefined when calling finishLaunchUsingPUT1.');
            }
            // verify required parameter 'launchId' is not null or undefined
            if (launchId === null || launchId === undefined) {
                throw new RequiredError('launchId', 'Required parameter launchId was null or undefined when calling finishLaunchUsingPUT1.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling finishLaunchUsingPUT1.');
            }
            const localVarPath = `/v1/{projectName}/launch/{launchId}/finish`
                .replace(`{${"launchId"}}`, encodeURIComponent(String(launchId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'PUT'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"FinishExecutionRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(finishLaunchRQ || {}) : (finishLaunchRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Force finish launch for specified project
         * @param {FinishExecutionRQ} finishExecutionRQ finishExecutionRQ
         * @param {number} launchId launchId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forceFinishLaunchUsingPUT(finishExecutionRQ: FinishExecutionRQ, launchId: number, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'finishExecutionRQ' is not null or undefined
            if (finishExecutionRQ === null || finishExecutionRQ === undefined) {
                throw new RequiredError('finishExecutionRQ', 'Required parameter finishExecutionRQ was null or undefined when calling forceFinishLaunchUsingPUT.');
            }
            // verify required parameter 'launchId' is not null or undefined
            if (launchId === null || launchId === undefined) {
                throw new RequiredError('launchId', 'Required parameter launchId was null or undefined when calling forceFinishLaunchUsingPUT.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling forceFinishLaunchUsingPUT.');
            }
            const localVarPath = `/v1/{projectName}/launch/{launchId}/stop`
                .replace(`{${"launchId"}}`, encodeURIComponent(String(launchId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'PUT'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"FinishExecutionRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(finishExecutionRQ || {}) : (finishExecutionRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get launch names of project
         * @param {string} projectName projectName
         * @param {string} [filterCntName] filter.cnt.name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllLaunchNamesUsingGET(projectName: string, filterCntName?: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getAllLaunchNamesUsingGET.');
            }
            const localVarPath = `/v1/{projectName}/launch/names`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filterCntName !== undefined) {
                localVarQueryParameter['filter.cnt.name'] = filterCntName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all unique owners of project launches
         * @param {string} filterCntUser filter.cnt.user
         * @param {string} projectName projectName
         * @param {string} [mode] mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOwnersUsingGET(filterCntUser: string, projectName: string, mode?: string, options: any = {}): FetchArgs {
            // verify required parameter 'filterCntUser' is not null or undefined
            if (filterCntUser === null || filterCntUser === undefined) {
                throw new RequiredError('filterCntUser', 'Required parameter filterCntUser was null or undefined when calling getAllOwnersUsingGET.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getAllOwnersUsingGET.');
            }
            const localVarPath = `/v1/{projectName}/launch/owners`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filterCntUser !== undefined) {
                localVarQueryParameter['filter.cnt.user'] = filterCntUser;
            }

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all unique attribute keys of project launches
         * @param {string} filterCntAttributeKey filter.cnt.attributeKey
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributeKeysUsingGET(filterCntAttributeKey: string, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'filterCntAttributeKey' is not null or undefined
            if (filterCntAttributeKey === null || filterCntAttributeKey === undefined) {
                throw new RequiredError('filterCntAttributeKey', 'Required parameter filterCntAttributeKey was null or undefined when calling getAttributeKeysUsingGET.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getAttributeKeysUsingGET.');
            }
            const localVarPath = `/v1/{projectName}/launch/attribute/keys`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filterCntAttributeKey !== undefined) {
                localVarQueryParameter['filter.cnt.attributeKey'] = filterCntAttributeKey;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all unique attribute values of project launches
         * @param {string} filterCntAttributeValue filter.cnt.attributeValue
         * @param {string} projectName projectName
         * @param {string} [filterEqAttributeKey] filter.eq.attributeKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributeValuesUsingGET(filterCntAttributeValue: string, projectName: string, filterEqAttributeKey?: string, options: any = {}): FetchArgs {
            // verify required parameter 'filterCntAttributeValue' is not null or undefined
            if (filterCntAttributeValue === null || filterCntAttributeValue === undefined) {
                throw new RequiredError('filterCntAttributeValue', 'Required parameter filterCntAttributeValue was null or undefined when calling getAttributeValuesUsingGET.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getAttributeValuesUsingGET.');
            }
            const localVarPath = `/v1/{projectName}/launch/attribute/values`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filterCntAttributeValue !== undefined) {
                localVarQueryParameter['filter.cnt.attributeValue'] = filterCntAttributeValue;
            }

            if (filterEqAttributeKey !== undefined) {
                localVarQueryParameter['filter.eq.attributeKey'] = filterEqAttributeKey;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all index clusters of the launch
         * @param {string} launchId launchId
         * @param {string} projectName projectName
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClustersUsingGET(launchId: string, projectName: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'launchId' is not null or undefined
            if (launchId === null || launchId === undefined) {
                throw new RequiredError('launchId', 'Required parameter launchId was null or undefined when calling getClustersUsingGET.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getClustersUsingGET.');
            }
            const localVarPath = `/v1/{projectName}/launch/cluster/{launchId}`
                .replace(`{${"launchId"}}`, encodeURIComponent(String(launchId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pagePage !== undefined) {
                localVarQueryParameter['page.page'] = pagePage;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page.size'] = pageSize;
            }

            if (pageSort) {
                localVarQueryParameter['page.sort'] = pageSort;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get launches of specified project from DEBUG mode
         * @param {string} projectName projectName
         * @param {string} [filterEqAttributeKey] Filters by &#39;attributeKey&#39;
         * @param {string} [filterEqAttributeValue] Filters by &#39;attributeValue&#39;
         * @param {Array<string>} [filterEqCompositeAttribute] Filters by &#39;compositeAttribute&#39;
         * @param {string} [filterEqDescription] Filters by &#39;description&#39;
         * @param {Date} [filterEqEndTime] Filters by &#39;endTime&#39;
         * @param {boolean} [filterEqHasRetries] Filters by &#39;hasRetries&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {Date} [filterEqLastModified] Filters by &#39;lastModified&#39;
         * @param {string} [filterEqMode] Filters by &#39;mode&#39;
         * @param {string} [filterEqName] Filters by &#39;name&#39;
         * @param {number} [filterEqNumber] Filters by &#39;number&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {Date} [filterEqStartTime] Filters by &#39;startTime&#39;
         * @param {number} [filterEqStatisticsdefectsautomationBugab001] Filters by &#39;statistics$defects$automation_bug$ab001&#39;
         * @param {number} [filterEqStatisticsdefectsnoDefectnd001] Filters by &#39;statistics$defects$no_defect$nd001&#39;
         * @param {number} [filterEqStatisticsdefectsproductBugpb001] Filters by &#39;statistics$defects$product_bug$pb001&#39;
         * @param {number} [filterEqStatisticsdefectssystemIssuesi001] Filters by &#39;statistics$defects$system_issue$si001&#39;
         * @param {number} [filterEqStatisticsdefectstoInvestigateti001] Filters by &#39;statistics$defects$to_investigate$ti001&#39;
         * @param {number} [filterEqStatisticsexecutionsfailed] Filters by &#39;statistics$executions$failed&#39;
         * @param {number} [filterEqStatisticsexecutionspassed] Filters by &#39;statistics$executions$passed&#39;
         * @param {number} [filterEqStatisticsexecutionsskipped] Filters by &#39;statistics$executions$skipped&#39;
         * @param {number} [filterEqStatisticsexecutionstotal] Filters by &#39;statistics$executions$total&#39;
         * @param {string} [filterEqStatus] Filters by &#39;status&#39;
         * @param {string} [filterEqUser] Filters by &#39;user&#39;
         * @param {number} [filterEqUserId] Filters by &#39;userId&#39;
         * @param {string} [filterEqUuid] Filters by &#39;uuid&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDebugLaunchesUsingGET(projectName: string, filterEqAttributeKey?: string, filterEqAttributeValue?: string, filterEqCompositeAttribute?: Array<string>, filterEqDescription?: string, filterEqEndTime?: Date, filterEqHasRetries?: boolean, filterEqId?: number, filterEqLastModified?: Date, filterEqMode?: string, filterEqName?: string, filterEqNumber?: number, filterEqProjectId?: number, filterEqStartTime?: Date, filterEqStatisticsdefectsautomationBugab001?: number, filterEqStatisticsdefectsnoDefectnd001?: number, filterEqStatisticsdefectsproductBugpb001?: number, filterEqStatisticsdefectssystemIssuesi001?: number, filterEqStatisticsdefectstoInvestigateti001?: number, filterEqStatisticsexecutionsfailed?: number, filterEqStatisticsexecutionspassed?: number, filterEqStatisticsexecutionsskipped?: number, filterEqStatisticsexecutionstotal?: number, filterEqStatus?: string, filterEqUser?: string, filterEqUserId?: number, filterEqUuid?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getDebugLaunchesUsingGET.');
            }
            const localVarPath = `/v1/{projectName}/launch/mode`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filterEqAttributeKey !== undefined) {
                localVarQueryParameter['filter.eq.attributeKey'] = filterEqAttributeKey;
            }

            if (filterEqAttributeValue !== undefined) {
                localVarQueryParameter['filter.eq.attributeValue'] = filterEqAttributeValue;
            }

            if (filterEqCompositeAttribute) {
                localVarQueryParameter['filter.eq.compositeAttribute'] = filterEqCompositeAttribute;
            }

            if (filterEqDescription !== undefined) {
                localVarQueryParameter['filter.eq.description'] = filterEqDescription;
            }

            if (filterEqEndTime !== undefined) {
                localVarQueryParameter['filter.eq.endTime'] = (filterEqEndTime as any).toISOString();
            }

            if (filterEqHasRetries !== undefined) {
                localVarQueryParameter['filter.eq.hasRetries'] = filterEqHasRetries;
            }

            if (filterEqId !== undefined) {
                localVarQueryParameter['filter.eq.id'] = filterEqId;
            }

            if (filterEqLastModified !== undefined) {
                localVarQueryParameter['filter.eq.lastModified'] = (filterEqLastModified as any).toISOString();
            }

            if (filterEqMode !== undefined) {
                localVarQueryParameter['filter.eq.mode'] = filterEqMode;
            }

            if (filterEqName !== undefined) {
                localVarQueryParameter['filter.eq.name'] = filterEqName;
            }

            if (filterEqNumber !== undefined) {
                localVarQueryParameter['filter.eq.number'] = filterEqNumber;
            }

            if (filterEqProjectId !== undefined) {
                localVarQueryParameter['filter.eq.projectId'] = filterEqProjectId;
            }

            if (filterEqStartTime !== undefined) {
                localVarQueryParameter['filter.eq.startTime'] = (filterEqStartTime as any).toISOString();
            }

            if (filterEqStatisticsdefectsautomationBugab001 !== undefined) {
                localVarQueryParameter['filter.eq.statistics$defects$automation_bug$ab001'] = filterEqStatisticsdefectsautomationBugab001;
            }

            if (filterEqStatisticsdefectsnoDefectnd001 !== undefined) {
                localVarQueryParameter['filter.eq.statistics$defects$no_defect$nd001'] = filterEqStatisticsdefectsnoDefectnd001;
            }

            if (filterEqStatisticsdefectsproductBugpb001 !== undefined) {
                localVarQueryParameter['filter.eq.statistics$defects$product_bug$pb001'] = filterEqStatisticsdefectsproductBugpb001;
            }

            if (filterEqStatisticsdefectssystemIssuesi001 !== undefined) {
                localVarQueryParameter['filter.eq.statistics$defects$system_issue$si001'] = filterEqStatisticsdefectssystemIssuesi001;
            }

            if (filterEqStatisticsdefectstoInvestigateti001 !== undefined) {
                localVarQueryParameter['filter.eq.statistics$defects$to_investigate$ti001'] = filterEqStatisticsdefectstoInvestigateti001;
            }

            if (filterEqStatisticsexecutionsfailed !== undefined) {
                localVarQueryParameter['filter.eq.statistics$executions$failed'] = filterEqStatisticsexecutionsfailed;
            }

            if (filterEqStatisticsexecutionspassed !== undefined) {
                localVarQueryParameter['filter.eq.statistics$executions$passed'] = filterEqStatisticsexecutionspassed;
            }

            if (filterEqStatisticsexecutionsskipped !== undefined) {
                localVarQueryParameter['filter.eq.statistics$executions$skipped'] = filterEqStatisticsexecutionsskipped;
            }

            if (filterEqStatisticsexecutionstotal !== undefined) {
                localVarQueryParameter['filter.eq.statistics$executions$total'] = filterEqStatisticsexecutionstotal;
            }

            if (filterEqStatus !== undefined) {
                localVarQueryParameter['filter.eq.status'] = filterEqStatus;
            }

            if (filterEqUser !== undefined) {
                localVarQueryParameter['filter.eq.user'] = filterEqUser;
            }

            if (filterEqUserId !== undefined) {
                localVarQueryParameter['filter.eq.userId'] = filterEqUserId;
            }

            if (filterEqUuid !== undefined) {
                localVarQueryParameter['filter.eq.uuid'] = filterEqUuid;
            }

            if (pagePage !== undefined) {
                localVarQueryParameter['page.page'] = pagePage;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page.size'] = pageSize;
            }

            if (pageSort) {
                localVarQueryParameter['page.sort'] = pageSort;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get list of latest project launches by filter
         * @param {string} projectName projectName
         * @param {string} [filterEqAttributeKey] Filters by &#39;attributeKey&#39;
         * @param {string} [filterEqAttributeValue] Filters by &#39;attributeValue&#39;
         * @param {Array<string>} [filterEqCompositeAttribute] Filters by &#39;compositeAttribute&#39;
         * @param {string} [filterEqDescription] Filters by &#39;description&#39;
         * @param {Date} [filterEqEndTime] Filters by &#39;endTime&#39;
         * @param {boolean} [filterEqHasRetries] Filters by &#39;hasRetries&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {Date} [filterEqLastModified] Filters by &#39;lastModified&#39;
         * @param {string} [filterEqMode] Filters by &#39;mode&#39;
         * @param {string} [filterEqName] Filters by &#39;name&#39;
         * @param {number} [filterEqNumber] Filters by &#39;number&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {Date} [filterEqStartTime] Filters by &#39;startTime&#39;
         * @param {number} [filterEqStatisticsdefectsautomationBugab001] Filters by &#39;statistics$defects$automation_bug$ab001&#39;
         * @param {number} [filterEqStatisticsdefectsnoDefectnd001] Filters by &#39;statistics$defects$no_defect$nd001&#39;
         * @param {number} [filterEqStatisticsdefectsproductBugpb001] Filters by &#39;statistics$defects$product_bug$pb001&#39;
         * @param {number} [filterEqStatisticsdefectssystemIssuesi001] Filters by &#39;statistics$defects$system_issue$si001&#39;
         * @param {number} [filterEqStatisticsdefectstoInvestigateti001] Filters by &#39;statistics$defects$to_investigate$ti001&#39;
         * @param {number} [filterEqStatisticsexecutionsfailed] Filters by &#39;statistics$executions$failed&#39;
         * @param {number} [filterEqStatisticsexecutionspassed] Filters by &#39;statistics$executions$passed&#39;
         * @param {number} [filterEqStatisticsexecutionsskipped] Filters by &#39;statistics$executions$skipped&#39;
         * @param {number} [filterEqStatisticsexecutionstotal] Filters by &#39;statistics$executions$total&#39;
         * @param {string} [filterEqStatus] Filters by &#39;status&#39;
         * @param {string} [filterEqUser] Filters by &#39;user&#39;
         * @param {number} [filterEqUserId] Filters by &#39;userId&#39;
         * @param {string} [filterEqUuid] Filters by &#39;uuid&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestLaunchesUsingGET(projectName: string, filterEqAttributeKey?: string, filterEqAttributeValue?: string, filterEqCompositeAttribute?: Array<string>, filterEqDescription?: string, filterEqEndTime?: Date, filterEqHasRetries?: boolean, filterEqId?: number, filterEqLastModified?: Date, filterEqMode?: string, filterEqName?: string, filterEqNumber?: number, filterEqProjectId?: number, filterEqStartTime?: Date, filterEqStatisticsdefectsautomationBugab001?: number, filterEqStatisticsdefectsnoDefectnd001?: number, filterEqStatisticsdefectsproductBugpb001?: number, filterEqStatisticsdefectssystemIssuesi001?: number, filterEqStatisticsdefectstoInvestigateti001?: number, filterEqStatisticsexecutionsfailed?: number, filterEqStatisticsexecutionspassed?: number, filterEqStatisticsexecutionsskipped?: number, filterEqStatisticsexecutionstotal?: number, filterEqStatus?: string, filterEqUser?: string, filterEqUserId?: number, filterEqUuid?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getLatestLaunchesUsingGET.');
            }
            const localVarPath = `/v1/{projectName}/launch/latest`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filterEqAttributeKey !== undefined) {
                localVarQueryParameter['filter.eq.attributeKey'] = filterEqAttributeKey;
            }

            if (filterEqAttributeValue !== undefined) {
                localVarQueryParameter['filter.eq.attributeValue'] = filterEqAttributeValue;
            }

            if (filterEqCompositeAttribute) {
                localVarQueryParameter['filter.eq.compositeAttribute'] = filterEqCompositeAttribute;
            }

            if (filterEqDescription !== undefined) {
                localVarQueryParameter['filter.eq.description'] = filterEqDescription;
            }

            if (filterEqEndTime !== undefined) {
                localVarQueryParameter['filter.eq.endTime'] = (filterEqEndTime as any).toISOString();
            }

            if (filterEqHasRetries !== undefined) {
                localVarQueryParameter['filter.eq.hasRetries'] = filterEqHasRetries;
            }

            if (filterEqId !== undefined) {
                localVarQueryParameter['filter.eq.id'] = filterEqId;
            }

            if (filterEqLastModified !== undefined) {
                localVarQueryParameter['filter.eq.lastModified'] = (filterEqLastModified as any).toISOString();
            }

            if (filterEqMode !== undefined) {
                localVarQueryParameter['filter.eq.mode'] = filterEqMode;
            }

            if (filterEqName !== undefined) {
                localVarQueryParameter['filter.eq.name'] = filterEqName;
            }

            if (filterEqNumber !== undefined) {
                localVarQueryParameter['filter.eq.number'] = filterEqNumber;
            }

            if (filterEqProjectId !== undefined) {
                localVarQueryParameter['filter.eq.projectId'] = filterEqProjectId;
            }

            if (filterEqStartTime !== undefined) {
                localVarQueryParameter['filter.eq.startTime'] = (filterEqStartTime as any).toISOString();
            }

            if (filterEqStatisticsdefectsautomationBugab001 !== undefined) {
                localVarQueryParameter['filter.eq.statistics$defects$automation_bug$ab001'] = filterEqStatisticsdefectsautomationBugab001;
            }

            if (filterEqStatisticsdefectsnoDefectnd001 !== undefined) {
                localVarQueryParameter['filter.eq.statistics$defects$no_defect$nd001'] = filterEqStatisticsdefectsnoDefectnd001;
            }

            if (filterEqStatisticsdefectsproductBugpb001 !== undefined) {
                localVarQueryParameter['filter.eq.statistics$defects$product_bug$pb001'] = filterEqStatisticsdefectsproductBugpb001;
            }

            if (filterEqStatisticsdefectssystemIssuesi001 !== undefined) {
                localVarQueryParameter['filter.eq.statistics$defects$system_issue$si001'] = filterEqStatisticsdefectssystemIssuesi001;
            }

            if (filterEqStatisticsdefectstoInvestigateti001 !== undefined) {
                localVarQueryParameter['filter.eq.statistics$defects$to_investigate$ti001'] = filterEqStatisticsdefectstoInvestigateti001;
            }

            if (filterEqStatisticsexecutionsfailed !== undefined) {
                localVarQueryParameter['filter.eq.statistics$executions$failed'] = filterEqStatisticsexecutionsfailed;
            }

            if (filterEqStatisticsexecutionspassed !== undefined) {
                localVarQueryParameter['filter.eq.statistics$executions$passed'] = filterEqStatisticsexecutionspassed;
            }

            if (filterEqStatisticsexecutionsskipped !== undefined) {
                localVarQueryParameter['filter.eq.statistics$executions$skipped'] = filterEqStatisticsexecutionsskipped;
            }

            if (filterEqStatisticsexecutionstotal !== undefined) {
                localVarQueryParameter['filter.eq.statistics$executions$total'] = filterEqStatisticsexecutionstotal;
            }

            if (filterEqStatus !== undefined) {
                localVarQueryParameter['filter.eq.status'] = filterEqStatus;
            }

            if (filterEqUser !== undefined) {
                localVarQueryParameter['filter.eq.user'] = filterEqUser;
            }

            if (filterEqUserId !== undefined) {
                localVarQueryParameter['filter.eq.userId'] = filterEqUserId;
            }

            if (filterEqUuid !== undefined) {
                localVarQueryParameter['filter.eq.uuid'] = filterEqUuid;
            }

            if (pagePage !== undefined) {
                localVarQueryParameter['page.page'] = pagePage;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page.size'] = pageSize;
            }

            if (pageSort) {
                localVarQueryParameter['page.sort'] = pageSort;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get specified launch by UUID
         * @param {string} launchId launchId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLaunchByUuidUsingGET(launchId: string, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'launchId' is not null or undefined
            if (launchId === null || launchId === undefined) {
                throw new RequiredError('launchId', 'Required parameter launchId was null or undefined when calling getLaunchByUuidUsingGET.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getLaunchByUuidUsingGET.');
            }
            const localVarPath = `/v1/{projectName}/launch/uuid/{launchId}`
                .replace(`{${"launchId"}}`, encodeURIComponent(String(launchId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only following formats are supported: pdf (by default), xls, html.
         * @summary Export specified launch
         * @param {number} launchId launchId
         * @param {string} projectName projectName
         * @param {'pdf' | 'xls' | 'html'} [view] view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLaunchReportUsingGET(launchId: number, projectName: string, view?: 'pdf' | 'xls' | 'html', options: any = {}): FetchArgs {
            // verify required parameter 'launchId' is not null or undefined
            if (launchId === null || launchId === undefined) {
                throw new RequiredError('launchId', 'Required parameter launchId was null or undefined when calling getLaunchReportUsingGET.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getLaunchReportUsingGET.');
            }
            const localVarPath = `/v1/{projectName}/launch/{launchId}/report`
                .replace(`{${"launchId"}}`, encodeURIComponent(String(launchId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get specified launch by ID
         * @param {string} launchId launchId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLaunchUsingGET(launchId: string, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'launchId' is not null or undefined
            if (launchId === null || launchId === undefined) {
                throw new RequiredError('launchId', 'Required parameter launchId was null or undefined when calling getLaunchUsingGET.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getLaunchUsingGET.');
            }
            const localVarPath = `/v1/{projectName}/launch/{launchId}`
                .replace(`{${"launchId"}}`, encodeURIComponent(String(launchId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get list of project launches by filter
         * @param {string} projectName projectName
         * @param {string} [filterEqAttributeKey] Filters by &#39;attributeKey&#39;
         * @param {string} [filterEqAttributeValue] Filters by &#39;attributeValue&#39;
         * @param {Array<string>} [filterEqCompositeAttribute] Filters by &#39;compositeAttribute&#39;
         * @param {string} [filterEqDescription] Filters by &#39;description&#39;
         * @param {Date} [filterEqEndTime] Filters by &#39;endTime&#39;
         * @param {boolean} [filterEqHasRetries] Filters by &#39;hasRetries&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {Date} [filterEqLastModified] Filters by &#39;lastModified&#39;
         * @param {string} [filterEqMode] Filters by &#39;mode&#39;
         * @param {string} [filterEqName] Filters by &#39;name&#39;
         * @param {number} [filterEqNumber] Filters by &#39;number&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {Date} [filterEqStartTime] Filters by &#39;startTime&#39;
         * @param {number} [filterEqStatisticsdefectsautomationBugab001] Filters by &#39;statistics$defects$automation_bug$ab001&#39;
         * @param {number} [filterEqStatisticsdefectsnoDefectnd001] Filters by &#39;statistics$defects$no_defect$nd001&#39;
         * @param {number} [filterEqStatisticsdefectsproductBugpb001] Filters by &#39;statistics$defects$product_bug$pb001&#39;
         * @param {number} [filterEqStatisticsdefectssystemIssuesi001] Filters by &#39;statistics$defects$system_issue$si001&#39;
         * @param {number} [filterEqStatisticsdefectstoInvestigateti001] Filters by &#39;statistics$defects$to_investigate$ti001&#39;
         * @param {number} [filterEqStatisticsexecutionsfailed] Filters by &#39;statistics$executions$failed&#39;
         * @param {number} [filterEqStatisticsexecutionspassed] Filters by &#39;statistics$executions$passed&#39;
         * @param {number} [filterEqStatisticsexecutionsskipped] Filters by &#39;statistics$executions$skipped&#39;
         * @param {number} [filterEqStatisticsexecutionstotal] Filters by &#39;statistics$executions$total&#39;
         * @param {string} [filterEqStatus] Filters by &#39;status&#39;
         * @param {string} [filterEqUser] Filters by &#39;user&#39;
         * @param {number} [filterEqUserId] Filters by &#39;userId&#39;
         * @param {string} [filterEqUuid] Filters by &#39;uuid&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectLaunchesUsingGET(projectName: string, filterEqAttributeKey?: string, filterEqAttributeValue?: string, filterEqCompositeAttribute?: Array<string>, filterEqDescription?: string, filterEqEndTime?: Date, filterEqHasRetries?: boolean, filterEqId?: number, filterEqLastModified?: Date, filterEqMode?: string, filterEqName?: string, filterEqNumber?: number, filterEqProjectId?: number, filterEqStartTime?: Date, filterEqStatisticsdefectsautomationBugab001?: number, filterEqStatisticsdefectsnoDefectnd001?: number, filterEqStatisticsdefectsproductBugpb001?: number, filterEqStatisticsdefectssystemIssuesi001?: number, filterEqStatisticsdefectstoInvestigateti001?: number, filterEqStatisticsexecutionsfailed?: number, filterEqStatisticsexecutionspassed?: number, filterEqStatisticsexecutionsskipped?: number, filterEqStatisticsexecutionstotal?: number, filterEqStatus?: string, filterEqUser?: string, filterEqUserId?: number, filterEqUuid?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getProjectLaunchesUsingGET.');
            }
            const localVarPath = `/v1/{projectName}/launch`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filterEqAttributeKey !== undefined) {
                localVarQueryParameter['filter.eq.attributeKey'] = filterEqAttributeKey;
            }

            if (filterEqAttributeValue !== undefined) {
                localVarQueryParameter['filter.eq.attributeValue'] = filterEqAttributeValue;
            }

            if (filterEqCompositeAttribute) {
                localVarQueryParameter['filter.eq.compositeAttribute'] = filterEqCompositeAttribute;
            }

            if (filterEqDescription !== undefined) {
                localVarQueryParameter['filter.eq.description'] = filterEqDescription;
            }

            if (filterEqEndTime !== undefined) {
                localVarQueryParameter['filter.eq.endTime'] = (filterEqEndTime as any).toISOString();
            }

            if (filterEqHasRetries !== undefined) {
                localVarQueryParameter['filter.eq.hasRetries'] = filterEqHasRetries;
            }

            if (filterEqId !== undefined) {
                localVarQueryParameter['filter.eq.id'] = filterEqId;
            }

            if (filterEqLastModified !== undefined) {
                localVarQueryParameter['filter.eq.lastModified'] = (filterEqLastModified as any).toISOString();
            }

            if (filterEqMode !== undefined) {
                localVarQueryParameter['filter.eq.mode'] = filterEqMode;
            }

            if (filterEqName !== undefined) {
                localVarQueryParameter['filter.eq.name'] = filterEqName;
            }

            if (filterEqNumber !== undefined) {
                localVarQueryParameter['filter.eq.number'] = filterEqNumber;
            }

            if (filterEqProjectId !== undefined) {
                localVarQueryParameter['filter.eq.projectId'] = filterEqProjectId;
            }

            if (filterEqStartTime !== undefined) {
                localVarQueryParameter['filter.eq.startTime'] = (filterEqStartTime as any).toISOString();
            }

            if (filterEqStatisticsdefectsautomationBugab001 !== undefined) {
                localVarQueryParameter['filter.eq.statistics$defects$automation_bug$ab001'] = filterEqStatisticsdefectsautomationBugab001;
            }

            if (filterEqStatisticsdefectsnoDefectnd001 !== undefined) {
                localVarQueryParameter['filter.eq.statistics$defects$no_defect$nd001'] = filterEqStatisticsdefectsnoDefectnd001;
            }

            if (filterEqStatisticsdefectsproductBugpb001 !== undefined) {
                localVarQueryParameter['filter.eq.statistics$defects$product_bug$pb001'] = filterEqStatisticsdefectsproductBugpb001;
            }

            if (filterEqStatisticsdefectssystemIssuesi001 !== undefined) {
                localVarQueryParameter['filter.eq.statistics$defects$system_issue$si001'] = filterEqStatisticsdefectssystemIssuesi001;
            }

            if (filterEqStatisticsdefectstoInvestigateti001 !== undefined) {
                localVarQueryParameter['filter.eq.statistics$defects$to_investigate$ti001'] = filterEqStatisticsdefectstoInvestigateti001;
            }

            if (filterEqStatisticsexecutionsfailed !== undefined) {
                localVarQueryParameter['filter.eq.statistics$executions$failed'] = filterEqStatisticsexecutionsfailed;
            }

            if (filterEqStatisticsexecutionspassed !== undefined) {
                localVarQueryParameter['filter.eq.statistics$executions$passed'] = filterEqStatisticsexecutionspassed;
            }

            if (filterEqStatisticsexecutionsskipped !== undefined) {
                localVarQueryParameter['filter.eq.statistics$executions$skipped'] = filterEqStatisticsexecutionsskipped;
            }

            if (filterEqStatisticsexecutionstotal !== undefined) {
                localVarQueryParameter['filter.eq.statistics$executions$total'] = filterEqStatisticsexecutionstotal;
            }

            if (filterEqStatus !== undefined) {
                localVarQueryParameter['filter.eq.status'] = filterEqStatus;
            }

            if (filterEqUser !== undefined) {
                localVarQueryParameter['filter.eq.user'] = filterEqUser;
            }

            if (filterEqUserId !== undefined) {
                localVarQueryParameter['filter.eq.userId'] = filterEqUserId;
            }

            if (filterEqUuid !== undefined) {
                localVarQueryParameter['filter.eq.uuid'] = filterEqUuid;
            }

            if (pagePage !== undefined) {
                localVarQueryParameter['page.page'] = pagePage;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page.size'] = pageSize;
            }

            if (pageSort) {
                localVarQueryParameter['page.sort'] = pageSort;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary getStatuses
         * @param {Array<number>} ids ids
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusesUsingGET(ids: Array<number>, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'ids' is not null or undefined
            if (ids === null || ids === undefined) {
                throw new RequiredError('ids', 'Required parameter ids was null or undefined when calling getStatusesUsingGET.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getStatusesUsingGET.');
            }
            const localVarPath = `/v1/{projectName}/launch/status`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only following formats are supported: zip and xml.
         * @summary Import junit xml report
         * @param {any} file file
         * @param {string} projectName projectName
         * @param {LaunchImportRQ} [launchImportRq]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importLaunchUsingPOST(file: any, projectName: string, launchImportRq?: LaunchImportRQ, options: any = {}): FetchArgs {
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file', 'Required parameter file was null or undefined when calling importLaunchUsingPOST.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling importLaunchUsingPOST.');
            }
            const localVarPath = `/v1/{projectName}/launch/import`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();
            const needsSerialization = (<any>"LaunchImportRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(launchImportRq || {}) : (launchImportRq || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Merge set of specified launches in common one
         * @param {MergeLaunchesRQ} mergeLaunchesRQ Merge launches request body
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeLaunchesUsingPOST1(mergeLaunchesRQ: MergeLaunchesRQ, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'mergeLaunchesRQ' is not null or undefined
            if (mergeLaunchesRQ === null || mergeLaunchesRQ === undefined) {
                throw new RequiredError('mergeLaunchesRQ', 'Required parameter mergeLaunchesRQ was null or undefined when calling mergeLaunchesUsingPOST1.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling mergeLaunchesUsingPOST1.');
            }
            const localVarPath = `/v1/{projectName}/launch/merge`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MergeLaunchesRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(mergeLaunchesRQ || {}) : (mergeLaunchesRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Start launch auto-analyzer on demand
         * @param {AnalyzeLaunchRQ} analyzeLaunchRQ analyzeLaunchRQ
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startLaunchAnalyzerUsingPOST(analyzeLaunchRQ: AnalyzeLaunchRQ, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'analyzeLaunchRQ' is not null or undefined
            if (analyzeLaunchRQ === null || analyzeLaunchRQ === undefined) {
                throw new RequiredError('analyzeLaunchRQ', 'Required parameter analyzeLaunchRQ was null or undefined when calling startLaunchAnalyzerUsingPOST.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling startLaunchAnalyzerUsingPOST.');
            }
            const localVarPath = `/v1/{projectName}/launch/analyze`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AnalyzeLaunchRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(analyzeLaunchRQ || {}) : (analyzeLaunchRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Starts launch for specified project
         * @param {string} projectName projectName
         * @param {StartLaunchRQ} startLaunchRQ Start launch request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startLaunchUsingPOST1(projectName: string, startLaunchRQ: StartLaunchRQ, options: any = {}): FetchArgs {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling startLaunchUsingPOST1.');
            }
            // verify required parameter 'startLaunchRQ' is not null or undefined
            if (startLaunchRQ === null || startLaunchRQ === undefined) {
                throw new RequiredError('startLaunchRQ', 'Required parameter startLaunchRQ was null or undefined when calling startLaunchUsingPOST1.');
            }
            const localVarPath = `/v1/{projectName}/launch`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"StartLaunchRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(startLaunchRQ || {}) : (startLaunchRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Updates launch for specified project
         * @param {number} launchId launchId
         * @param {string} projectName projectName
         * @param {UpdateLaunchRQ} updateLaunchRQ updateLaunchRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLaunchUsingPUT(launchId: number, projectName: string, updateLaunchRQ: UpdateLaunchRQ, options: any = {}): FetchArgs {
            // verify required parameter 'launchId' is not null or undefined
            if (launchId === null || launchId === undefined) {
                throw new RequiredError('launchId', 'Required parameter launchId was null or undefined when calling updateLaunchUsingPUT.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling updateLaunchUsingPUT.');
            }
            // verify required parameter 'updateLaunchRQ' is not null or undefined
            if (updateLaunchRQ === null || updateLaunchRQ === undefined) {
                throw new RequiredError('updateLaunchRQ', 'Required parameter updateLaunchRQ was null or undefined when calling updateLaunchUsingPUT.');
            }
            const localVarPath = `/v1/{projectName}/launch/{launchId}/update`
                .replace(`{${"launchId"}}`, encodeURIComponent(String(launchId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'PUT'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateLaunchRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(updateLaunchRQ || {}) : (updateLaunchRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Updates launches for specified project
         * @param {string} projectName projectName
         * @param {BulkRQlongUpdateLaunchRQ} rq rq
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLaunchesUsingPUT(projectName: string, rq: BulkRQlongUpdateLaunchRQ, options: any = {}): FetchArgs {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling updateLaunchesUsingPUT.');
            }
            // verify required parameter 'rq' is not null or undefined
            if (rq === null || rq === undefined) {
                throw new RequiredError('rq', 'Required parameter rq was null or undefined when calling updateLaunchesUsingPUT.');
            }
            const localVarPath = `/v1/{projectName}/launch/update`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'PUT'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BulkRQlongUpdateLaunchRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(rq || {}) : (rq || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LaunchControllerApi - functional programming interface
 * @export
 */
export const LaunchControllerApiFp = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Force finish launch
         * @param {string} projectName projectName
         * @param {BulkRQlongFinishExecutionRQ} rq rq
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkForceFinishUsingPUT(projectName: string, rq: BulkRQlongFinishExecutionRQ, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<OperationCompletionRS>> {
            const localVarFetchArgs = LaunchControllerApiFetchParamCreator(configuration).bulkForceFinishUsingPUT(projectName, rq, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Bulk update attributes and description
         * @param {BulkInfoUpdateRQ} bulkInfoUpdateRQ bulkInfoUpdateRQ
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateUsingPUT(bulkInfoUpdateRQ: BulkInfoUpdateRQ, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = LaunchControllerApiFetchParamCreator(configuration).bulkUpdateUsingPUT(bulkInfoUpdateRQ, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Compare launches
         * @param {Array<number>} ids ids
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compareLaunchesUsingGET(ids: Array<number>, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{
            [key: string]: Array<ChartStatisticsContent>;
        }> {
            const localVarFetchArgs = LaunchControllerApiFetchParamCreator(configuration).compareLaunchesUsingGET(ids, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create launch clusters
         * @param {CreateClustersRQ} createClustersRQ createClustersRQ
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClustersUsingPOST(createClustersRQ: CreateClustersRQ, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = LaunchControllerApiFetchParamCreator(configuration).createClustersUsingPOST(createClustersRQ, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete specified launch by ID
         * @param {number} launchId launchId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLaunchUsingDELETE(launchId: number, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = LaunchControllerApiFetchParamCreator(configuration).deleteLaunchUsingDELETE(launchId, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete specified launches by ids
         * @param {DeleteBulkRQ} deleteBulkRQ deleteBulkRQ
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLaunchesUsingDELETE(deleteBulkRQ: DeleteBulkRQ, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteBulkRS> {
            const localVarFetchArgs = LaunchControllerApiFetchParamCreator(configuration).deleteLaunchesUsingDELETE(deleteBulkRQ, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Finish launch for specified project
         * @param {FinishExecutionRQ} finishLaunchRQ finishLaunchRQ
         * @param {string} launchId launchId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finishLaunchUsingPUT1(finishLaunchRQ: FinishExecutionRQ, launchId: string, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FinishLaunchRS> {
            const localVarFetchArgs = LaunchControllerApiFetchParamCreator(configuration).finishLaunchUsingPUT1(finishLaunchRQ, launchId, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Force finish launch for specified project
         * @param {FinishExecutionRQ} finishExecutionRQ finishExecutionRQ
         * @param {number} launchId launchId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forceFinishLaunchUsingPUT(finishExecutionRQ: FinishExecutionRQ, launchId: number, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = LaunchControllerApiFetchParamCreator(configuration).forceFinishLaunchUsingPUT(finishExecutionRQ, launchId, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get launch names of project
         * @param {string} projectName projectName
         * @param {string} [filterCntName] filter.cnt.name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllLaunchNamesUsingGET(projectName: string, filterCntName?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = LaunchControllerApiFetchParamCreator(configuration).getAllLaunchNamesUsingGET(projectName, filterCntName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all unique owners of project launches
         * @param {string} filterCntUser filter.cnt.user
         * @param {string} projectName projectName
         * @param {string} [mode] mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOwnersUsingGET(filterCntUser: string, projectName: string, mode?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = LaunchControllerApiFetchParamCreator(configuration).getAllOwnersUsingGET(filterCntUser, projectName, mode, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all unique attribute keys of project launches
         * @param {string} filterCntAttributeKey filter.cnt.attributeKey
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributeKeysUsingGET(filterCntAttributeKey: string, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = LaunchControllerApiFetchParamCreator(configuration).getAttributeKeysUsingGET(filterCntAttributeKey, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all unique attribute values of project launches
         * @param {string} filterCntAttributeValue filter.cnt.attributeValue
         * @param {string} projectName projectName
         * @param {string} [filterEqAttributeKey] filter.eq.attributeKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributeValuesUsingGET(filterCntAttributeValue: string, projectName: string, filterEqAttributeKey?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = LaunchControllerApiFetchParamCreator(configuration).getAttributeValuesUsingGET(filterCntAttributeValue, projectName, filterEqAttributeKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all index clusters of the launch
         * @param {string} launchId launchId
         * @param {string} projectName projectName
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClustersUsingGET(launchId: string, projectName: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<IterableClusterInfoResource> {
            const localVarFetchArgs = LaunchControllerApiFetchParamCreator(configuration).getClustersUsingGET(launchId, projectName, pagePage, pageSize, pageSort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get launches of specified project from DEBUG mode
         * @param {string} projectName projectName
         * @param {string} [filterEqAttributeKey] Filters by &#39;attributeKey&#39;
         * @param {string} [filterEqAttributeValue] Filters by &#39;attributeValue&#39;
         * @param {Array<string>} [filterEqCompositeAttribute] Filters by &#39;compositeAttribute&#39;
         * @param {string} [filterEqDescription] Filters by &#39;description&#39;
         * @param {Date} [filterEqEndTime] Filters by &#39;endTime&#39;
         * @param {boolean} [filterEqHasRetries] Filters by &#39;hasRetries&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {Date} [filterEqLastModified] Filters by &#39;lastModified&#39;
         * @param {string} [filterEqMode] Filters by &#39;mode&#39;
         * @param {string} [filterEqName] Filters by &#39;name&#39;
         * @param {number} [filterEqNumber] Filters by &#39;number&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {Date} [filterEqStartTime] Filters by &#39;startTime&#39;
         * @param {number} [filterEqStatisticsdefectsautomationBugab001] Filters by &#39;statistics$defects$automation_bug$ab001&#39;
         * @param {number} [filterEqStatisticsdefectsnoDefectnd001] Filters by &#39;statistics$defects$no_defect$nd001&#39;
         * @param {number} [filterEqStatisticsdefectsproductBugpb001] Filters by &#39;statistics$defects$product_bug$pb001&#39;
         * @param {number} [filterEqStatisticsdefectssystemIssuesi001] Filters by &#39;statistics$defects$system_issue$si001&#39;
         * @param {number} [filterEqStatisticsdefectstoInvestigateti001] Filters by &#39;statistics$defects$to_investigate$ti001&#39;
         * @param {number} [filterEqStatisticsexecutionsfailed] Filters by &#39;statistics$executions$failed&#39;
         * @param {number} [filterEqStatisticsexecutionspassed] Filters by &#39;statistics$executions$passed&#39;
         * @param {number} [filterEqStatisticsexecutionsskipped] Filters by &#39;statistics$executions$skipped&#39;
         * @param {number} [filterEqStatisticsexecutionstotal] Filters by &#39;statistics$executions$total&#39;
         * @param {string} [filterEqStatus] Filters by &#39;status&#39;
         * @param {string} [filterEqUser] Filters by &#39;user&#39;
         * @param {number} [filterEqUserId] Filters by &#39;userId&#39;
         * @param {string} [filterEqUuid] Filters by &#39;uuid&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDebugLaunchesUsingGET(projectName: string, filterEqAttributeKey?: string, filterEqAttributeValue?: string, filterEqCompositeAttribute?: Array<string>, filterEqDescription?: string, filterEqEndTime?: Date, filterEqHasRetries?: boolean, filterEqId?: number, filterEqLastModified?: Date, filterEqMode?: string, filterEqName?: string, filterEqNumber?: number, filterEqProjectId?: number, filterEqStartTime?: Date, filterEqStatisticsdefectsautomationBugab001?: number, filterEqStatisticsdefectsnoDefectnd001?: number, filterEqStatisticsdefectsproductBugpb001?: number, filterEqStatisticsdefectssystemIssuesi001?: number, filterEqStatisticsdefectstoInvestigateti001?: number, filterEqStatisticsexecutionsfailed?: number, filterEqStatisticsexecutionspassed?: number, filterEqStatisticsexecutionsskipped?: number, filterEqStatisticsexecutionstotal?: number, filterEqStatus?: string, filterEqUser?: string, filterEqUserId?: number, filterEqUuid?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<IterableLaunchResource> {
            const localVarFetchArgs = LaunchControllerApiFetchParamCreator(configuration).getDebugLaunchesUsingGET(projectName, filterEqAttributeKey, filterEqAttributeValue, filterEqCompositeAttribute, filterEqDescription, filterEqEndTime, filterEqHasRetries, filterEqId, filterEqLastModified, filterEqMode, filterEqName, filterEqNumber, filterEqProjectId, filterEqStartTime, filterEqStatisticsdefectsautomationBugab001, filterEqStatisticsdefectsnoDefectnd001, filterEqStatisticsdefectsproductBugpb001, filterEqStatisticsdefectssystemIssuesi001, filterEqStatisticsdefectstoInvestigateti001, filterEqStatisticsexecutionsfailed, filterEqStatisticsexecutionspassed, filterEqStatisticsexecutionsskipped, filterEqStatisticsexecutionstotal, filterEqStatus, filterEqUser, filterEqUserId, filterEqUuid, pagePage, pageSize, pageSort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get list of latest project launches by filter
         * @param {string} projectName projectName
         * @param {string} [filterEqAttributeKey] Filters by &#39;attributeKey&#39;
         * @param {string} [filterEqAttributeValue] Filters by &#39;attributeValue&#39;
         * @param {Array<string>} [filterEqCompositeAttribute] Filters by &#39;compositeAttribute&#39;
         * @param {string} [filterEqDescription] Filters by &#39;description&#39;
         * @param {Date} [filterEqEndTime] Filters by &#39;endTime&#39;
         * @param {boolean} [filterEqHasRetries] Filters by &#39;hasRetries&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {Date} [filterEqLastModified] Filters by &#39;lastModified&#39;
         * @param {string} [filterEqMode] Filters by &#39;mode&#39;
         * @param {string} [filterEqName] Filters by &#39;name&#39;
         * @param {number} [filterEqNumber] Filters by &#39;number&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {Date} [filterEqStartTime] Filters by &#39;startTime&#39;
         * @param {number} [filterEqStatisticsdefectsautomationBugab001] Filters by &#39;statistics$defects$automation_bug$ab001&#39;
         * @param {number} [filterEqStatisticsdefectsnoDefectnd001] Filters by &#39;statistics$defects$no_defect$nd001&#39;
         * @param {number} [filterEqStatisticsdefectsproductBugpb001] Filters by &#39;statistics$defects$product_bug$pb001&#39;
         * @param {number} [filterEqStatisticsdefectssystemIssuesi001] Filters by &#39;statistics$defects$system_issue$si001&#39;
         * @param {number} [filterEqStatisticsdefectstoInvestigateti001] Filters by &#39;statistics$defects$to_investigate$ti001&#39;
         * @param {number} [filterEqStatisticsexecutionsfailed] Filters by &#39;statistics$executions$failed&#39;
         * @param {number} [filterEqStatisticsexecutionspassed] Filters by &#39;statistics$executions$passed&#39;
         * @param {number} [filterEqStatisticsexecutionsskipped] Filters by &#39;statistics$executions$skipped&#39;
         * @param {number} [filterEqStatisticsexecutionstotal] Filters by &#39;statistics$executions$total&#39;
         * @param {string} [filterEqStatus] Filters by &#39;status&#39;
         * @param {string} [filterEqUser] Filters by &#39;user&#39;
         * @param {number} [filterEqUserId] Filters by &#39;userId&#39;
         * @param {string} [filterEqUuid] Filters by &#39;uuid&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestLaunchesUsingGET(projectName: string, filterEqAttributeKey?: string, filterEqAttributeValue?: string, filterEqCompositeAttribute?: Array<string>, filterEqDescription?: string, filterEqEndTime?: Date, filterEqHasRetries?: boolean, filterEqId?: number, filterEqLastModified?: Date, filterEqMode?: string, filterEqName?: string, filterEqNumber?: number, filterEqProjectId?: number, filterEqStartTime?: Date, filterEqStatisticsdefectsautomationBugab001?: number, filterEqStatisticsdefectsnoDefectnd001?: number, filterEqStatisticsdefectsproductBugpb001?: number, filterEqStatisticsdefectssystemIssuesi001?: number, filterEqStatisticsdefectstoInvestigateti001?: number, filterEqStatisticsexecutionsfailed?: number, filterEqStatisticsexecutionspassed?: number, filterEqStatisticsexecutionsskipped?: number, filterEqStatisticsexecutionstotal?: number, filterEqStatus?: string, filterEqUser?: string, filterEqUserId?: number, filterEqUuid?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<IterableLaunchResource> {
            const localVarFetchArgs = LaunchControllerApiFetchParamCreator(configuration).getLatestLaunchesUsingGET(projectName, filterEqAttributeKey, filterEqAttributeValue, filterEqCompositeAttribute, filterEqDescription, filterEqEndTime, filterEqHasRetries, filterEqId, filterEqLastModified, filterEqMode, filterEqName, filterEqNumber, filterEqProjectId, filterEqStartTime, filterEqStatisticsdefectsautomationBugab001, filterEqStatisticsdefectsnoDefectnd001, filterEqStatisticsdefectsproductBugpb001, filterEqStatisticsdefectssystemIssuesi001, filterEqStatisticsdefectstoInvestigateti001, filterEqStatisticsexecutionsfailed, filterEqStatisticsexecutionspassed, filterEqStatisticsexecutionsskipped, filterEqStatisticsexecutionstotal, filterEqStatus, filterEqUser, filterEqUserId, filterEqUuid, pagePage, pageSize, pageSort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get specified launch by UUID
         * @param {string} launchId launchId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLaunchByUuidUsingGET(launchId: string, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LaunchResource> {
            const localVarFetchArgs = LaunchControllerApiFetchParamCreator(configuration).getLaunchByUuidUsingGET(launchId, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Only following formats are supported: pdf (by default), xls, html.
         * @summary Export specified launch
         * @param {number} launchId launchId
         * @param {string} projectName projectName
         * @param {'pdf' | 'xls' | 'html'} [view] view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLaunchReportUsingGET(launchId: number, projectName: string, view?: 'pdf' | 'xls' | 'html', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = LaunchControllerApiFetchParamCreator(configuration).getLaunchReportUsingGET(launchId, projectName, view, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get specified launch by ID
         * @param {string} launchId launchId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLaunchUsingGET(launchId: string, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LaunchResource> {
            const localVarFetchArgs = LaunchControllerApiFetchParamCreator(configuration).getLaunchUsingGET(launchId, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get list of project launches by filter
         * @param {string} projectName projectName
         * @param {string} [filterEqAttributeKey] Filters by &#39;attributeKey&#39;
         * @param {string} [filterEqAttributeValue] Filters by &#39;attributeValue&#39;
         * @param {Array<string>} [filterEqCompositeAttribute] Filters by &#39;compositeAttribute&#39;
         * @param {string} [filterEqDescription] Filters by &#39;description&#39;
         * @param {Date} [filterEqEndTime] Filters by &#39;endTime&#39;
         * @param {boolean} [filterEqHasRetries] Filters by &#39;hasRetries&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {Date} [filterEqLastModified] Filters by &#39;lastModified&#39;
         * @param {string} [filterEqMode] Filters by &#39;mode&#39;
         * @param {string} [filterEqName] Filters by &#39;name&#39;
         * @param {number} [filterEqNumber] Filters by &#39;number&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {Date} [filterEqStartTime] Filters by &#39;startTime&#39;
         * @param {number} [filterEqStatisticsdefectsautomationBugab001] Filters by &#39;statistics$defects$automation_bug$ab001&#39;
         * @param {number} [filterEqStatisticsdefectsnoDefectnd001] Filters by &#39;statistics$defects$no_defect$nd001&#39;
         * @param {number} [filterEqStatisticsdefectsproductBugpb001] Filters by &#39;statistics$defects$product_bug$pb001&#39;
         * @param {number} [filterEqStatisticsdefectssystemIssuesi001] Filters by &#39;statistics$defects$system_issue$si001&#39;
         * @param {number} [filterEqStatisticsdefectstoInvestigateti001] Filters by &#39;statistics$defects$to_investigate$ti001&#39;
         * @param {number} [filterEqStatisticsexecutionsfailed] Filters by &#39;statistics$executions$failed&#39;
         * @param {number} [filterEqStatisticsexecutionspassed] Filters by &#39;statistics$executions$passed&#39;
         * @param {number} [filterEqStatisticsexecutionsskipped] Filters by &#39;statistics$executions$skipped&#39;
         * @param {number} [filterEqStatisticsexecutionstotal] Filters by &#39;statistics$executions$total&#39;
         * @param {string} [filterEqStatus] Filters by &#39;status&#39;
         * @param {string} [filterEqUser] Filters by &#39;user&#39;
         * @param {number} [filterEqUserId] Filters by &#39;userId&#39;
         * @param {string} [filterEqUuid] Filters by &#39;uuid&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectLaunchesUsingGET(projectName: string, filterEqAttributeKey?: string, filterEqAttributeValue?: string, filterEqCompositeAttribute?: Array<string>, filterEqDescription?: string, filterEqEndTime?: Date, filterEqHasRetries?: boolean, filterEqId?: number, filterEqLastModified?: Date, filterEqMode?: string, filterEqName?: string, filterEqNumber?: number, filterEqProjectId?: number, filterEqStartTime?: Date, filterEqStatisticsdefectsautomationBugab001?: number, filterEqStatisticsdefectsnoDefectnd001?: number, filterEqStatisticsdefectsproductBugpb001?: number, filterEqStatisticsdefectssystemIssuesi001?: number, filterEqStatisticsdefectstoInvestigateti001?: number, filterEqStatisticsexecutionsfailed?: number, filterEqStatisticsexecutionspassed?: number, filterEqStatisticsexecutionsskipped?: number, filterEqStatisticsexecutionstotal?: number, filterEqStatus?: string, filterEqUser?: string, filterEqUserId?: number, filterEqUuid?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<IterableLaunchResource> {
            const localVarFetchArgs = LaunchControllerApiFetchParamCreator(configuration).getProjectLaunchesUsingGET(projectName, filterEqAttributeKey, filterEqAttributeValue, filterEqCompositeAttribute, filterEqDescription, filterEqEndTime, filterEqHasRetries, filterEqId, filterEqLastModified, filterEqMode, filterEqName, filterEqNumber, filterEqProjectId, filterEqStartTime, filterEqStatisticsdefectsautomationBugab001, filterEqStatisticsdefectsnoDefectnd001, filterEqStatisticsdefectsproductBugpb001, filterEqStatisticsdefectssystemIssuesi001, filterEqStatisticsdefectstoInvestigateti001, filterEqStatisticsexecutionsfailed, filterEqStatisticsexecutionspassed, filterEqStatisticsexecutionsskipped, filterEqStatisticsexecutionstotal, filterEqStatus, filterEqUser, filterEqUserId, filterEqUuid, pagePage, pageSize, pageSort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary getStatuses
         * @param {Array<number>} ids ids
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusesUsingGET(ids: Array<number>, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{
            [key: string]: string;
        }> {
            const localVarFetchArgs = LaunchControllerApiFetchParamCreator(configuration).getStatusesUsingGET(ids, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Only following formats are supported: zip and xml.
         * @summary Import junit xml report
         * @param {any} file file
         * @param {string} projectName projectName
         * @param {LaunchImportRQ} [launchImportRq]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importLaunchUsingPOST(file: any, projectName: string, launchImportRq?: LaunchImportRQ, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = LaunchControllerApiFetchParamCreator(configuration).importLaunchUsingPOST(file, projectName, launchImportRq, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Merge set of specified launches in common one
         * @param {MergeLaunchesRQ} mergeLaunchesRQ Merge launches request body
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeLaunchesUsingPOST1(mergeLaunchesRQ: MergeLaunchesRQ, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LaunchResource> {
            const localVarFetchArgs = LaunchControllerApiFetchParamCreator(configuration).mergeLaunchesUsingPOST1(mergeLaunchesRQ, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Start launch auto-analyzer on demand
         * @param {AnalyzeLaunchRQ} analyzeLaunchRQ analyzeLaunchRQ
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startLaunchAnalyzerUsingPOST(analyzeLaunchRQ: AnalyzeLaunchRQ, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = LaunchControllerApiFetchParamCreator(configuration).startLaunchAnalyzerUsingPOST(analyzeLaunchRQ, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Starts launch for specified project
         * @param {string} projectName projectName
         * @param {StartLaunchRQ} startLaunchRQ Start launch request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startLaunchUsingPOST1(projectName: string, startLaunchRQ: StartLaunchRQ, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StartLaunchRS> {
            const localVarFetchArgs = LaunchControllerApiFetchParamCreator(configuration).startLaunchUsingPOST1(projectName, startLaunchRQ, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Updates launch for specified project
         * @param {number} launchId launchId
         * @param {string} projectName projectName
         * @param {UpdateLaunchRQ} updateLaunchRQ updateLaunchRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLaunchUsingPUT(launchId: number, projectName: string, updateLaunchRQ: UpdateLaunchRQ, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = LaunchControllerApiFetchParamCreator(configuration).updateLaunchUsingPUT(launchId, projectName, updateLaunchRQ, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Updates launches for specified project
         * @param {string} projectName projectName
         * @param {BulkRQlongUpdateLaunchRQ} rq rq
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLaunchesUsingPUT(projectName: string, rq: BulkRQlongUpdateLaunchRQ, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<OperationCompletionRS>> {
            const localVarFetchArgs = LaunchControllerApiFetchParamCreator(configuration).updateLaunchesUsingPUT(projectName, rq, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LaunchControllerApi - factory interface
 * @export
 */
export const LaunchControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Force finish launch
         * @param {string} projectName projectName
         * @param {BulkRQlongFinishExecutionRQ} rq rq
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkForceFinishUsingPUT(projectName: string, rq: BulkRQlongFinishExecutionRQ, options?: any) {
            return LaunchControllerApiFp(configuration).bulkForceFinishUsingPUT(projectName, rq, options)(fetch, basePath);
        },
        /**
         *
         * @summary Bulk update attributes and description
         * @param {BulkInfoUpdateRQ} bulkInfoUpdateRQ bulkInfoUpdateRQ
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateUsingPUT(bulkInfoUpdateRQ: BulkInfoUpdateRQ, projectName: string, options?: any) {
            return LaunchControllerApiFp(configuration).bulkUpdateUsingPUT(bulkInfoUpdateRQ, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Compare launches
         * @param {Array<number>} ids ids
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compareLaunchesUsingGET(ids: Array<number>, projectName: string, options?: any) {
            return LaunchControllerApiFp(configuration).compareLaunchesUsingGET(ids, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create launch clusters
         * @param {CreateClustersRQ} createClustersRQ createClustersRQ
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClustersUsingPOST(createClustersRQ: CreateClustersRQ, projectName: string, options?: any) {
            return LaunchControllerApiFp(configuration).createClustersUsingPOST(createClustersRQ, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete specified launch by ID
         * @param {number} launchId launchId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLaunchUsingDELETE(launchId: number, projectName: string, options?: any) {
            return LaunchControllerApiFp(configuration).deleteLaunchUsingDELETE(launchId, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete specified launches by ids
         * @param {DeleteBulkRQ} deleteBulkRQ deleteBulkRQ
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLaunchesUsingDELETE(deleteBulkRQ: DeleteBulkRQ, projectName: string, options?: any) {
            return LaunchControllerApiFp(configuration).deleteLaunchesUsingDELETE(deleteBulkRQ, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Finish launch for specified project
         * @param {FinishExecutionRQ} finishLaunchRQ finishLaunchRQ
         * @param {string} launchId launchId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finishLaunchUsingPUT1(finishLaunchRQ: FinishExecutionRQ, launchId: string, projectName: string, options?: any) {
            return LaunchControllerApiFp(configuration).finishLaunchUsingPUT1(finishLaunchRQ, launchId, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Force finish launch for specified project
         * @param {FinishExecutionRQ} finishExecutionRQ finishExecutionRQ
         * @param {number} launchId launchId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forceFinishLaunchUsingPUT(finishExecutionRQ: FinishExecutionRQ, launchId: number, projectName: string, options?: any) {
            return LaunchControllerApiFp(configuration).forceFinishLaunchUsingPUT(finishExecutionRQ, launchId, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get launch names of project
         * @param {string} projectName projectName
         * @param {string} [filterCntName] filter.cnt.name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllLaunchNamesUsingGET(projectName: string, filterCntName?: string, options?: any) {
            return LaunchControllerApiFp(configuration).getAllLaunchNamesUsingGET(projectName, filterCntName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get all unique owners of project launches
         * @param {string} filterCntUser filter.cnt.user
         * @param {string} projectName projectName
         * @param {string} [mode] mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOwnersUsingGET(filterCntUser: string, projectName: string, mode?: string, options?: any) {
            return LaunchControllerApiFp(configuration).getAllOwnersUsingGET(filterCntUser, projectName, mode, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get all unique attribute keys of project launches
         * @param {string} filterCntAttributeKey filter.cnt.attributeKey
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributeKeysUsingGET(filterCntAttributeKey: string, projectName: string, options?: any) {
            return LaunchControllerApiFp(configuration).getAttributeKeysUsingGET(filterCntAttributeKey, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get all unique attribute values of project launches
         * @param {string} filterCntAttributeValue filter.cnt.attributeValue
         * @param {string} projectName projectName
         * @param {string} [filterEqAttributeKey] filter.eq.attributeKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributeValuesUsingGET(filterCntAttributeValue: string, projectName: string, filterEqAttributeKey?: string, options?: any) {
            return LaunchControllerApiFp(configuration).getAttributeValuesUsingGET(filterCntAttributeValue, projectName, filterEqAttributeKey, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get all index clusters of the launch
         * @param {string} launchId launchId
         * @param {string} projectName projectName
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClustersUsingGET(launchId: string, projectName: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any) {
            return LaunchControllerApiFp(configuration).getClustersUsingGET(launchId, projectName, pagePage, pageSize, pageSort, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get launches of specified project from DEBUG mode
         * @param {string} projectName projectName
         * @param {string} [filterEqAttributeKey] Filters by &#39;attributeKey&#39;
         * @param {string} [filterEqAttributeValue] Filters by &#39;attributeValue&#39;
         * @param {Array<string>} [filterEqCompositeAttribute] Filters by &#39;compositeAttribute&#39;
         * @param {string} [filterEqDescription] Filters by &#39;description&#39;
         * @param {Date} [filterEqEndTime] Filters by &#39;endTime&#39;
         * @param {boolean} [filterEqHasRetries] Filters by &#39;hasRetries&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {Date} [filterEqLastModified] Filters by &#39;lastModified&#39;
         * @param {string} [filterEqMode] Filters by &#39;mode&#39;
         * @param {string} [filterEqName] Filters by &#39;name&#39;
         * @param {number} [filterEqNumber] Filters by &#39;number&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {Date} [filterEqStartTime] Filters by &#39;startTime&#39;
         * @param {number} [filterEqStatisticsdefectsautomationBugab001] Filters by &#39;statistics$defects$automation_bug$ab001&#39;
         * @param {number} [filterEqStatisticsdefectsnoDefectnd001] Filters by &#39;statistics$defects$no_defect$nd001&#39;
         * @param {number} [filterEqStatisticsdefectsproductBugpb001] Filters by &#39;statistics$defects$product_bug$pb001&#39;
         * @param {number} [filterEqStatisticsdefectssystemIssuesi001] Filters by &#39;statistics$defects$system_issue$si001&#39;
         * @param {number} [filterEqStatisticsdefectstoInvestigateti001] Filters by &#39;statistics$defects$to_investigate$ti001&#39;
         * @param {number} [filterEqStatisticsexecutionsfailed] Filters by &#39;statistics$executions$failed&#39;
         * @param {number} [filterEqStatisticsexecutionspassed] Filters by &#39;statistics$executions$passed&#39;
         * @param {number} [filterEqStatisticsexecutionsskipped] Filters by &#39;statistics$executions$skipped&#39;
         * @param {number} [filterEqStatisticsexecutionstotal] Filters by &#39;statistics$executions$total&#39;
         * @param {string} [filterEqStatus] Filters by &#39;status&#39;
         * @param {string} [filterEqUser] Filters by &#39;user&#39;
         * @param {number} [filterEqUserId] Filters by &#39;userId&#39;
         * @param {string} [filterEqUuid] Filters by &#39;uuid&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDebugLaunchesUsingGET(projectName: string, filterEqAttributeKey?: string, filterEqAttributeValue?: string, filterEqCompositeAttribute?: Array<string>, filterEqDescription?: string, filterEqEndTime?: Date, filterEqHasRetries?: boolean, filterEqId?: number, filterEqLastModified?: Date, filterEqMode?: string, filterEqName?: string, filterEqNumber?: number, filterEqProjectId?: number, filterEqStartTime?: Date, filterEqStatisticsdefectsautomationBugab001?: number, filterEqStatisticsdefectsnoDefectnd001?: number, filterEqStatisticsdefectsproductBugpb001?: number, filterEqStatisticsdefectssystemIssuesi001?: number, filterEqStatisticsdefectstoInvestigateti001?: number, filterEqStatisticsexecutionsfailed?: number, filterEqStatisticsexecutionspassed?: number, filterEqStatisticsexecutionsskipped?: number, filterEqStatisticsexecutionstotal?: number, filterEqStatus?: string, filterEqUser?: string, filterEqUserId?: number, filterEqUuid?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any) {
            return LaunchControllerApiFp(configuration).getDebugLaunchesUsingGET(projectName, filterEqAttributeKey, filterEqAttributeValue, filterEqCompositeAttribute, filterEqDescription, filterEqEndTime, filterEqHasRetries, filterEqId, filterEqLastModified, filterEqMode, filterEqName, filterEqNumber, filterEqProjectId, filterEqStartTime, filterEqStatisticsdefectsautomationBugab001, filterEqStatisticsdefectsnoDefectnd001, filterEqStatisticsdefectsproductBugpb001, filterEqStatisticsdefectssystemIssuesi001, filterEqStatisticsdefectstoInvestigateti001, filterEqStatisticsexecutionsfailed, filterEqStatisticsexecutionspassed, filterEqStatisticsexecutionsskipped, filterEqStatisticsexecutionstotal, filterEqStatus, filterEqUser, filterEqUserId, filterEqUuid, pagePage, pageSize, pageSort, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get list of latest project launches by filter
         * @param {string} projectName projectName
         * @param {string} [filterEqAttributeKey] Filters by &#39;attributeKey&#39;
         * @param {string} [filterEqAttributeValue] Filters by &#39;attributeValue&#39;
         * @param {Array<string>} [filterEqCompositeAttribute] Filters by &#39;compositeAttribute&#39;
         * @param {string} [filterEqDescription] Filters by &#39;description&#39;
         * @param {Date} [filterEqEndTime] Filters by &#39;endTime&#39;
         * @param {boolean} [filterEqHasRetries] Filters by &#39;hasRetries&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {Date} [filterEqLastModified] Filters by &#39;lastModified&#39;
         * @param {string} [filterEqMode] Filters by &#39;mode&#39;
         * @param {string} [filterEqName] Filters by &#39;name&#39;
         * @param {number} [filterEqNumber] Filters by &#39;number&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {Date} [filterEqStartTime] Filters by &#39;startTime&#39;
         * @param {number} [filterEqStatisticsdefectsautomationBugab001] Filters by &#39;statistics$defects$automation_bug$ab001&#39;
         * @param {number} [filterEqStatisticsdefectsnoDefectnd001] Filters by &#39;statistics$defects$no_defect$nd001&#39;
         * @param {number} [filterEqStatisticsdefectsproductBugpb001] Filters by &#39;statistics$defects$product_bug$pb001&#39;
         * @param {number} [filterEqStatisticsdefectssystemIssuesi001] Filters by &#39;statistics$defects$system_issue$si001&#39;
         * @param {number} [filterEqStatisticsdefectstoInvestigateti001] Filters by &#39;statistics$defects$to_investigate$ti001&#39;
         * @param {number} [filterEqStatisticsexecutionsfailed] Filters by &#39;statistics$executions$failed&#39;
         * @param {number} [filterEqStatisticsexecutionspassed] Filters by &#39;statistics$executions$passed&#39;
         * @param {number} [filterEqStatisticsexecutionsskipped] Filters by &#39;statistics$executions$skipped&#39;
         * @param {number} [filterEqStatisticsexecutionstotal] Filters by &#39;statistics$executions$total&#39;
         * @param {string} [filterEqStatus] Filters by &#39;status&#39;
         * @param {string} [filterEqUser] Filters by &#39;user&#39;
         * @param {number} [filterEqUserId] Filters by &#39;userId&#39;
         * @param {string} [filterEqUuid] Filters by &#39;uuid&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestLaunchesUsingGET(projectName: string, filterEqAttributeKey?: string, filterEqAttributeValue?: string, filterEqCompositeAttribute?: Array<string>, filterEqDescription?: string, filterEqEndTime?: Date, filterEqHasRetries?: boolean, filterEqId?: number, filterEqLastModified?: Date, filterEqMode?: string, filterEqName?: string, filterEqNumber?: number, filterEqProjectId?: number, filterEqStartTime?: Date, filterEqStatisticsdefectsautomationBugab001?: number, filterEqStatisticsdefectsnoDefectnd001?: number, filterEqStatisticsdefectsproductBugpb001?: number, filterEqStatisticsdefectssystemIssuesi001?: number, filterEqStatisticsdefectstoInvestigateti001?: number, filterEqStatisticsexecutionsfailed?: number, filterEqStatisticsexecutionspassed?: number, filterEqStatisticsexecutionsskipped?: number, filterEqStatisticsexecutionstotal?: number, filterEqStatus?: string, filterEqUser?: string, filterEqUserId?: number, filterEqUuid?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any) {
            return LaunchControllerApiFp(configuration).getLatestLaunchesUsingGET(projectName, filterEqAttributeKey, filterEqAttributeValue, filterEqCompositeAttribute, filterEqDescription, filterEqEndTime, filterEqHasRetries, filterEqId, filterEqLastModified, filterEqMode, filterEqName, filterEqNumber, filterEqProjectId, filterEqStartTime, filterEqStatisticsdefectsautomationBugab001, filterEqStatisticsdefectsnoDefectnd001, filterEqStatisticsdefectsproductBugpb001, filterEqStatisticsdefectssystemIssuesi001, filterEqStatisticsdefectstoInvestigateti001, filterEqStatisticsexecutionsfailed, filterEqStatisticsexecutionspassed, filterEqStatisticsexecutionsskipped, filterEqStatisticsexecutionstotal, filterEqStatus, filterEqUser, filterEqUserId, filterEqUuid, pagePage, pageSize, pageSort, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get specified launch by UUID
         * @param {string} launchId launchId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLaunchByUuidUsingGET(launchId: string, projectName: string, options?: any) {
            return LaunchControllerApiFp(configuration).getLaunchByUuidUsingGET(launchId, projectName, options)(fetch, basePath);
        },
        /**
         * Only following formats are supported: pdf (by default), xls, html.
         * @summary Export specified launch
         * @param {number} launchId launchId
         * @param {string} projectName projectName
         * @param {'pdf' | 'xls' | 'html'} [view] view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLaunchReportUsingGET(launchId: number, projectName: string, view?: 'pdf' | 'xls' | 'html', options?: any) {
            return LaunchControllerApiFp(configuration).getLaunchReportUsingGET(launchId, projectName, view, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get specified launch by ID
         * @param {string} launchId launchId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLaunchUsingGET(launchId: string, projectName: string, options?: any) {
            return LaunchControllerApiFp(configuration).getLaunchUsingGET(launchId, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get list of project launches by filter
         * @param {string} projectName projectName
         * @param {string} [filterEqAttributeKey] Filters by &#39;attributeKey&#39;
         * @param {string} [filterEqAttributeValue] Filters by &#39;attributeValue&#39;
         * @param {Array<string>} [filterEqCompositeAttribute] Filters by &#39;compositeAttribute&#39;
         * @param {string} [filterEqDescription] Filters by &#39;description&#39;
         * @param {Date} [filterEqEndTime] Filters by &#39;endTime&#39;
         * @param {boolean} [filterEqHasRetries] Filters by &#39;hasRetries&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {Date} [filterEqLastModified] Filters by &#39;lastModified&#39;
         * @param {string} [filterEqMode] Filters by &#39;mode&#39;
         * @param {string} [filterEqName] Filters by &#39;name&#39;
         * @param {number} [filterEqNumber] Filters by &#39;number&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {Date} [filterEqStartTime] Filters by &#39;startTime&#39;
         * @param {number} [filterEqStatisticsdefectsautomationBugab001] Filters by &#39;statistics$defects$automation_bug$ab001&#39;
         * @param {number} [filterEqStatisticsdefectsnoDefectnd001] Filters by &#39;statistics$defects$no_defect$nd001&#39;
         * @param {number} [filterEqStatisticsdefectsproductBugpb001] Filters by &#39;statistics$defects$product_bug$pb001&#39;
         * @param {number} [filterEqStatisticsdefectssystemIssuesi001] Filters by &#39;statistics$defects$system_issue$si001&#39;
         * @param {number} [filterEqStatisticsdefectstoInvestigateti001] Filters by &#39;statistics$defects$to_investigate$ti001&#39;
         * @param {number} [filterEqStatisticsexecutionsfailed] Filters by &#39;statistics$executions$failed&#39;
         * @param {number} [filterEqStatisticsexecutionspassed] Filters by &#39;statistics$executions$passed&#39;
         * @param {number} [filterEqStatisticsexecutionsskipped] Filters by &#39;statistics$executions$skipped&#39;
         * @param {number} [filterEqStatisticsexecutionstotal] Filters by &#39;statistics$executions$total&#39;
         * @param {string} [filterEqStatus] Filters by &#39;status&#39;
         * @param {string} [filterEqUser] Filters by &#39;user&#39;
         * @param {number} [filterEqUserId] Filters by &#39;userId&#39;
         * @param {string} [filterEqUuid] Filters by &#39;uuid&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectLaunchesUsingGET(projectName: string, filterEqAttributeKey?: string, filterEqAttributeValue?: string, filterEqCompositeAttribute?: Array<string>, filterEqDescription?: string, filterEqEndTime?: Date, filterEqHasRetries?: boolean, filterEqId?: number, filterEqLastModified?: Date, filterEqMode?: string, filterEqName?: string, filterEqNumber?: number, filterEqProjectId?: number, filterEqStartTime?: Date, filterEqStatisticsdefectsautomationBugab001?: number, filterEqStatisticsdefectsnoDefectnd001?: number, filterEqStatisticsdefectsproductBugpb001?: number, filterEqStatisticsdefectssystemIssuesi001?: number, filterEqStatisticsdefectstoInvestigateti001?: number, filterEqStatisticsexecutionsfailed?: number, filterEqStatisticsexecutionspassed?: number, filterEqStatisticsexecutionsskipped?: number, filterEqStatisticsexecutionstotal?: number, filterEqStatus?: string, filterEqUser?: string, filterEqUserId?: number, filterEqUuid?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any) {
            return LaunchControllerApiFp(configuration).getProjectLaunchesUsingGET(projectName, filterEqAttributeKey, filterEqAttributeValue, filterEqCompositeAttribute, filterEqDescription, filterEqEndTime, filterEqHasRetries, filterEqId, filterEqLastModified, filterEqMode, filterEqName, filterEqNumber, filterEqProjectId, filterEqStartTime, filterEqStatisticsdefectsautomationBugab001, filterEqStatisticsdefectsnoDefectnd001, filterEqStatisticsdefectsproductBugpb001, filterEqStatisticsdefectssystemIssuesi001, filterEqStatisticsdefectstoInvestigateti001, filterEqStatisticsexecutionsfailed, filterEqStatisticsexecutionspassed, filterEqStatisticsexecutionsskipped, filterEqStatisticsexecutionstotal, filterEqStatus, filterEqUser, filterEqUserId, filterEqUuid, pagePage, pageSize, pageSort, options)(fetch, basePath);
        },
        /**
         *
         * @summary getStatuses
         * @param {Array<number>} ids ids
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusesUsingGET(ids: Array<number>, projectName: string, options?: any) {
            return LaunchControllerApiFp(configuration).getStatusesUsingGET(ids, projectName, options)(fetch, basePath);
        },
        /**
         * Only following formats are supported: zip and xml.
         * @summary Import junit xml report
         * @param {any} file file
         * @param {string} projectName projectName
         * @param {LaunchImportRQ} [launchImportRq]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importLaunchUsingPOST(file: any, projectName: string, launchImportRq?: LaunchImportRQ, options?: any) {
            return LaunchControllerApiFp(configuration).importLaunchUsingPOST(file, projectName, launchImportRq, options)(fetch, basePath);
        },
        /**
         *
         * @summary Merge set of specified launches in common one
         * @param {MergeLaunchesRQ} mergeLaunchesRQ Merge launches request body
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeLaunchesUsingPOST1(mergeLaunchesRQ: MergeLaunchesRQ, projectName: string, options?: any) {
            return LaunchControllerApiFp(configuration).mergeLaunchesUsingPOST1(mergeLaunchesRQ, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Start launch auto-analyzer on demand
         * @param {AnalyzeLaunchRQ} analyzeLaunchRQ analyzeLaunchRQ
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startLaunchAnalyzerUsingPOST(analyzeLaunchRQ: AnalyzeLaunchRQ, projectName: string, options?: any) {
            return LaunchControllerApiFp(configuration).startLaunchAnalyzerUsingPOST(analyzeLaunchRQ, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Starts launch for specified project
         * @param {string} projectName projectName
         * @param {StartLaunchRQ} startLaunchRQ Start launch request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startLaunchUsingPOST1(projectName: string, startLaunchRQ: StartLaunchRQ, options?: any) {
            return LaunchControllerApiFp(configuration).startLaunchUsingPOST1(projectName, startLaunchRQ, options)(fetch, basePath);
        },
        /**
         *
         * @summary Updates launch for specified project
         * @param {number} launchId launchId
         * @param {string} projectName projectName
         * @param {UpdateLaunchRQ} updateLaunchRQ updateLaunchRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLaunchUsingPUT(launchId: number, projectName: string, updateLaunchRQ: UpdateLaunchRQ, options?: any) {
            return LaunchControllerApiFp(configuration).updateLaunchUsingPUT(launchId, projectName, updateLaunchRQ, options)(fetch, basePath);
        },
        /**
         *
         * @summary Updates launches for specified project
         * @param {string} projectName projectName
         * @param {BulkRQlongUpdateLaunchRQ} rq rq
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLaunchesUsingPUT(projectName: string, rq: BulkRQlongUpdateLaunchRQ, options?: any) {
            return LaunchControllerApiFp(configuration).updateLaunchesUsingPUT(projectName, rq, options)(fetch, basePath);
        },
    };
};

/**
 * LaunchControllerApi - object-oriented interface
 * @export
 * @class LaunchControllerApi
 * @extends {BaseAPI}
 */
export class LaunchControllerApi extends BaseAPI {
    /**
     *
     * @summary Force finish launch
     * @param {string} projectName projectName
     * @param {BulkRQlongFinishExecutionRQ} rq rq
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaunchControllerApi
     */
    public bulkForceFinishUsingPUT(projectName: string, rq: BulkRQlongFinishExecutionRQ, options?: any) {
        return LaunchControllerApiFp(this.configuration).bulkForceFinishUsingPUT(projectName, rq, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Bulk update attributes and description
     * @param {BulkInfoUpdateRQ} bulkInfoUpdateRQ bulkInfoUpdateRQ
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaunchControllerApi
     */
    public bulkUpdateUsingPUT(bulkInfoUpdateRQ: BulkInfoUpdateRQ, projectName: string, options?: any) {
        return LaunchControllerApiFp(this.configuration).bulkUpdateUsingPUT(bulkInfoUpdateRQ, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Compare launches
     * @param {Array<number>} ids ids
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaunchControllerApi
     */
    public compareLaunchesUsingGET(ids: Array<number>, projectName: string, options?: any) {
        return LaunchControllerApiFp(this.configuration).compareLaunchesUsingGET(ids, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Create launch clusters
     * @param {CreateClustersRQ} createClustersRQ createClustersRQ
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaunchControllerApi
     */
    public createClustersUsingPOST(createClustersRQ: CreateClustersRQ, projectName: string, options?: any) {
        return LaunchControllerApiFp(this.configuration).createClustersUsingPOST(createClustersRQ, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete specified launch by ID
     * @param {number} launchId launchId
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaunchControllerApi
     */
    public deleteLaunchUsingDELETE(launchId: number, projectName: string, options?: any) {
        return LaunchControllerApiFp(this.configuration).deleteLaunchUsingDELETE(launchId, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete specified launches by ids
     * @param {DeleteBulkRQ} deleteBulkRQ deleteBulkRQ
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaunchControllerApi
     */
    public deleteLaunchesUsingDELETE(deleteBulkRQ: DeleteBulkRQ, projectName: string, options?: any) {
        return LaunchControllerApiFp(this.configuration).deleteLaunchesUsingDELETE(deleteBulkRQ, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Finish launch for specified project
     * @param {FinishExecutionRQ} finishLaunchRQ finishLaunchRQ
     * @param {string} launchId launchId
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaunchControllerApi
     */
    public finishLaunchUsingPUT1(finishLaunchRQ: FinishExecutionRQ, launchId: string, projectName: string, options?: any) {
        return LaunchControllerApiFp(this.configuration).finishLaunchUsingPUT1(finishLaunchRQ, launchId, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Force finish launch for specified project
     * @param {FinishExecutionRQ} finishExecutionRQ finishExecutionRQ
     * @param {number} launchId launchId
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaunchControllerApi
     */
    public forceFinishLaunchUsingPUT(finishExecutionRQ: FinishExecutionRQ, launchId: number, projectName: string, options?: any) {
        return LaunchControllerApiFp(this.configuration).forceFinishLaunchUsingPUT(finishExecutionRQ, launchId, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get launch names of project
     * @param {string} projectName projectName
     * @param {string} [filterCntName] filter.cnt.name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaunchControllerApi
     */
    public getAllLaunchNamesUsingGET(projectName: string, filterCntName?: string, options?: any) {
        return LaunchControllerApiFp(this.configuration).getAllLaunchNamesUsingGET(projectName, filterCntName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get all unique owners of project launches
     * @param {string} filterCntUser filter.cnt.user
     * @param {string} projectName projectName
     * @param {string} [mode] mode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaunchControllerApi
     */
    public getAllOwnersUsingGET(filterCntUser: string, projectName: string, mode?: string, options?: any) {
        return LaunchControllerApiFp(this.configuration).getAllOwnersUsingGET(filterCntUser, projectName, mode, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get all unique attribute keys of project launches
     * @param {string} filterCntAttributeKey filter.cnt.attributeKey
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaunchControllerApi
     */
    public getAttributeKeysUsingGET(filterCntAttributeKey: string, projectName: string, options?: any) {
        return LaunchControllerApiFp(this.configuration).getAttributeKeysUsingGET(filterCntAttributeKey, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get all unique attribute values of project launches
     * @param {string} filterCntAttributeValue filter.cnt.attributeValue
     * @param {string} projectName projectName
     * @param {string} [filterEqAttributeKey] filter.eq.attributeKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaunchControllerApi
     */
    public getAttributeValuesUsingGET(filterCntAttributeValue: string, projectName: string, filterEqAttributeKey?: string, options?: any) {
        return LaunchControllerApiFp(this.configuration).getAttributeValuesUsingGET(filterCntAttributeValue, projectName, filterEqAttributeKey, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get all index clusters of the launch
     * @param {string} launchId launchId
     * @param {string} projectName projectName
     * @param {number} [pagePage] Results page you want to retrieve (0..N)
     * @param {number} [pageSize] Number of records per page
     * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaunchControllerApi
     */
    public getClustersUsingGET(launchId: string, projectName: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any) {
        return LaunchControllerApiFp(this.configuration).getClustersUsingGET(launchId, projectName, pagePage, pageSize, pageSort, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get launches of specified project from DEBUG mode
     * @param {string} projectName projectName
     * @param {string} [filterEqAttributeKey] Filters by &#39;attributeKey&#39;
     * @param {string} [filterEqAttributeValue] Filters by &#39;attributeValue&#39;
     * @param {Array<string>} [filterEqCompositeAttribute] Filters by &#39;compositeAttribute&#39;
     * @param {string} [filterEqDescription] Filters by &#39;description&#39;
     * @param {Date} [filterEqEndTime] Filters by &#39;endTime&#39;
     * @param {boolean} [filterEqHasRetries] Filters by &#39;hasRetries&#39;
     * @param {number} [filterEqId] Filters by &#39;id&#39;
     * @param {Date} [filterEqLastModified] Filters by &#39;lastModified&#39;
     * @param {string} [filterEqMode] Filters by &#39;mode&#39;
     * @param {string} [filterEqName] Filters by &#39;name&#39;
     * @param {number} [filterEqNumber] Filters by &#39;number&#39;
     * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
     * @param {Date} [filterEqStartTime] Filters by &#39;startTime&#39;
     * @param {number} [filterEqStatisticsdefectsautomationBugab001] Filters by &#39;statistics$defects$automation_bug$ab001&#39;
     * @param {number} [filterEqStatisticsdefectsnoDefectnd001] Filters by &#39;statistics$defects$no_defect$nd001&#39;
     * @param {number} [filterEqStatisticsdefectsproductBugpb001] Filters by &#39;statistics$defects$product_bug$pb001&#39;
     * @param {number} [filterEqStatisticsdefectssystemIssuesi001] Filters by &#39;statistics$defects$system_issue$si001&#39;
     * @param {number} [filterEqStatisticsdefectstoInvestigateti001] Filters by &#39;statistics$defects$to_investigate$ti001&#39;
     * @param {number} [filterEqStatisticsexecutionsfailed] Filters by &#39;statistics$executions$failed&#39;
     * @param {number} [filterEqStatisticsexecutionspassed] Filters by &#39;statistics$executions$passed&#39;
     * @param {number} [filterEqStatisticsexecutionsskipped] Filters by &#39;statistics$executions$skipped&#39;
     * @param {number} [filterEqStatisticsexecutionstotal] Filters by &#39;statistics$executions$total&#39;
     * @param {string} [filterEqStatus] Filters by &#39;status&#39;
     * @param {string} [filterEqUser] Filters by &#39;user&#39;
     * @param {number} [filterEqUserId] Filters by &#39;userId&#39;
     * @param {string} [filterEqUuid] Filters by &#39;uuid&#39;
     * @param {number} [pagePage] Results page you want to retrieve (0..N)
     * @param {number} [pageSize] Number of records per page
     * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaunchControllerApi
     */
    public getDebugLaunchesUsingGET(projectName: string, filterEqAttributeKey?: string, filterEqAttributeValue?: string, filterEqCompositeAttribute?: Array<string>, filterEqDescription?: string, filterEqEndTime?: Date, filterEqHasRetries?: boolean, filterEqId?: number, filterEqLastModified?: Date, filterEqMode?: string, filterEqName?: string, filterEqNumber?: number, filterEqProjectId?: number, filterEqStartTime?: Date, filterEqStatisticsdefectsautomationBugab001?: number, filterEqStatisticsdefectsnoDefectnd001?: number, filterEqStatisticsdefectsproductBugpb001?: number, filterEqStatisticsdefectssystemIssuesi001?: number, filterEqStatisticsdefectstoInvestigateti001?: number, filterEqStatisticsexecutionsfailed?: number, filterEqStatisticsexecutionspassed?: number, filterEqStatisticsexecutionsskipped?: number, filterEqStatisticsexecutionstotal?: number, filterEqStatus?: string, filterEqUser?: string, filterEqUserId?: number, filterEqUuid?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any) {
        return LaunchControllerApiFp(this.configuration).getDebugLaunchesUsingGET(projectName, filterEqAttributeKey, filterEqAttributeValue, filterEqCompositeAttribute, filterEqDescription, filterEqEndTime, filterEqHasRetries, filterEqId, filterEqLastModified, filterEqMode, filterEqName, filterEqNumber, filterEqProjectId, filterEqStartTime, filterEqStatisticsdefectsautomationBugab001, filterEqStatisticsdefectsnoDefectnd001, filterEqStatisticsdefectsproductBugpb001, filterEqStatisticsdefectssystemIssuesi001, filterEqStatisticsdefectstoInvestigateti001, filterEqStatisticsexecutionsfailed, filterEqStatisticsexecutionspassed, filterEqStatisticsexecutionsskipped, filterEqStatisticsexecutionstotal, filterEqStatus, filterEqUser, filterEqUserId, filterEqUuid, pagePage, pageSize, pageSort, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get list of latest project launches by filter
     * @param {string} projectName projectName
     * @param {string} [filterEqAttributeKey] Filters by &#39;attributeKey&#39;
     * @param {string} [filterEqAttributeValue] Filters by &#39;attributeValue&#39;
     * @param {Array<string>} [filterEqCompositeAttribute] Filters by &#39;compositeAttribute&#39;
     * @param {string} [filterEqDescription] Filters by &#39;description&#39;
     * @param {Date} [filterEqEndTime] Filters by &#39;endTime&#39;
     * @param {boolean} [filterEqHasRetries] Filters by &#39;hasRetries&#39;
     * @param {number} [filterEqId] Filters by &#39;id&#39;
     * @param {Date} [filterEqLastModified] Filters by &#39;lastModified&#39;
     * @param {string} [filterEqMode] Filters by &#39;mode&#39;
     * @param {string} [filterEqName] Filters by &#39;name&#39;
     * @param {number} [filterEqNumber] Filters by &#39;number&#39;
     * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
     * @param {Date} [filterEqStartTime] Filters by &#39;startTime&#39;
     * @param {number} [filterEqStatisticsdefectsautomationBugab001] Filters by &#39;statistics$defects$automation_bug$ab001&#39;
     * @param {number} [filterEqStatisticsdefectsnoDefectnd001] Filters by &#39;statistics$defects$no_defect$nd001&#39;
     * @param {number} [filterEqStatisticsdefectsproductBugpb001] Filters by &#39;statistics$defects$product_bug$pb001&#39;
     * @param {number} [filterEqStatisticsdefectssystemIssuesi001] Filters by &#39;statistics$defects$system_issue$si001&#39;
     * @param {number} [filterEqStatisticsdefectstoInvestigateti001] Filters by &#39;statistics$defects$to_investigate$ti001&#39;
     * @param {number} [filterEqStatisticsexecutionsfailed] Filters by &#39;statistics$executions$failed&#39;
     * @param {number} [filterEqStatisticsexecutionspassed] Filters by &#39;statistics$executions$passed&#39;
     * @param {number} [filterEqStatisticsexecutionsskipped] Filters by &#39;statistics$executions$skipped&#39;
     * @param {number} [filterEqStatisticsexecutionstotal] Filters by &#39;statistics$executions$total&#39;
     * @param {string} [filterEqStatus] Filters by &#39;status&#39;
     * @param {string} [filterEqUser] Filters by &#39;user&#39;
     * @param {number} [filterEqUserId] Filters by &#39;userId&#39;
     * @param {string} [filterEqUuid] Filters by &#39;uuid&#39;
     * @param {number} [pagePage] Results page you want to retrieve (0..N)
     * @param {number} [pageSize] Number of records per page
     * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaunchControllerApi
     */
    public getLatestLaunchesUsingGET(projectName: string, filterEqAttributeKey?: string, filterEqAttributeValue?: string, filterEqCompositeAttribute?: Array<string>, filterEqDescription?: string, filterEqEndTime?: Date, filterEqHasRetries?: boolean, filterEqId?: number, filterEqLastModified?: Date, filterEqMode?: string, filterEqName?: string, filterEqNumber?: number, filterEqProjectId?: number, filterEqStartTime?: Date, filterEqStatisticsdefectsautomationBugab001?: number, filterEqStatisticsdefectsnoDefectnd001?: number, filterEqStatisticsdefectsproductBugpb001?: number, filterEqStatisticsdefectssystemIssuesi001?: number, filterEqStatisticsdefectstoInvestigateti001?: number, filterEqStatisticsexecutionsfailed?: number, filterEqStatisticsexecutionspassed?: number, filterEqStatisticsexecutionsskipped?: number, filterEqStatisticsexecutionstotal?: number, filterEqStatus?: string, filterEqUser?: string, filterEqUserId?: number, filterEqUuid?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any) {
        return LaunchControllerApiFp(this.configuration).getLatestLaunchesUsingGET(projectName, filterEqAttributeKey, filterEqAttributeValue, filterEqCompositeAttribute, filterEqDescription, filterEqEndTime, filterEqHasRetries, filterEqId, filterEqLastModified, filterEqMode, filterEqName, filterEqNumber, filterEqProjectId, filterEqStartTime, filterEqStatisticsdefectsautomationBugab001, filterEqStatisticsdefectsnoDefectnd001, filterEqStatisticsdefectsproductBugpb001, filterEqStatisticsdefectssystemIssuesi001, filterEqStatisticsdefectstoInvestigateti001, filterEqStatisticsexecutionsfailed, filterEqStatisticsexecutionspassed, filterEqStatisticsexecutionsskipped, filterEqStatisticsexecutionstotal, filterEqStatus, filterEqUser, filterEqUserId, filterEqUuid, pagePage, pageSize, pageSort, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get specified launch by UUID
     * @param {string} launchId launchId
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaunchControllerApi
     */
    public getLaunchByUuidUsingGET(launchId: string, projectName: string, options?: any) {
        return LaunchControllerApiFp(this.configuration).getLaunchByUuidUsingGET(launchId, projectName, options)(this.fetch, this.basePath);
    }

    /**
     * Only following formats are supported: pdf (by default), xls, html.
     * @summary Export specified launch
     * @param {number} launchId launchId
     * @param {string} projectName projectName
     * @param {'pdf' | 'xls' | 'html'} [view] view
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaunchControllerApi
     */
    public getLaunchReportUsingGET(launchId: number, projectName: string, view?: 'pdf' | 'xls' | 'html', options?: any) {
        return LaunchControllerApiFp(this.configuration).getLaunchReportUsingGET(launchId, projectName, view, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get specified launch by ID
     * @param {string} launchId launchId
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaunchControllerApi
     */
    public getLaunchUsingGET(launchId: string, projectName: string, options?: any) {
        return LaunchControllerApiFp(this.configuration).getLaunchUsingGET(launchId, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get list of project launches by filter
     * @param {string} projectName projectName
     * @param {string} [filterEqAttributeKey] Filters by &#39;attributeKey&#39;
     * @param {string} [filterEqAttributeValue] Filters by &#39;attributeValue&#39;
     * @param {Array<string>} [filterEqCompositeAttribute] Filters by &#39;compositeAttribute&#39;
     * @param {string} [filterEqDescription] Filters by &#39;description&#39;
     * @param {Date} [filterEqEndTime] Filters by &#39;endTime&#39;
     * @param {boolean} [filterEqHasRetries] Filters by &#39;hasRetries&#39;
     * @param {number} [filterEqId] Filters by &#39;id&#39;
     * @param {Date} [filterEqLastModified] Filters by &#39;lastModified&#39;
     * @param {string} [filterEqMode] Filters by &#39;mode&#39;
     * @param {string} [filterEqName] Filters by &#39;name&#39;
     * @param {number} [filterEqNumber] Filters by &#39;number&#39;
     * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
     * @param {Date} [filterEqStartTime] Filters by &#39;startTime&#39;
     * @param {number} [filterEqStatisticsdefectsautomationBugab001] Filters by &#39;statistics$defects$automation_bug$ab001&#39;
     * @param {number} [filterEqStatisticsdefectsnoDefectnd001] Filters by &#39;statistics$defects$no_defect$nd001&#39;
     * @param {number} [filterEqStatisticsdefectsproductBugpb001] Filters by &#39;statistics$defects$product_bug$pb001&#39;
     * @param {number} [filterEqStatisticsdefectssystemIssuesi001] Filters by &#39;statistics$defects$system_issue$si001&#39;
     * @param {number} [filterEqStatisticsdefectstoInvestigateti001] Filters by &#39;statistics$defects$to_investigate$ti001&#39;
     * @param {number} [filterEqStatisticsexecutionsfailed] Filters by &#39;statistics$executions$failed&#39;
     * @param {number} [filterEqStatisticsexecutionspassed] Filters by &#39;statistics$executions$passed&#39;
     * @param {number} [filterEqStatisticsexecutionsskipped] Filters by &#39;statistics$executions$skipped&#39;
     * @param {number} [filterEqStatisticsexecutionstotal] Filters by &#39;statistics$executions$total&#39;
     * @param {string} [filterEqStatus] Filters by &#39;status&#39;
     * @param {string} [filterEqUser] Filters by &#39;user&#39;
     * @param {number} [filterEqUserId] Filters by &#39;userId&#39;
     * @param {string} [filterEqUuid] Filters by &#39;uuid&#39;
     * @param {number} [pagePage] Results page you want to retrieve (0..N)
     * @param {number} [pageSize] Number of records per page
     * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaunchControllerApi
     */
    public getProjectLaunchesUsingGET(projectName: string, filterEqAttributeKey?: string, filterEqAttributeValue?: string, filterEqCompositeAttribute?: Array<string>, filterEqDescription?: string, filterEqEndTime?: Date, filterEqHasRetries?: boolean, filterEqId?: number, filterEqLastModified?: Date, filterEqMode?: string, filterEqName?: string, filterEqNumber?: number, filterEqProjectId?: number, filterEqStartTime?: Date, filterEqStatisticsdefectsautomationBugab001?: number, filterEqStatisticsdefectsnoDefectnd001?: number, filterEqStatisticsdefectsproductBugpb001?: number, filterEqStatisticsdefectssystemIssuesi001?: number, filterEqStatisticsdefectstoInvestigateti001?: number, filterEqStatisticsexecutionsfailed?: number, filterEqStatisticsexecutionspassed?: number, filterEqStatisticsexecutionsskipped?: number, filterEqStatisticsexecutionstotal?: number, filterEqStatus?: string, filterEqUser?: string, filterEqUserId?: number, filterEqUuid?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any) {
        return LaunchControllerApiFp(this.configuration).getProjectLaunchesUsingGET(projectName, filterEqAttributeKey, filterEqAttributeValue, filterEqCompositeAttribute, filterEqDescription, filterEqEndTime, filterEqHasRetries, filterEqId, filterEqLastModified, filterEqMode, filterEqName, filterEqNumber, filterEqProjectId, filterEqStartTime, filterEqStatisticsdefectsautomationBugab001, filterEqStatisticsdefectsnoDefectnd001, filterEqStatisticsdefectsproductBugpb001, filterEqStatisticsdefectssystemIssuesi001, filterEqStatisticsdefectstoInvestigateti001, filterEqStatisticsexecutionsfailed, filterEqStatisticsexecutionspassed, filterEqStatisticsexecutionsskipped, filterEqStatisticsexecutionstotal, filterEqStatus, filterEqUser, filterEqUserId, filterEqUuid, pagePage, pageSize, pageSort, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary getStatuses
     * @param {Array<number>} ids ids
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaunchControllerApi
     */
    public getStatusesUsingGET(ids: Array<number>, projectName: string, options?: any) {
        return LaunchControllerApiFp(this.configuration).getStatusesUsingGET(ids, projectName, options)(this.fetch, this.basePath);
    }

    /**
     * Only following formats are supported: zip and xml.
     * @summary Import junit xml report
     * @param {any} file file
     * @param {string} projectName projectName
     * @param {LaunchImportRQ} [launchImportRq]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaunchControllerApi
     */
    public importLaunchUsingPOST(file: any, projectName: string, launchImportRq?: LaunchImportRQ, options?: any) {
        return LaunchControllerApiFp(this.configuration).importLaunchUsingPOST(file, projectName, launchImportRq, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Merge set of specified launches in common one
     * @param {MergeLaunchesRQ} mergeLaunchesRQ Merge launches request body
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaunchControllerApi
     */
    public mergeLaunchesUsingPOST1(mergeLaunchesRQ: MergeLaunchesRQ, projectName: string, options?: any) {
        return LaunchControllerApiFp(this.configuration).mergeLaunchesUsingPOST1(mergeLaunchesRQ, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Start launch auto-analyzer on demand
     * @param {AnalyzeLaunchRQ} analyzeLaunchRQ analyzeLaunchRQ
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaunchControllerApi
     */
    public startLaunchAnalyzerUsingPOST(analyzeLaunchRQ: AnalyzeLaunchRQ, projectName: string, options?: any) {
        return LaunchControllerApiFp(this.configuration).startLaunchAnalyzerUsingPOST(analyzeLaunchRQ, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Starts launch for specified project
     * @param {string} projectName projectName
     * @param {StartLaunchRQ} startLaunchRQ Start launch request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaunchControllerApi
     */
    public startLaunchUsingPOST1(projectName: string, startLaunchRQ: StartLaunchRQ, options?: any) {
        return LaunchControllerApiFp(this.configuration).startLaunchUsingPOST1(projectName, startLaunchRQ, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Updates launch for specified project
     * @param {number} launchId launchId
     * @param {string} projectName projectName
     * @param {UpdateLaunchRQ} updateLaunchRQ updateLaunchRQ
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaunchControllerApi
     */
    public updateLaunchUsingPUT(launchId: number, projectName: string, updateLaunchRQ: UpdateLaunchRQ, options?: any) {
        return LaunchControllerApiFp(this.configuration).updateLaunchUsingPUT(launchId, projectName, updateLaunchRQ, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Updates launches for specified project
     * @param {string} projectName projectName
     * @param {BulkRQlongUpdateLaunchRQ} rq rq
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LaunchControllerApi
     */
    public updateLaunchesUsingPUT(projectName: string, rq: BulkRQlongUpdateLaunchRQ, options?: any) {
        return LaunchControllerApiFp(this.configuration).updateLaunchesUsingPUT(projectName, rq, options)(this.fetch, this.basePath);
    }

}

/**
 * LogAsyncControllerApi - fetch parameter creator
 * @export
 */
export const LogAsyncControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create log
         * @param {SaveLogRQ} createLogRQ createLogRQ
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLogEntryUsingPOST(createLogRQ: SaveLogRQ, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'createLogRQ' is not null or undefined
            if (createLogRQ === null || createLogRQ === undefined) {
                throw new RequiredError('createLogRQ', 'Required parameter createLogRQ was null or undefined when calling createLogEntryUsingPOST.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling createLogEntryUsingPOST.');
            }
            const localVarPath = `/v2/{projectName}/log/entry`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SaveLogRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(createLogRQ || {}) : (createLogRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create log (batching operation)
         * @param {any} jsonRequestPart json_request_part
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLogUsingPOST(jsonRequestPart: any, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'jsonRequestPart' is not null or undefined
            if (jsonRequestPart === null || jsonRequestPart === undefined) {
                throw new RequiredError('jsonRequestPart', 'Required parameter jsonRequestPart was null or undefined when calling createLogUsingPOST.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling createLogUsingPOST.');
            }
            const localVarPath = `/v2/{projectName}/log`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            if (jsonRequestPart !== undefined) {
                localVarFormParams.set('json_request_part', jsonRequestPart as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LogAsyncControllerApi - functional programming interface
 * @export
 */
export const LogAsyncControllerApiFp = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create log
         * @param {SaveLogRQ} createLogRQ createLogRQ
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLogEntryUsingPOST(createLogRQ: SaveLogRQ, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EntryCreatedAsyncRS> {
            const localVarFetchArgs = LogAsyncControllerApiFetchParamCreator(configuration).createLogEntryUsingPOST(createLogRQ, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create log (batching operation)
         * @param {any} jsonRequestPart json_request_part
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLogUsingPOST(jsonRequestPart: any, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BatchSaveOperatingRS> {
            const localVarFetchArgs = LogAsyncControllerApiFetchParamCreator(configuration).createLogUsingPOST(jsonRequestPart, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LogAsyncControllerApi - factory interface
 * @export
 */
export const LogAsyncControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Create log
         * @param {SaveLogRQ} createLogRQ createLogRQ
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLogEntryUsingPOST(createLogRQ: SaveLogRQ, projectName: string, options?: any) {
            return LogAsyncControllerApiFp(configuration).createLogEntryUsingPOST(createLogRQ, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create log (batching operation)
         * @param {any} jsonRequestPart json_request_part
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLogUsingPOST(jsonRequestPart: any, projectName: string, options?: any) {
            return LogAsyncControllerApiFp(configuration).createLogUsingPOST(jsonRequestPart, projectName, options)(fetch, basePath);
        },
    };
};

/**
 * LogAsyncControllerApi - object-oriented interface
 * @export
 * @class LogAsyncControllerApi
 * @extends {BaseAPI}
 */
export class LogAsyncControllerApi extends BaseAPI {
    /**
     *
     * @summary Create log
     * @param {SaveLogRQ} createLogRQ createLogRQ
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogAsyncControllerApi
     */
    public createLogEntryUsingPOST(createLogRQ: SaveLogRQ, projectName: string, options?: any) {
        return LogAsyncControllerApiFp(this.configuration).createLogEntryUsingPOST(createLogRQ, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Create log (batching operation)
     * @param {any} jsonRequestPart json_request_part
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogAsyncControllerApi
     */
    public createLogUsingPOST(jsonRequestPart: any, projectName: string, options?: any) {
        return LogAsyncControllerApiFp(this.configuration).createLogUsingPOST(jsonRequestPart, projectName, options)(this.fetch, this.basePath);
    }

}

/**
 * LogControllerApi - fetch parameter creator
 * @export
 */
export const LogControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create log
         * @param {SaveLogRQ} createLogRQ createLogRQ
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLogEntryUsingPOST1(createLogRQ: SaveLogRQ, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'createLogRQ' is not null or undefined
            if (createLogRQ === null || createLogRQ === undefined) {
                throw new RequiredError('createLogRQ', 'Required parameter createLogRQ was null or undefined when calling createLogEntryUsingPOST1.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling createLogEntryUsingPOST1.');
            }
            const localVarPath = `/v1/{projectName}/log/entry`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SaveLogRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(createLogRQ || {}) : (createLogRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create log (batching operation)
         * @param {any} jsonRequestPart json_request_part
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLogUsingPOST1(jsonRequestPart: any, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'jsonRequestPart' is not null or undefined
            if (jsonRequestPart === null || jsonRequestPart === undefined) {
                throw new RequiredError('jsonRequestPart', 'Required parameter jsonRequestPart was null or undefined when calling createLogUsingPOST1.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling createLogUsingPOST1.');
            }
            const localVarPath = `/v1/{projectName}/log`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            if (jsonRequestPart !== undefined) {
                localVarFormParams.set('json_request_part', jsonRequestPart as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete log
         * @param {number} logId logId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLogUsingDELETE(logId: number, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'logId' is not null or undefined
            if (logId === null || logId === undefined) {
                throw new RequiredError('logId', 'Required parameter logId was null or undefined when calling deleteLogUsingDELETE.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling deleteLogUsingDELETE.');
            }
            const localVarPath = `/v1/{projectName}/log/{logId}`
                .replace(`{${"logId"}}`, encodeURIComponent(String(logId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'DELETE'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get next or previous log in test item
         * @param {any} params params
         * @param {number} parentId parentId
         * @param {string} projectName projectName
         * @param {boolean} [filterEqAutoAnalyzed] Filters by &#39;autoAnalyzed&#39;
         * @param {string} [filterEqBinaryContent] Filters by &#39;binaryContent&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {number} [filterEqItem] Filters by &#39;item&#39;
         * @param {Date} [filterEqLastModified] Filters by &#39;lastModified&#39;
         * @param {number} [filterEqLaunch] Filters by &#39;launch&#39;
         * @param {number} [filterEqLaunchId] Filters by &#39;launchId&#39;
         * @param {string} [filterEqLevel] Filters by &#39;level&#39;
         * @param {number} [filterEqLogId] Filters by &#39;logId&#39;
         * @param {Date} [filterEqLogTime] Filters by &#39;logTime&#39;
         * @param {string} [filterEqMessage] Filters by &#39;message&#39;
         * @param {string} [filterEqPath] Filters by &#39;path&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {number} [filterEqRetryParentId] Filters by &#39;retryParentId&#39;
         * @param {number} [filterEqRetryParentLaunchId] Filters by &#39;retryParentLaunchId&#39;
         * @param {string} [filterEqStatus] Filters by &#39;status&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getErrorPageUsingGET(params: any, parentId: number, projectName: string, filterEqAutoAnalyzed?: boolean, filterEqBinaryContent?: string, filterEqId?: number, filterEqItem?: number, filterEqLastModified?: Date, filterEqLaunch?: number, filterEqLaunchId?: number, filterEqLevel?: string, filterEqLogId?: number, filterEqLogTime?: Date, filterEqMessage?: string, filterEqPath?: string, filterEqProjectId?: number, filterEqRetryParentId?: number, filterEqRetryParentLaunchId?: number, filterEqStatus?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'params' is not null or undefined
            if (params === null || params === undefined) {
                throw new RequiredError('params', 'Required parameter params was null or undefined when calling getErrorPageUsingGET.');
            }
            // verify required parameter 'parentId' is not null or undefined
            if (parentId === null || parentId === undefined) {
                throw new RequiredError('parentId', 'Required parameter parentId was null or undefined when calling getErrorPageUsingGET.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getErrorPageUsingGET.');
            }
            const localVarPath = `/v1/{projectName}/log/locations/{parentId}`
                .replace(`{${"parentId"}}`, encodeURIComponent(String(parentId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filterEqAutoAnalyzed !== undefined) {
                localVarQueryParameter['filter.eq.autoAnalyzed'] = filterEqAutoAnalyzed;
            }

            if (filterEqBinaryContent !== undefined) {
                localVarQueryParameter['filter.eq.binaryContent'] = filterEqBinaryContent;
            }

            if (filterEqId !== undefined) {
                localVarQueryParameter['filter.eq.id'] = filterEqId;
            }

            if (filterEqItem !== undefined) {
                localVarQueryParameter['filter.eq.item'] = filterEqItem;
            }

            if (filterEqLastModified !== undefined) {
                localVarQueryParameter['filter.eq.lastModified'] = (filterEqLastModified as any).toISOString();
            }

            if (filterEqLaunch !== undefined) {
                localVarQueryParameter['filter.eq.launch'] = filterEqLaunch;
            }

            if (filterEqLaunchId !== undefined) {
                localVarQueryParameter['filter.eq.launchId'] = filterEqLaunchId;
            }

            if (filterEqLevel !== undefined) {
                localVarQueryParameter['filter.eq.level'] = filterEqLevel;
            }

            if (filterEqLogId !== undefined) {
                localVarQueryParameter['filter.eq.logId'] = filterEqLogId;
            }

            if (filterEqLogTime !== undefined) {
                localVarQueryParameter['filter.eq.logTime'] = (filterEqLogTime as any).toISOString();
            }

            if (filterEqMessage !== undefined) {
                localVarQueryParameter['filter.eq.message'] = filterEqMessage;
            }

            if (filterEqPath !== undefined) {
                localVarQueryParameter['filter.eq.path'] = filterEqPath;
            }

            if (filterEqProjectId !== undefined) {
                localVarQueryParameter['filter.eq.projectId'] = filterEqProjectId;
            }

            if (filterEqRetryParentId !== undefined) {
                localVarQueryParameter['filter.eq.retryParentId'] = filterEqRetryParentId;
            }

            if (filterEqRetryParentLaunchId !== undefined) {
                localVarQueryParameter['filter.eq.retryParentLaunchId'] = filterEqRetryParentLaunchId;
            }

            if (filterEqStatus !== undefined) {
                localVarQueryParameter['filter.eq.status'] = filterEqStatus;
            }

            if (pagePage !== undefined) {
                localVarQueryParameter['page.page'] = pagePage;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page.size'] = pageSize;
            }

            if (pageSort) {
                localVarQueryParameter['page.sort'] = pageSort;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get log by UUID (Will be removed in version 6.0)
         * @param {string} logId logId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogByUuidUsingGET(logId: string, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'logId' is not null or undefined
            if (logId === null || logId === undefined) {
                throw new RequiredError('logId', 'Required parameter logId was null or undefined when calling getLogByUuidUsingGET.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getLogByUuidUsingGET.');
            }
            const localVarPath = `/v1/{projectName}/log/uuid/{logId}`
                .replace(`{${"logId"}}`, encodeURIComponent(String(logId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get log by ID
         * @param {string} logId logId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogUsingGET(logId: string, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'logId' is not null or undefined
            if (logId === null || logId === undefined) {
                throw new RequiredError('logId', 'Required parameter logId was null or undefined when calling getLogUsingGET.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getLogUsingGET.');
            }
            const localVarPath = `/v1/{projectName}/log/{logId}`
                .replace(`{${"logId"}}`, encodeURIComponent(String(logId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get logs under items
         * @param {GetLogsUnderRq} logsUnderRq logsUnderRq
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogsUnderUsingPOST(logsUnderRq: GetLogsUnderRq, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'logsUnderRq' is not null or undefined
            if (logsUnderRq === null || logsUnderRq === undefined) {
                throw new RequiredError('logsUnderRq', 'Required parameter logsUnderRq was null or undefined when calling getLogsUnderUsingPOST.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getLogsUnderUsingPOST.');
            }
            const localVarPath = `/v1/{projectName}/log/under`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GetLogsUnderRq" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(logsUnderRq || {}) : (logsUnderRq || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get logs by filter
         * @param {string} projectName projectName
         * @param {boolean} [filterEqAutoAnalyzed] Filters by &#39;autoAnalyzed&#39;
         * @param {string} [filterEqBinaryContent] Filters by &#39;binaryContent&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {number} [filterEqItem] Filters by &#39;item&#39;
         * @param {Date} [filterEqLastModified] Filters by &#39;lastModified&#39;
         * @param {number} [filterEqLaunch] Filters by &#39;launch&#39;
         * @param {number} [filterEqLaunchId] Filters by &#39;launchId&#39;
         * @param {string} [filterEqLevel] Filters by &#39;level&#39;
         * @param {number} [filterEqLogId] Filters by &#39;logId&#39;
         * @param {Date} [filterEqLogTime] Filters by &#39;logTime&#39;
         * @param {string} [filterEqMessage] Filters by &#39;message&#39;
         * @param {string} [filterEqPath] Filters by &#39;path&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {number} [filterEqRetryParentId] Filters by &#39;retryParentId&#39;
         * @param {number} [filterEqRetryParentLaunchId] Filters by &#39;retryParentLaunchId&#39;
         * @param {string} [filterEqStatus] Filters by &#39;status&#39;
         * @param {string} [filterUnderPath] filter.under.path
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogsUsingGET(projectName: string, filterEqAutoAnalyzed?: boolean, filterEqBinaryContent?: string, filterEqId?: number, filterEqItem?: number, filterEqLastModified?: Date, filterEqLaunch?: number, filterEqLaunchId?: number, filterEqLevel?: string, filterEqLogId?: number, filterEqLogTime?: Date, filterEqMessage?: string, filterEqPath?: string, filterEqProjectId?: number, filterEqRetryParentId?: number, filterEqRetryParentLaunchId?: number, filterEqStatus?: string, filterUnderPath?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getLogsUsingGET.');
            }
            const localVarPath = `/v1/{projectName}/log`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filterEqAutoAnalyzed !== undefined) {
                localVarQueryParameter['filter.eq.autoAnalyzed'] = filterEqAutoAnalyzed;
            }

            if (filterEqBinaryContent !== undefined) {
                localVarQueryParameter['filter.eq.binaryContent'] = filterEqBinaryContent;
            }

            if (filterEqId !== undefined) {
                localVarQueryParameter['filter.eq.id'] = filterEqId;
            }

            if (filterEqItem !== undefined) {
                localVarQueryParameter['filter.eq.item'] = filterEqItem;
            }

            if (filterEqLastModified !== undefined) {
                localVarQueryParameter['filter.eq.lastModified'] = (filterEqLastModified as any).toISOString();
            }

            if (filterEqLaunch !== undefined) {
                localVarQueryParameter['filter.eq.launch'] = filterEqLaunch;
            }

            if (filterEqLaunchId !== undefined) {
                localVarQueryParameter['filter.eq.launchId'] = filterEqLaunchId;
            }

            if (filterEqLevel !== undefined) {
                localVarQueryParameter['filter.eq.level'] = filterEqLevel;
            }

            if (filterEqLogId !== undefined) {
                localVarQueryParameter['filter.eq.logId'] = filterEqLogId;
            }

            if (filterEqLogTime !== undefined) {
                localVarQueryParameter['filter.eq.logTime'] = (filterEqLogTime as any).toISOString();
            }

            if (filterEqMessage !== undefined) {
                localVarQueryParameter['filter.eq.message'] = filterEqMessage;
            }

            if (filterEqPath !== undefined) {
                localVarQueryParameter['filter.eq.path'] = filterEqPath;
            }

            if (filterEqProjectId !== undefined) {
                localVarQueryParameter['filter.eq.projectId'] = filterEqProjectId;
            }

            if (filterEqRetryParentId !== undefined) {
                localVarQueryParameter['filter.eq.retryParentId'] = filterEqRetryParentId;
            }

            if (filterEqRetryParentLaunchId !== undefined) {
                localVarQueryParameter['filter.eq.retryParentLaunchId'] = filterEqRetryParentLaunchId;
            }

            if (filterEqStatus !== undefined) {
                localVarQueryParameter['filter.eq.status'] = filterEqStatus;
            }

            if (filterUnderPath !== undefined) {
                localVarQueryParameter['filter.under.path'] = filterUnderPath;
            }

            if (pagePage !== undefined) {
                localVarQueryParameter['page.page'] = pagePage;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page.size'] = pageSize;
            }

            if (pageSort) {
                localVarQueryParameter['page.sort'] = pageSort;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get nested steps with logs for the parent Test Item
         * @param {number} parentId parentId
         * @param {string} projectName projectName
         * @param {boolean} [filterEqAutoAnalyzed] Filters by &#39;autoAnalyzed&#39;
         * @param {string} [filterEqBinaryContent] Filters by &#39;binaryContent&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {number} [filterEqItem] Filters by &#39;item&#39;
         * @param {Date} [filterEqLastModified] Filters by &#39;lastModified&#39;
         * @param {number} [filterEqLaunch] Filters by &#39;launch&#39;
         * @param {number} [filterEqLaunchId] Filters by &#39;launchId&#39;
         * @param {string} [filterEqLevel] Filters by &#39;level&#39;
         * @param {number} [filterEqLogId] Filters by &#39;logId&#39;
         * @param {Date} [filterEqLogTime] Filters by &#39;logTime&#39;
         * @param {string} [filterEqMessage] Filters by &#39;message&#39;
         * @param {string} [filterEqPath] Filters by &#39;path&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {number} [filterEqRetryParentId] Filters by &#39;retryParentId&#39;
         * @param {number} [filterEqRetryParentLaunchId] Filters by &#39;retryParentLaunchId&#39;
         * @param {string} [filterEqStatus] Filters by &#39;status&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {any} [params] params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNestedItemsUsingGET(parentId: number, projectName: string, filterEqAutoAnalyzed?: boolean, filterEqBinaryContent?: string, filterEqId?: number, filterEqItem?: number, filterEqLastModified?: Date, filterEqLaunch?: number, filterEqLaunchId?: number, filterEqLevel?: string, filterEqLogId?: number, filterEqLogTime?: Date, filterEqMessage?: string, filterEqPath?: string, filterEqProjectId?: number, filterEqRetryParentId?: number, filterEqRetryParentLaunchId?: number, filterEqStatus?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, params?: any, options: any = {}): FetchArgs {
            // verify required parameter 'parentId' is not null or undefined
            if (parentId === null || parentId === undefined) {
                throw new RequiredError('parentId', 'Required parameter parentId was null or undefined when calling getNestedItemsUsingGET.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getNestedItemsUsingGET.');
            }
            const localVarPath = `/v1/{projectName}/log/nested/{parentId}`
                .replace(`{${"parentId"}}`, encodeURIComponent(String(parentId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filterEqAutoAnalyzed !== undefined) {
                localVarQueryParameter['filter.eq.autoAnalyzed'] = filterEqAutoAnalyzed;
            }

            if (filterEqBinaryContent !== undefined) {
                localVarQueryParameter['filter.eq.binaryContent'] = filterEqBinaryContent;
            }

            if (filterEqId !== undefined) {
                localVarQueryParameter['filter.eq.id'] = filterEqId;
            }

            if (filterEqItem !== undefined) {
                localVarQueryParameter['filter.eq.item'] = filterEqItem;
            }

            if (filterEqLastModified !== undefined) {
                localVarQueryParameter['filter.eq.lastModified'] = (filterEqLastModified as any).toISOString();
            }

            if (filterEqLaunch !== undefined) {
                localVarQueryParameter['filter.eq.launch'] = filterEqLaunch;
            }

            if (filterEqLaunchId !== undefined) {
                localVarQueryParameter['filter.eq.launchId'] = filterEqLaunchId;
            }

            if (filterEqLevel !== undefined) {
                localVarQueryParameter['filter.eq.level'] = filterEqLevel;
            }

            if (filterEqLogId !== undefined) {
                localVarQueryParameter['filter.eq.logId'] = filterEqLogId;
            }

            if (filterEqLogTime !== undefined) {
                localVarQueryParameter['filter.eq.logTime'] = (filterEqLogTime as any).toISOString();
            }

            if (filterEqMessage !== undefined) {
                localVarQueryParameter['filter.eq.message'] = filterEqMessage;
            }

            if (filterEqPath !== undefined) {
                localVarQueryParameter['filter.eq.path'] = filterEqPath;
            }

            if (filterEqProjectId !== undefined) {
                localVarQueryParameter['filter.eq.projectId'] = filterEqProjectId;
            }

            if (filterEqRetryParentId !== undefined) {
                localVarQueryParameter['filter.eq.retryParentId'] = filterEqRetryParentId;
            }

            if (filterEqRetryParentLaunchId !== undefined) {
                localVarQueryParameter['filter.eq.retryParentLaunchId'] = filterEqRetryParentLaunchId;
            }

            if (filterEqStatus !== undefined) {
                localVarQueryParameter['filter.eq.status'] = filterEqStatus;
            }

            if (pagePage !== undefined) {
                localVarQueryParameter['page.page'] = pagePage;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page.size'] = pageSize;
            }

            if (pageSort) {
                localVarQueryParameter['page.sort'] = pageSort;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get logs by filter
         * @param {number} logId logId
         * @param {string} projectName projectName
         * @param {boolean} [filterEqAutoAnalyzed] Filters by &#39;autoAnalyzed&#39;
         * @param {string} [filterEqBinaryContent] Filters by &#39;binaryContent&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {number} [filterEqItem] Filters by &#39;item&#39;
         * @param {Date} [filterEqLastModified] Filters by &#39;lastModified&#39;
         * @param {number} [filterEqLaunch] Filters by &#39;launch&#39;
         * @param {number} [filterEqLaunchId] Filters by &#39;launchId&#39;
         * @param {string} [filterEqLevel] Filters by &#39;level&#39;
         * @param {number} [filterEqLogId] Filters by &#39;logId&#39;
         * @param {Date} [filterEqLogTime] Filters by &#39;logTime&#39;
         * @param {string} [filterEqMessage] Filters by &#39;message&#39;
         * @param {string} [filterEqPath] Filters by &#39;path&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {number} [filterEqRetryParentId] Filters by &#39;retryParentId&#39;
         * @param {number} [filterEqRetryParentLaunchId] Filters by &#39;retryParentLaunchId&#39;
         * @param {string} [filterEqStatus] Filters by &#39;status&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPageNumberUsingGET(logId: number, projectName: string, filterEqAutoAnalyzed?: boolean, filterEqBinaryContent?: string, filterEqId?: number, filterEqItem?: number, filterEqLastModified?: Date, filterEqLaunch?: number, filterEqLaunchId?: number, filterEqLevel?: string, filterEqLogId?: number, filterEqLogTime?: Date, filterEqMessage?: string, filterEqPath?: string, filterEqProjectId?: number, filterEqRetryParentId?: number, filterEqRetryParentLaunchId?: number, filterEqStatus?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'logId' is not null or undefined
            if (logId === null || logId === undefined) {
                throw new RequiredError('logId', 'Required parameter logId was null or undefined when calling getPageNumberUsingGET.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getPageNumberUsingGET.');
            }
            const localVarPath = `/v1/{projectName}/log/{logId}/page`
                .replace(`{${"logId"}}`, encodeURIComponent(String(logId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filterEqAutoAnalyzed !== undefined) {
                localVarQueryParameter['filter.eq.autoAnalyzed'] = filterEqAutoAnalyzed;
            }

            if (filterEqBinaryContent !== undefined) {
                localVarQueryParameter['filter.eq.binaryContent'] = filterEqBinaryContent;
            }

            if (filterEqId !== undefined) {
                localVarQueryParameter['filter.eq.id'] = filterEqId;
            }

            if (filterEqItem !== undefined) {
                localVarQueryParameter['filter.eq.item'] = filterEqItem;
            }

            if (filterEqLastModified !== undefined) {
                localVarQueryParameter['filter.eq.lastModified'] = (filterEqLastModified as any).toISOString();
            }

            if (filterEqLaunch !== undefined) {
                localVarQueryParameter['filter.eq.launch'] = filterEqLaunch;
            }

            if (filterEqLaunchId !== undefined) {
                localVarQueryParameter['filter.eq.launchId'] = filterEqLaunchId;
            }

            if (filterEqLevel !== undefined) {
                localVarQueryParameter['filter.eq.level'] = filterEqLevel;
            }

            if (filterEqLogId !== undefined) {
                localVarQueryParameter['filter.eq.logId'] = filterEqLogId;
            }

            if (filterEqLogTime !== undefined) {
                localVarQueryParameter['filter.eq.logTime'] = (filterEqLogTime as any).toISOString();
            }

            if (filterEqMessage !== undefined) {
                localVarQueryParameter['filter.eq.message'] = filterEqMessage;
            }

            if (filterEqPath !== undefined) {
                localVarQueryParameter['filter.eq.path'] = filterEqPath;
            }

            if (filterEqProjectId !== undefined) {
                localVarQueryParameter['filter.eq.projectId'] = filterEqProjectId;
            }

            if (filterEqRetryParentId !== undefined) {
                localVarQueryParameter['filter.eq.retryParentId'] = filterEqRetryParentId;
            }

            if (filterEqRetryParentLaunchId !== undefined) {
                localVarQueryParameter['filter.eq.retryParentLaunchId'] = filterEqRetryParentLaunchId;
            }

            if (filterEqStatus !== undefined) {
                localVarQueryParameter['filter.eq.status'] = filterEqStatus;
            }

            if (pagePage !== undefined) {
                localVarQueryParameter['page.page'] = pagePage;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page.size'] = pageSize;
            }

            if (pageSort) {
                localVarQueryParameter['page.sort'] = pageSort;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Search test items with similar error logs
         * @param {number} itemId itemId
         * @param {string} projectName projectName
         * @param {SearchLogRq} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchLogsUsingPOST(itemId: number, projectName: string, request: SearchLogRq, options: any = {}): FetchArgs {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId', 'Required parameter itemId was null or undefined when calling searchLogsUsingPOST.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling searchLogsUsingPOST.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request', 'Required parameter request was null or undefined when calling searchLogsUsingPOST.');
            }
            const localVarPath = `/v1/{projectName}/log/search/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SearchLogRq" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LogControllerApi - functional programming interface
 * @export
 */
export const LogControllerApiFp = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create log
         * @param {SaveLogRQ} createLogRQ createLogRQ
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLogEntryUsingPOST1(createLogRQ: SaveLogRQ, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EntryCreatedAsyncRS> {
            const localVarFetchArgs = LogControllerApiFetchParamCreator(configuration).createLogEntryUsingPOST1(createLogRQ, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create log (batching operation)
         * @param {any} jsonRequestPart json_request_part
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLogUsingPOST1(jsonRequestPart: any, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BatchSaveOperatingRS> {
            const localVarFetchArgs = LogControllerApiFetchParamCreator(configuration).createLogUsingPOST1(jsonRequestPart, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete log
         * @param {number} logId logId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLogUsingDELETE(logId: number, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = LogControllerApiFetchParamCreator(configuration).deleteLogUsingDELETE(logId, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get next or previous log in test item
         * @param {any} params params
         * @param {number} parentId parentId
         * @param {string} projectName projectName
         * @param {boolean} [filterEqAutoAnalyzed] Filters by &#39;autoAnalyzed&#39;
         * @param {string} [filterEqBinaryContent] Filters by &#39;binaryContent&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {number} [filterEqItem] Filters by &#39;item&#39;
         * @param {Date} [filterEqLastModified] Filters by &#39;lastModified&#39;
         * @param {number} [filterEqLaunch] Filters by &#39;launch&#39;
         * @param {number} [filterEqLaunchId] Filters by &#39;launchId&#39;
         * @param {string} [filterEqLevel] Filters by &#39;level&#39;
         * @param {number} [filterEqLogId] Filters by &#39;logId&#39;
         * @param {Date} [filterEqLogTime] Filters by &#39;logTime&#39;
         * @param {string} [filterEqMessage] Filters by &#39;message&#39;
         * @param {string} [filterEqPath] Filters by &#39;path&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {number} [filterEqRetryParentId] Filters by &#39;retryParentId&#39;
         * @param {number} [filterEqRetryParentLaunchId] Filters by &#39;retryParentLaunchId&#39;
         * @param {string} [filterEqStatus] Filters by &#39;status&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getErrorPageUsingGET(params: any, parentId: number, projectName: string, filterEqAutoAnalyzed?: boolean, filterEqBinaryContent?: string, filterEqId?: number, filterEqItem?: number, filterEqLastModified?: Date, filterEqLaunch?: number, filterEqLaunchId?: number, filterEqLevel?: string, filterEqLogId?: number, filterEqLogTime?: Date, filterEqMessage?: string, filterEqPath?: string, filterEqProjectId?: number, filterEqRetryParentId?: number, filterEqRetryParentLaunchId?: number, filterEqStatus?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PagedLogResource>> {
            const localVarFetchArgs = LogControllerApiFetchParamCreator(configuration).getErrorPageUsingGET(params, parentId, projectName, filterEqAutoAnalyzed, filterEqBinaryContent, filterEqId, filterEqItem, filterEqLastModified, filterEqLaunch, filterEqLaunchId, filterEqLevel, filterEqLogId, filterEqLogTime, filterEqMessage, filterEqPath, filterEqProjectId, filterEqRetryParentId, filterEqRetryParentLaunchId, filterEqStatus, pagePage, pageSize, pageSort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get log by UUID (Will be removed in version 6.0)
         * @param {string} logId logId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogByUuidUsingGET(logId: string, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LogResource> {
            const localVarFetchArgs = LogControllerApiFetchParamCreator(configuration).getLogByUuidUsingGET(logId, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get log by ID
         * @param {string} logId logId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogUsingGET(logId: string, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LogResource> {
            const localVarFetchArgs = LogControllerApiFetchParamCreator(configuration).getLogUsingGET(logId, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get logs under items
         * @param {GetLogsUnderRq} logsUnderRq logsUnderRq
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogsUnderUsingPOST(logsUnderRq: GetLogsUnderRq, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{
            [key: string]: Array<LogResource>;
        }> {
            const localVarFetchArgs = LogControllerApiFetchParamCreator(configuration).getLogsUnderUsingPOST(logsUnderRq, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get logs by filter
         * @param {string} projectName projectName
         * @param {boolean} [filterEqAutoAnalyzed] Filters by &#39;autoAnalyzed&#39;
         * @param {string} [filterEqBinaryContent] Filters by &#39;binaryContent&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {number} [filterEqItem] Filters by &#39;item&#39;
         * @param {Date} [filterEqLastModified] Filters by &#39;lastModified&#39;
         * @param {number} [filterEqLaunch] Filters by &#39;launch&#39;
         * @param {number} [filterEqLaunchId] Filters by &#39;launchId&#39;
         * @param {string} [filterEqLevel] Filters by &#39;level&#39;
         * @param {number} [filterEqLogId] Filters by &#39;logId&#39;
         * @param {Date} [filterEqLogTime] Filters by &#39;logTime&#39;
         * @param {string} [filterEqMessage] Filters by &#39;message&#39;
         * @param {string} [filterEqPath] Filters by &#39;path&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {number} [filterEqRetryParentId] Filters by &#39;retryParentId&#39;
         * @param {number} [filterEqRetryParentLaunchId] Filters by &#39;retryParentLaunchId&#39;
         * @param {string} [filterEqStatus] Filters by &#39;status&#39;
         * @param {string} [filterUnderPath] filter.under.path
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogsUsingGET(projectName: string, filterEqAutoAnalyzed?: boolean, filterEqBinaryContent?: string, filterEqId?: number, filterEqItem?: number, filterEqLastModified?: Date, filterEqLaunch?: number, filterEqLaunchId?: number, filterEqLevel?: string, filterEqLogId?: number, filterEqLogTime?: Date, filterEqMessage?: string, filterEqPath?: string, filterEqProjectId?: number, filterEqRetryParentId?: number, filterEqRetryParentLaunchId?: number, filterEqStatus?: string, filterUnderPath?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<IterableLogResource> {
            const localVarFetchArgs = LogControllerApiFetchParamCreator(configuration).getLogsUsingGET(projectName, filterEqAutoAnalyzed, filterEqBinaryContent, filterEqId, filterEqItem, filterEqLastModified, filterEqLaunch, filterEqLaunchId, filterEqLevel, filterEqLogId, filterEqLogTime, filterEqMessage, filterEqPath, filterEqProjectId, filterEqRetryParentId, filterEqRetryParentLaunchId, filterEqStatus, filterUnderPath, pagePage, pageSize, pageSort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get nested steps with logs for the parent Test Item
         * @param {number} parentId parentId
         * @param {string} projectName projectName
         * @param {boolean} [filterEqAutoAnalyzed] Filters by &#39;autoAnalyzed&#39;
         * @param {string} [filterEqBinaryContent] Filters by &#39;binaryContent&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {number} [filterEqItem] Filters by &#39;item&#39;
         * @param {Date} [filterEqLastModified] Filters by &#39;lastModified&#39;
         * @param {number} [filterEqLaunch] Filters by &#39;launch&#39;
         * @param {number} [filterEqLaunchId] Filters by &#39;launchId&#39;
         * @param {string} [filterEqLevel] Filters by &#39;level&#39;
         * @param {number} [filterEqLogId] Filters by &#39;logId&#39;
         * @param {Date} [filterEqLogTime] Filters by &#39;logTime&#39;
         * @param {string} [filterEqMessage] Filters by &#39;message&#39;
         * @param {string} [filterEqPath] Filters by &#39;path&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {number} [filterEqRetryParentId] Filters by &#39;retryParentId&#39;
         * @param {number} [filterEqRetryParentLaunchId] Filters by &#39;retryParentLaunchId&#39;
         * @param {string} [filterEqStatus] Filters by &#39;status&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {any} [params] params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNestedItemsUsingGET(parentId: number, projectName: string, filterEqAutoAnalyzed?: boolean, filterEqBinaryContent?: string, filterEqId?: number, filterEqItem?: number, filterEqLastModified?: Date, filterEqLaunch?: number, filterEqLaunchId?: number, filterEqLevel?: string, filterEqLogId?: number, filterEqLogTime?: Date, filterEqMessage?: string, filterEqPath?: string, filterEqProjectId?: number, filterEqRetryParentId?: number, filterEqRetryParentLaunchId?: number, filterEqStatus?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, params?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Iterableobject> {
            const localVarFetchArgs = LogControllerApiFetchParamCreator(configuration).getNestedItemsUsingGET(parentId, projectName, filterEqAutoAnalyzed, filterEqBinaryContent, filterEqId, filterEqItem, filterEqLastModified, filterEqLaunch, filterEqLaunchId, filterEqLevel, filterEqLogId, filterEqLogTime, filterEqMessage, filterEqPath, filterEqProjectId, filterEqRetryParentId, filterEqRetryParentLaunchId, filterEqStatus, pagePage, pageSize, pageSort, params, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get logs by filter
         * @param {number} logId logId
         * @param {string} projectName projectName
         * @param {boolean} [filterEqAutoAnalyzed] Filters by &#39;autoAnalyzed&#39;
         * @param {string} [filterEqBinaryContent] Filters by &#39;binaryContent&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {number} [filterEqItem] Filters by &#39;item&#39;
         * @param {Date} [filterEqLastModified] Filters by &#39;lastModified&#39;
         * @param {number} [filterEqLaunch] Filters by &#39;launch&#39;
         * @param {number} [filterEqLaunchId] Filters by &#39;launchId&#39;
         * @param {string} [filterEqLevel] Filters by &#39;level&#39;
         * @param {number} [filterEqLogId] Filters by &#39;logId&#39;
         * @param {Date} [filterEqLogTime] Filters by &#39;logTime&#39;
         * @param {string} [filterEqMessage] Filters by &#39;message&#39;
         * @param {string} [filterEqPath] Filters by &#39;path&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {number} [filterEqRetryParentId] Filters by &#39;retryParentId&#39;
         * @param {number} [filterEqRetryParentLaunchId] Filters by &#39;retryParentLaunchId&#39;
         * @param {string} [filterEqStatus] Filters by &#39;status&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPageNumberUsingGET(logId: number, projectName: string, filterEqAutoAnalyzed?: boolean, filterEqBinaryContent?: string, filterEqId?: number, filterEqItem?: number, filterEqLastModified?: Date, filterEqLaunch?: number, filterEqLaunchId?: number, filterEqLevel?: string, filterEqLogId?: number, filterEqLogTime?: Date, filterEqMessage?: string, filterEqPath?: string, filterEqProjectId?: number, filterEqRetryParentId?: number, filterEqRetryParentLaunchId?: number, filterEqStatus?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{
            [key: string]: Serializable;
        }> {
            const localVarFetchArgs = LogControllerApiFetchParamCreator(configuration).getPageNumberUsingGET(logId, projectName, filterEqAutoAnalyzed, filterEqBinaryContent, filterEqId, filterEqItem, filterEqLastModified, filterEqLaunch, filterEqLaunchId, filterEqLevel, filterEqLogId, filterEqLogTime, filterEqMessage, filterEqPath, filterEqProjectId, filterEqRetryParentId, filterEqRetryParentLaunchId, filterEqStatus, pagePage, pageSize, pageSort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Search test items with similar error logs
         * @param {number} itemId itemId
         * @param {string} projectName projectName
         * @param {SearchLogRq} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchLogsUsingPOST(itemId: number, projectName: string, request: SearchLogRq, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<IterableSearchLogRs> {
            const localVarFetchArgs = LogControllerApiFetchParamCreator(configuration).searchLogsUsingPOST(itemId, projectName, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LogControllerApi - factory interface
 * @export
 */
export const LogControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Create log
         * @param {SaveLogRQ} createLogRQ createLogRQ
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLogEntryUsingPOST1(createLogRQ: SaveLogRQ, projectName: string, options?: any) {
            return LogControllerApiFp(configuration).createLogEntryUsingPOST1(createLogRQ, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create log (batching operation)
         * @param {any} jsonRequestPart json_request_part
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLogUsingPOST1(jsonRequestPart: any, projectName: string, options?: any) {
            return LogControllerApiFp(configuration).createLogUsingPOST1(jsonRequestPart, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete log
         * @param {number} logId logId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLogUsingDELETE(logId: number, projectName: string, options?: any) {
            return LogControllerApiFp(configuration).deleteLogUsingDELETE(logId, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get next or previous log in test item
         * @param {any} params params
         * @param {number} parentId parentId
         * @param {string} projectName projectName
         * @param {boolean} [filterEqAutoAnalyzed] Filters by &#39;autoAnalyzed&#39;
         * @param {string} [filterEqBinaryContent] Filters by &#39;binaryContent&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {number} [filterEqItem] Filters by &#39;item&#39;
         * @param {Date} [filterEqLastModified] Filters by &#39;lastModified&#39;
         * @param {number} [filterEqLaunch] Filters by &#39;launch&#39;
         * @param {number} [filterEqLaunchId] Filters by &#39;launchId&#39;
         * @param {string} [filterEqLevel] Filters by &#39;level&#39;
         * @param {number} [filterEqLogId] Filters by &#39;logId&#39;
         * @param {Date} [filterEqLogTime] Filters by &#39;logTime&#39;
         * @param {string} [filterEqMessage] Filters by &#39;message&#39;
         * @param {string} [filterEqPath] Filters by &#39;path&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {number} [filterEqRetryParentId] Filters by &#39;retryParentId&#39;
         * @param {number} [filterEqRetryParentLaunchId] Filters by &#39;retryParentLaunchId&#39;
         * @param {string} [filterEqStatus] Filters by &#39;status&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getErrorPageUsingGET(params: any, parentId: number, projectName: string, filterEqAutoAnalyzed?: boolean, filterEqBinaryContent?: string, filterEqId?: number, filterEqItem?: number, filterEqLastModified?: Date, filterEqLaunch?: number, filterEqLaunchId?: number, filterEqLevel?: string, filterEqLogId?: number, filterEqLogTime?: Date, filterEqMessage?: string, filterEqPath?: string, filterEqProjectId?: number, filterEqRetryParentId?: number, filterEqRetryParentLaunchId?: number, filterEqStatus?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any) {
            return LogControllerApiFp(configuration).getErrorPageUsingGET(params, parentId, projectName, filterEqAutoAnalyzed, filterEqBinaryContent, filterEqId, filterEqItem, filterEqLastModified, filterEqLaunch, filterEqLaunchId, filterEqLevel, filterEqLogId, filterEqLogTime, filterEqMessage, filterEqPath, filterEqProjectId, filterEqRetryParentId, filterEqRetryParentLaunchId, filterEqStatus, pagePage, pageSize, pageSort, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get log by UUID (Will be removed in version 6.0)
         * @param {string} logId logId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogByUuidUsingGET(logId: string, projectName: string, options?: any) {
            return LogControllerApiFp(configuration).getLogByUuidUsingGET(logId, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get log by ID
         * @param {string} logId logId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogUsingGET(logId: string, projectName: string, options?: any) {
            return LogControllerApiFp(configuration).getLogUsingGET(logId, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get logs under items
         * @param {GetLogsUnderRq} logsUnderRq logsUnderRq
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogsUnderUsingPOST(logsUnderRq: GetLogsUnderRq, projectName: string, options?: any) {
            return LogControllerApiFp(configuration).getLogsUnderUsingPOST(logsUnderRq, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get logs by filter
         * @param {string} projectName projectName
         * @param {boolean} [filterEqAutoAnalyzed] Filters by &#39;autoAnalyzed&#39;
         * @param {string} [filterEqBinaryContent] Filters by &#39;binaryContent&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {number} [filterEqItem] Filters by &#39;item&#39;
         * @param {Date} [filterEqLastModified] Filters by &#39;lastModified&#39;
         * @param {number} [filterEqLaunch] Filters by &#39;launch&#39;
         * @param {number} [filterEqLaunchId] Filters by &#39;launchId&#39;
         * @param {string} [filterEqLevel] Filters by &#39;level&#39;
         * @param {number} [filterEqLogId] Filters by &#39;logId&#39;
         * @param {Date} [filterEqLogTime] Filters by &#39;logTime&#39;
         * @param {string} [filterEqMessage] Filters by &#39;message&#39;
         * @param {string} [filterEqPath] Filters by &#39;path&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {number} [filterEqRetryParentId] Filters by &#39;retryParentId&#39;
         * @param {number} [filterEqRetryParentLaunchId] Filters by &#39;retryParentLaunchId&#39;
         * @param {string} [filterEqStatus] Filters by &#39;status&#39;
         * @param {string} [filterUnderPath] filter.under.path
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogsUsingGET(projectName: string, filterEqAutoAnalyzed?: boolean, filterEqBinaryContent?: string, filterEqId?: number, filterEqItem?: number, filterEqLastModified?: Date, filterEqLaunch?: number, filterEqLaunchId?: number, filterEqLevel?: string, filterEqLogId?: number, filterEqLogTime?: Date, filterEqMessage?: string, filterEqPath?: string, filterEqProjectId?: number, filterEqRetryParentId?: number, filterEqRetryParentLaunchId?: number, filterEqStatus?: string, filterUnderPath?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any) {
            return LogControllerApiFp(configuration).getLogsUsingGET(projectName, filterEqAutoAnalyzed, filterEqBinaryContent, filterEqId, filterEqItem, filterEqLastModified, filterEqLaunch, filterEqLaunchId, filterEqLevel, filterEqLogId, filterEqLogTime, filterEqMessage, filterEqPath, filterEqProjectId, filterEqRetryParentId, filterEqRetryParentLaunchId, filterEqStatus, filterUnderPath, pagePage, pageSize, pageSort, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get nested steps with logs for the parent Test Item
         * @param {number} parentId parentId
         * @param {string} projectName projectName
         * @param {boolean} [filterEqAutoAnalyzed] Filters by &#39;autoAnalyzed&#39;
         * @param {string} [filterEqBinaryContent] Filters by &#39;binaryContent&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {number} [filterEqItem] Filters by &#39;item&#39;
         * @param {Date} [filterEqLastModified] Filters by &#39;lastModified&#39;
         * @param {number} [filterEqLaunch] Filters by &#39;launch&#39;
         * @param {number} [filterEqLaunchId] Filters by &#39;launchId&#39;
         * @param {string} [filterEqLevel] Filters by &#39;level&#39;
         * @param {number} [filterEqLogId] Filters by &#39;logId&#39;
         * @param {Date} [filterEqLogTime] Filters by &#39;logTime&#39;
         * @param {string} [filterEqMessage] Filters by &#39;message&#39;
         * @param {string} [filterEqPath] Filters by &#39;path&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {number} [filterEqRetryParentId] Filters by &#39;retryParentId&#39;
         * @param {number} [filterEqRetryParentLaunchId] Filters by &#39;retryParentLaunchId&#39;
         * @param {string} [filterEqStatus] Filters by &#39;status&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {any} [params] params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNestedItemsUsingGET(parentId: number, projectName: string, filterEqAutoAnalyzed?: boolean, filterEqBinaryContent?: string, filterEqId?: number, filterEqItem?: number, filterEqLastModified?: Date, filterEqLaunch?: number, filterEqLaunchId?: number, filterEqLevel?: string, filterEqLogId?: number, filterEqLogTime?: Date, filterEqMessage?: string, filterEqPath?: string, filterEqProjectId?: number, filterEqRetryParentId?: number, filterEqRetryParentLaunchId?: number, filterEqStatus?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, params?: any, options?: any) {
            return LogControllerApiFp(configuration).getNestedItemsUsingGET(parentId, projectName, filterEqAutoAnalyzed, filterEqBinaryContent, filterEqId, filterEqItem, filterEqLastModified, filterEqLaunch, filterEqLaunchId, filterEqLevel, filterEqLogId, filterEqLogTime, filterEqMessage, filterEqPath, filterEqProjectId, filterEqRetryParentId, filterEqRetryParentLaunchId, filterEqStatus, pagePage, pageSize, pageSort, params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get logs by filter
         * @param {number} logId logId
         * @param {string} projectName projectName
         * @param {boolean} [filterEqAutoAnalyzed] Filters by &#39;autoAnalyzed&#39;
         * @param {string} [filterEqBinaryContent] Filters by &#39;binaryContent&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {number} [filterEqItem] Filters by &#39;item&#39;
         * @param {Date} [filterEqLastModified] Filters by &#39;lastModified&#39;
         * @param {number} [filterEqLaunch] Filters by &#39;launch&#39;
         * @param {number} [filterEqLaunchId] Filters by &#39;launchId&#39;
         * @param {string} [filterEqLevel] Filters by &#39;level&#39;
         * @param {number} [filterEqLogId] Filters by &#39;logId&#39;
         * @param {Date} [filterEqLogTime] Filters by &#39;logTime&#39;
         * @param {string} [filterEqMessage] Filters by &#39;message&#39;
         * @param {string} [filterEqPath] Filters by &#39;path&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {number} [filterEqRetryParentId] Filters by &#39;retryParentId&#39;
         * @param {number} [filterEqRetryParentLaunchId] Filters by &#39;retryParentLaunchId&#39;
         * @param {string} [filterEqStatus] Filters by &#39;status&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPageNumberUsingGET(logId: number, projectName: string, filterEqAutoAnalyzed?: boolean, filterEqBinaryContent?: string, filterEqId?: number, filterEqItem?: number, filterEqLastModified?: Date, filterEqLaunch?: number, filterEqLaunchId?: number, filterEqLevel?: string, filterEqLogId?: number, filterEqLogTime?: Date, filterEqMessage?: string, filterEqPath?: string, filterEqProjectId?: number, filterEqRetryParentId?: number, filterEqRetryParentLaunchId?: number, filterEqStatus?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any) {
            return LogControllerApiFp(configuration).getPageNumberUsingGET(logId, projectName, filterEqAutoAnalyzed, filterEqBinaryContent, filterEqId, filterEqItem, filterEqLastModified, filterEqLaunch, filterEqLaunchId, filterEqLevel, filterEqLogId, filterEqLogTime, filterEqMessage, filterEqPath, filterEqProjectId, filterEqRetryParentId, filterEqRetryParentLaunchId, filterEqStatus, pagePage, pageSize, pageSort, options)(fetch, basePath);
        },
        /**
         *
         * @summary Search test items with similar error logs
         * @param {number} itemId itemId
         * @param {string} projectName projectName
         * @param {SearchLogRq} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchLogsUsingPOST(itemId: number, projectName: string, request: SearchLogRq, options?: any) {
            return LogControllerApiFp(configuration).searchLogsUsingPOST(itemId, projectName, request, options)(fetch, basePath);
        },
    };
};

/**
 * LogControllerApi - object-oriented interface
 * @export
 * @class LogControllerApi
 * @extends {BaseAPI}
 */
export class LogControllerApi extends BaseAPI {
    /**
     *
     * @summary Create log
     * @param {SaveLogRQ} createLogRQ createLogRQ
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogControllerApi
     */
    public createLogEntryUsingPOST1(createLogRQ: SaveLogRQ, projectName: string, options?: any) {
        return LogControllerApiFp(this.configuration).createLogEntryUsingPOST1(createLogRQ, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Create log (batching operation)
     * @param {any} jsonRequestPart json_request_part
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogControllerApi
     */
    public createLogUsingPOST1(jsonRequestPart: any, projectName: string, options?: any) {
        return LogControllerApiFp(this.configuration).createLogUsingPOST1(jsonRequestPart, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete log
     * @param {number} logId logId
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogControllerApi
     */
    public deleteLogUsingDELETE(logId: number, projectName: string, options?: any) {
        return LogControllerApiFp(this.configuration).deleteLogUsingDELETE(logId, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get next or previous log in test item
     * @param {any} params params
     * @param {number} parentId parentId
     * @param {string} projectName projectName
     * @param {boolean} [filterEqAutoAnalyzed] Filters by &#39;autoAnalyzed&#39;
     * @param {string} [filterEqBinaryContent] Filters by &#39;binaryContent&#39;
     * @param {number} [filterEqId] Filters by &#39;id&#39;
     * @param {number} [filterEqItem] Filters by &#39;item&#39;
     * @param {Date} [filterEqLastModified] Filters by &#39;lastModified&#39;
     * @param {number} [filterEqLaunch] Filters by &#39;launch&#39;
     * @param {number} [filterEqLaunchId] Filters by &#39;launchId&#39;
     * @param {string} [filterEqLevel] Filters by &#39;level&#39;
     * @param {number} [filterEqLogId] Filters by &#39;logId&#39;
     * @param {Date} [filterEqLogTime] Filters by &#39;logTime&#39;
     * @param {string} [filterEqMessage] Filters by &#39;message&#39;
     * @param {string} [filterEqPath] Filters by &#39;path&#39;
     * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
     * @param {number} [filterEqRetryParentId] Filters by &#39;retryParentId&#39;
     * @param {number} [filterEqRetryParentLaunchId] Filters by &#39;retryParentLaunchId&#39;
     * @param {string} [filterEqStatus] Filters by &#39;status&#39;
     * @param {number} [pagePage] Results page you want to retrieve (0..N)
     * @param {number} [pageSize] Number of records per page
     * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogControllerApi
     */
    public getErrorPageUsingGET(params: any, parentId: number, projectName: string, filterEqAutoAnalyzed?: boolean, filterEqBinaryContent?: string, filterEqId?: number, filterEqItem?: number, filterEqLastModified?: Date, filterEqLaunch?: number, filterEqLaunchId?: number, filterEqLevel?: string, filterEqLogId?: number, filterEqLogTime?: Date, filterEqMessage?: string, filterEqPath?: string, filterEqProjectId?: number, filterEqRetryParentId?: number, filterEqRetryParentLaunchId?: number, filterEqStatus?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any) {
        return LogControllerApiFp(this.configuration).getErrorPageUsingGET(params, parentId, projectName, filterEqAutoAnalyzed, filterEqBinaryContent, filterEqId, filterEqItem, filterEqLastModified, filterEqLaunch, filterEqLaunchId, filterEqLevel, filterEqLogId, filterEqLogTime, filterEqMessage, filterEqPath, filterEqProjectId, filterEqRetryParentId, filterEqRetryParentLaunchId, filterEqStatus, pagePage, pageSize, pageSort, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get log by UUID (Will be removed in version 6.0)
     * @param {string} logId logId
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogControllerApi
     */
    public getLogByUuidUsingGET(logId: string, projectName: string, options?: any) {
        return LogControllerApiFp(this.configuration).getLogByUuidUsingGET(logId, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get log by ID
     * @param {string} logId logId
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogControllerApi
     */
    public getLogUsingGET(logId: string, projectName: string, options?: any) {
        return LogControllerApiFp(this.configuration).getLogUsingGET(logId, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get logs under items
     * @param {GetLogsUnderRq} logsUnderRq logsUnderRq
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogControllerApi
     */
    public getLogsUnderUsingPOST(logsUnderRq: GetLogsUnderRq, projectName: string, options?: any) {
        return LogControllerApiFp(this.configuration).getLogsUnderUsingPOST(logsUnderRq, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get logs by filter
     * @param {string} projectName projectName
     * @param {boolean} [filterEqAutoAnalyzed] Filters by &#39;autoAnalyzed&#39;
     * @param {string} [filterEqBinaryContent] Filters by &#39;binaryContent&#39;
     * @param {number} [filterEqId] Filters by &#39;id&#39;
     * @param {number} [filterEqItem] Filters by &#39;item&#39;
     * @param {Date} [filterEqLastModified] Filters by &#39;lastModified&#39;
     * @param {number} [filterEqLaunch] Filters by &#39;launch&#39;
     * @param {number} [filterEqLaunchId] Filters by &#39;launchId&#39;
     * @param {string} [filterEqLevel] Filters by &#39;level&#39;
     * @param {number} [filterEqLogId] Filters by &#39;logId&#39;
     * @param {Date} [filterEqLogTime] Filters by &#39;logTime&#39;
     * @param {string} [filterEqMessage] Filters by &#39;message&#39;
     * @param {string} [filterEqPath] Filters by &#39;path&#39;
     * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
     * @param {number} [filterEqRetryParentId] Filters by &#39;retryParentId&#39;
     * @param {number} [filterEqRetryParentLaunchId] Filters by &#39;retryParentLaunchId&#39;
     * @param {string} [filterEqStatus] Filters by &#39;status&#39;
     * @param {string} [filterUnderPath] filter.under.path
     * @param {number} [pagePage] Results page you want to retrieve (0..N)
     * @param {number} [pageSize] Number of records per page
     * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogControllerApi
     */
    public getLogsUsingGET(projectName: string, filterEqAutoAnalyzed?: boolean, filterEqBinaryContent?: string, filterEqId?: number, filterEqItem?: number, filterEqLastModified?: Date, filterEqLaunch?: number, filterEqLaunchId?: number, filterEqLevel?: string, filterEqLogId?: number, filterEqLogTime?: Date, filterEqMessage?: string, filterEqPath?: string, filterEqProjectId?: number, filterEqRetryParentId?: number, filterEqRetryParentLaunchId?: number, filterEqStatus?: string, filterUnderPath?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any) {
        return LogControllerApiFp(this.configuration).getLogsUsingGET(projectName, filterEqAutoAnalyzed, filterEqBinaryContent, filterEqId, filterEqItem, filterEqLastModified, filterEqLaunch, filterEqLaunchId, filterEqLevel, filterEqLogId, filterEqLogTime, filterEqMessage, filterEqPath, filterEqProjectId, filterEqRetryParentId, filterEqRetryParentLaunchId, filterEqStatus, filterUnderPath, pagePage, pageSize, pageSort, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get nested steps with logs for the parent Test Item
     * @param {number} parentId parentId
     * @param {string} projectName projectName
     * @param {boolean} [filterEqAutoAnalyzed] Filters by &#39;autoAnalyzed&#39;
     * @param {string} [filterEqBinaryContent] Filters by &#39;binaryContent&#39;
     * @param {number} [filterEqId] Filters by &#39;id&#39;
     * @param {number} [filterEqItem] Filters by &#39;item&#39;
     * @param {Date} [filterEqLastModified] Filters by &#39;lastModified&#39;
     * @param {number} [filterEqLaunch] Filters by &#39;launch&#39;
     * @param {number} [filterEqLaunchId] Filters by &#39;launchId&#39;
     * @param {string} [filterEqLevel] Filters by &#39;level&#39;
     * @param {number} [filterEqLogId] Filters by &#39;logId&#39;
     * @param {Date} [filterEqLogTime] Filters by &#39;logTime&#39;
     * @param {string} [filterEqMessage] Filters by &#39;message&#39;
     * @param {string} [filterEqPath] Filters by &#39;path&#39;
     * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
     * @param {number} [filterEqRetryParentId] Filters by &#39;retryParentId&#39;
     * @param {number} [filterEqRetryParentLaunchId] Filters by &#39;retryParentLaunchId&#39;
     * @param {string} [filterEqStatus] Filters by &#39;status&#39;
     * @param {number} [pagePage] Results page you want to retrieve (0..N)
     * @param {number} [pageSize] Number of records per page
     * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {any} [params] params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogControllerApi
     */
    public getNestedItemsUsingGET(parentId: number, projectName: string, filterEqAutoAnalyzed?: boolean, filterEqBinaryContent?: string, filterEqId?: number, filterEqItem?: number, filterEqLastModified?: Date, filterEqLaunch?: number, filterEqLaunchId?: number, filterEqLevel?: string, filterEqLogId?: number, filterEqLogTime?: Date, filterEqMessage?: string, filterEqPath?: string, filterEqProjectId?: number, filterEqRetryParentId?: number, filterEqRetryParentLaunchId?: number, filterEqStatus?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, params?: any, options?: any) {
        return LogControllerApiFp(this.configuration).getNestedItemsUsingGET(parentId, projectName, filterEqAutoAnalyzed, filterEqBinaryContent, filterEqId, filterEqItem, filterEqLastModified, filterEqLaunch, filterEqLaunchId, filterEqLevel, filterEqLogId, filterEqLogTime, filterEqMessage, filterEqPath, filterEqProjectId, filterEqRetryParentId, filterEqRetryParentLaunchId, filterEqStatus, pagePage, pageSize, pageSort, params, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get logs by filter
     * @param {number} logId logId
     * @param {string} projectName projectName
     * @param {boolean} [filterEqAutoAnalyzed] Filters by &#39;autoAnalyzed&#39;
     * @param {string} [filterEqBinaryContent] Filters by &#39;binaryContent&#39;
     * @param {number} [filterEqId] Filters by &#39;id&#39;
     * @param {number} [filterEqItem] Filters by &#39;item&#39;
     * @param {Date} [filterEqLastModified] Filters by &#39;lastModified&#39;
     * @param {number} [filterEqLaunch] Filters by &#39;launch&#39;
     * @param {number} [filterEqLaunchId] Filters by &#39;launchId&#39;
     * @param {string} [filterEqLevel] Filters by &#39;level&#39;
     * @param {number} [filterEqLogId] Filters by &#39;logId&#39;
     * @param {Date} [filterEqLogTime] Filters by &#39;logTime&#39;
     * @param {string} [filterEqMessage] Filters by &#39;message&#39;
     * @param {string} [filterEqPath] Filters by &#39;path&#39;
     * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
     * @param {number} [filterEqRetryParentId] Filters by &#39;retryParentId&#39;
     * @param {number} [filterEqRetryParentLaunchId] Filters by &#39;retryParentLaunchId&#39;
     * @param {string} [filterEqStatus] Filters by &#39;status&#39;
     * @param {number} [pagePage] Results page you want to retrieve (0..N)
     * @param {number} [pageSize] Number of records per page
     * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogControllerApi
     */
    public getPageNumberUsingGET(logId: number, projectName: string, filterEqAutoAnalyzed?: boolean, filterEqBinaryContent?: string, filterEqId?: number, filterEqItem?: number, filterEqLastModified?: Date, filterEqLaunch?: number, filterEqLaunchId?: number, filterEqLevel?: string, filterEqLogId?: number, filterEqLogTime?: Date, filterEqMessage?: string, filterEqPath?: string, filterEqProjectId?: number, filterEqRetryParentId?: number, filterEqRetryParentLaunchId?: number, filterEqStatus?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any) {
        return LogControllerApiFp(this.configuration).getPageNumberUsingGET(logId, projectName, filterEqAutoAnalyzed, filterEqBinaryContent, filterEqId, filterEqItem, filterEqLastModified, filterEqLaunch, filterEqLaunchId, filterEqLevel, filterEqLogId, filterEqLogTime, filterEqMessage, filterEqPath, filterEqProjectId, filterEqRetryParentId, filterEqRetryParentLaunchId, filterEqStatus, pagePage, pageSize, pageSort, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Search test items with similar error logs
     * @param {number} itemId itemId
     * @param {string} projectName projectName
     * @param {SearchLogRq} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogControllerApi
     */
    public searchLogsUsingPOST(itemId: number, projectName: string, request: SearchLogRq, options?: any) {
        return LogControllerApiFp(this.configuration).searchLogsUsingPOST(itemId, projectName, request, options)(this.fetch, this.basePath);
    }

}

/**
 * OnboardingControllerApi - fetch parameter creator
 * @export
 */
export const OnboardingControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Return onboarding information for page if available, -1 otherwise
         * @param {string} [page] page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        onBoardingUsingGET(page?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v1/onboarding`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OnboardingControllerApi - functional programming interface
 * @export
 */
export const OnboardingControllerApiFp = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Return onboarding information for page if available, -1 otherwise
         * @param {string} [page] page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        onBoardingUsingGET(page?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = OnboardingControllerApiFetchParamCreator(configuration).onBoardingUsingGET(page, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OnboardingControllerApi - factory interface
 * @export
 */
export const OnboardingControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Return onboarding information for page if available, -1 otherwise
         * @param {string} [page] page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        onBoardingUsingGET(page?: string, options?: any) {
            return OnboardingControllerApiFp(configuration).onBoardingUsingGET(page, options)(fetch, basePath);
        },
    };
};

/**
 * OnboardingControllerApi - object-oriented interface
 * @export
 * @class OnboardingControllerApi
 * @extends {BaseAPI}
 */
export class OnboardingControllerApi extends BaseAPI {
    /**
     *
     * @summary Return onboarding information for page if available, -1 otherwise
     * @param {string} [page] page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OnboardingControllerApi
     */
    public onBoardingUsingGET(page?: string, options?: any) {
        return OnboardingControllerApiFp(this.configuration).onBoardingUsingGET(page, options)(this.fetch, this.basePath);
    }

}

/**
 * PluginControllerApi - fetch parameter creator
 * @export
 */
export const PluginControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Delete plugin by id
         * @param {number} pluginId pluginId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePluginUsingDELETE(pluginId: number, options: any = {}): FetchArgs {
            // verify required parameter 'pluginId' is not null or undefined
            if (pluginId === null || pluginId === undefined) {
                throw new RequiredError('pluginId', 'Required parameter pluginId was null or undefined when calling deletePluginUsingDELETE.');
            }
            const localVarPath = `/v1/plugin/{pluginId}`
                .replace(`{${"pluginId"}}`, encodeURIComponent(String(pluginId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'DELETE'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Execute command to the plugin instance
         * @param {string} command command
         * @param {any} executionParams executionParams
         * @param {string} pluginName pluginName
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePluginCommandUsingPUT(command: string, executionParams: any, pluginName: string, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'command' is not null or undefined
            if (command === null || command === undefined) {
                throw new RequiredError('command', 'Required parameter command was null or undefined when calling executePluginCommandUsingPUT.');
            }
            // verify required parameter 'executionParams' is not null or undefined
            if (executionParams === null || executionParams === undefined) {
                throw new RequiredError('executionParams', 'Required parameter executionParams was null or undefined when calling executePluginCommandUsingPUT.');
            }
            // verify required parameter 'pluginName' is not null or undefined
            if (pluginName === null || pluginName === undefined) {
                throw new RequiredError('pluginName', 'Required parameter pluginName was null or undefined when calling executePluginCommandUsingPUT.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling executePluginCommandUsingPUT.');
            }
            const localVarPath = `/v1/plugin/{projectName}/{pluginName}/common/{command}`
                .replace(`{${"command"}}`, encodeURIComponent(String(command)))
                .replace(`{${"pluginName"}}`, encodeURIComponent(String(pluginName)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'PUT'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(executionParams || {}) : (executionParams || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all available plugins
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginsUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/v1/plugin`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update Report Portal plugin state
         * @param {number} pluginId pluginId
         * @param {UpdatePluginStateRQ} updatePluginStateRQ updatePluginStateRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePluginStateUsingPUT(pluginId: number, updatePluginStateRQ: UpdatePluginStateRQ, options: any = {}): FetchArgs {
            // verify required parameter 'pluginId' is not null or undefined
            if (pluginId === null || pluginId === undefined) {
                throw new RequiredError('pluginId', 'Required parameter pluginId was null or undefined when calling updatePluginStateUsingPUT.');
            }
            // verify required parameter 'updatePluginStateRQ' is not null or undefined
            if (updatePluginStateRQ === null || updatePluginStateRQ === undefined) {
                throw new RequiredError('updatePluginStateRQ', 'Required parameter updatePluginStateRQ was null or undefined when calling updatePluginStateUsingPUT.');
            }
            const localVarPath = `/v1/plugin/{pluginId}`
                .replace(`{${"pluginId"}}`, encodeURIComponent(String(pluginId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'PUT'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdatePluginStateRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(updatePluginStateRQ || {}) : (updatePluginStateRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Upload new Report Portal plugin
         * @param {any} file file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPluginUsingPOST(file: any, options: any = {}): FetchArgs {
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file', 'Required parameter file was null or undefined when calling uploadPluginUsingPOST.');
            }
            const localVarPath = `/v1/plugin`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PluginControllerApi - functional programming interface
 * @export
 */
export const PluginControllerApiFp = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Delete plugin by id
         * @param {number} pluginId pluginId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePluginUsingDELETE(pluginId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = PluginControllerApiFetchParamCreator(configuration).deletePluginUsingDELETE(pluginId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Execute command to the plugin instance
         * @param {string} command command
         * @param {any} executionParams executionParams
         * @param {string} pluginName pluginName
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePluginCommandUsingPUT(command: string, executionParams: any, pluginName: string, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = PluginControllerApiFetchParamCreator(configuration).executePluginCommandUsingPUT(command, executionParams, pluginName, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all available plugins
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginsUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<IntegrationTypeResource>> {
            const localVarFetchArgs = PluginControllerApiFetchParamCreator(configuration).getPluginsUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update Report Portal plugin state
         * @param {number} pluginId pluginId
         * @param {UpdatePluginStateRQ} updatePluginStateRQ updatePluginStateRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePluginStateUsingPUT(pluginId: number, updatePluginStateRQ: UpdatePluginStateRQ, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = PluginControllerApiFetchParamCreator(configuration).updatePluginStateUsingPUT(pluginId, updatePluginStateRQ, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Upload new Report Portal plugin
         * @param {any} file file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPluginUsingPOST(file: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EntryCreatedRS> {
            const localVarFetchArgs = PluginControllerApiFetchParamCreator(configuration).uploadPluginUsingPOST(file, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PluginControllerApi - factory interface
 * @export
 */
export const PluginControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Delete plugin by id
         * @param {number} pluginId pluginId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePluginUsingDELETE(pluginId: number, options?: any) {
            return PluginControllerApiFp(configuration).deletePluginUsingDELETE(pluginId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Execute command to the plugin instance
         * @param {string} command command
         * @param {any} executionParams executionParams
         * @param {string} pluginName pluginName
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePluginCommandUsingPUT(command: string, executionParams: any, pluginName: string, projectName: string, options?: any) {
            return PluginControllerApiFp(configuration).executePluginCommandUsingPUT(command, executionParams, pluginName, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get all available plugins
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginsUsingGET(options?: any) {
            return PluginControllerApiFp(configuration).getPluginsUsingGET(options)(fetch, basePath);
        },
        /**
         *
         * @summary Update Report Portal plugin state
         * @param {number} pluginId pluginId
         * @param {UpdatePluginStateRQ} updatePluginStateRQ updatePluginStateRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePluginStateUsingPUT(pluginId: number, updatePluginStateRQ: UpdatePluginStateRQ, options?: any) {
            return PluginControllerApiFp(configuration).updatePluginStateUsingPUT(pluginId, updatePluginStateRQ, options)(fetch, basePath);
        },
        /**
         *
         * @summary Upload new Report Portal plugin
         * @param {any} file file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPluginUsingPOST(file: any, options?: any) {
            return PluginControllerApiFp(configuration).uploadPluginUsingPOST(file, options)(fetch, basePath);
        },
    };
};

/**
 * PluginControllerApi - object-oriented interface
 * @export
 * @class PluginControllerApi
 * @extends {BaseAPI}
 */
export class PluginControllerApi extends BaseAPI {
    /**
     *
     * @summary Delete plugin by id
     * @param {number} pluginId pluginId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginControllerApi
     */
    public deletePluginUsingDELETE(pluginId: number, options?: any) {
        return PluginControllerApiFp(this.configuration).deletePluginUsingDELETE(pluginId, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Execute command to the plugin instance
     * @param {string} command command
     * @param {any} executionParams executionParams
     * @param {string} pluginName pluginName
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginControllerApi
     */
    public executePluginCommandUsingPUT(command: string, executionParams: any, pluginName: string, projectName: string, options?: any) {
        return PluginControllerApiFp(this.configuration).executePluginCommandUsingPUT(command, executionParams, pluginName, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get all available plugins
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginControllerApi
     */
    public getPluginsUsingGET(options?: any) {
        return PluginControllerApiFp(this.configuration).getPluginsUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Update Report Portal plugin state
     * @param {number} pluginId pluginId
     * @param {UpdatePluginStateRQ} updatePluginStateRQ updatePluginStateRQ
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginControllerApi
     */
    public updatePluginStateUsingPUT(pluginId: number, updatePluginStateRQ: UpdatePluginStateRQ, options?: any) {
        return PluginControllerApiFp(this.configuration).updatePluginStateUsingPUT(pluginId, updatePluginStateRQ, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Upload new Report Portal plugin
     * @param {any} file file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginControllerApi
     */
    public uploadPluginUsingPOST(file: any, options?: any) {
        return PluginControllerApiFp(this.configuration).uploadPluginUsingPOST(file, options)(this.fetch, this.basePath);
    }

}

/**
 * PluginPublicControllerApi - fetch parameter creator
 * @export
 */
export const PluginPublicControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Execute public command without authentication
         * @param {string} command command
         * @param {any} executionParams executionParams
         * @param {string} pluginName pluginName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePublicPluginCommandUsingPUT(command: string, executionParams: any, pluginName: string, options: any = {}): FetchArgs {
            // verify required parameter 'command' is not null or undefined
            if (command === null || command === undefined) {
                throw new RequiredError('command', 'Required parameter command was null or undefined when calling executePublicPluginCommandUsingPUT.');
            }
            // verify required parameter 'executionParams' is not null or undefined
            if (executionParams === null || executionParams === undefined) {
                throw new RequiredError('executionParams', 'Required parameter executionParams was null or undefined when calling executePublicPluginCommandUsingPUT.');
            }
            // verify required parameter 'pluginName' is not null or undefined
            if (pluginName === null || pluginName === undefined) {
                throw new RequiredError('pluginName', 'Required parameter pluginName was null or undefined when calling executePublicPluginCommandUsingPUT.');
            }
            const localVarPath = `/v1/plugin/public/{pluginName}/{command}`
                .replace(`{${"command"}}`, encodeURIComponent(String(command)))
                .replace(`{${"pluginName"}}`, encodeURIComponent(String(pluginName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'PUT'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(executionParams || {}) : (executionParams || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all available public plugins
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginsUsingGET1(options: any = {}): FetchArgs {
            const localVarPath = `/v1/plugin/public`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get public plugin file without authentication
         * @param {string} name name
         * @param {string} pluginName pluginName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicFileUsingGET(name: string, pluginName: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name', 'Required parameter name was null or undefined when calling getPublicFileUsingGET.');
            }
            // verify required parameter 'pluginName' is not null or undefined
            if (pluginName === null || pluginName === undefined) {
                throw new RequiredError('pluginName', 'Required parameter pluginName was null or undefined when calling getPublicFileUsingGET.');
            }
            const localVarPath = `/v1/plugin/public/{pluginName}/file/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"pluginName"}}`, encodeURIComponent(String(pluginName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PluginPublicControllerApi - functional programming interface
 * @export
 */
export const PluginPublicControllerApiFp = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Execute public command without authentication
         * @param {string} command command
         * @param {any} executionParams executionParams
         * @param {string} pluginName pluginName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePublicPluginCommandUsingPUT(command: string, executionParams: any, pluginName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = PluginPublicControllerApiFetchParamCreator(configuration).executePublicPluginCommandUsingPUT(command, executionParams, pluginName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all available public plugins
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginsUsingGET1(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<IntegrationTypeResource>> {
            const localVarFetchArgs = PluginPublicControllerApiFetchParamCreator(configuration).getPluginsUsingGET1(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get public plugin file without authentication
         * @param {string} name name
         * @param {string} pluginName pluginName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicFileUsingGET(name: string, pluginName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PluginPublicControllerApiFetchParamCreator(configuration).getPublicFileUsingGET(name, pluginName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PluginPublicControllerApi - factory interface
 * @export
 */
export const PluginPublicControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Execute public command without authentication
         * @param {string} command command
         * @param {any} executionParams executionParams
         * @param {string} pluginName pluginName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executePublicPluginCommandUsingPUT(command: string, executionParams: any, pluginName: string, options?: any) {
            return PluginPublicControllerApiFp(configuration).executePublicPluginCommandUsingPUT(command, executionParams, pluginName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get all available public plugins
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginsUsingGET1(options?: any) {
            return PluginPublicControllerApiFp(configuration).getPluginsUsingGET1(options)(fetch, basePath);
        },
        /**
         *
         * @summary Get public plugin file without authentication
         * @param {string} name name
         * @param {string} pluginName pluginName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicFileUsingGET(name: string, pluginName: string, options?: any) {
            return PluginPublicControllerApiFp(configuration).getPublicFileUsingGET(name, pluginName, options)(fetch, basePath);
        },
    };
};

/**
 * PluginPublicControllerApi - object-oriented interface
 * @export
 * @class PluginPublicControllerApi
 * @extends {BaseAPI}
 */
export class PluginPublicControllerApi extends BaseAPI {
    /**
     *
     * @summary Execute public command without authentication
     * @param {string} command command
     * @param {any} executionParams executionParams
     * @param {string} pluginName pluginName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginPublicControllerApi
     */
    public executePublicPluginCommandUsingPUT(command: string, executionParams: any, pluginName: string, options?: any) {
        return PluginPublicControllerApiFp(this.configuration).executePublicPluginCommandUsingPUT(command, executionParams, pluginName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get all available public plugins
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginPublicControllerApi
     */
    public getPluginsUsingGET1(options?: any) {
        return PluginPublicControllerApiFp(this.configuration).getPluginsUsingGET1(options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get public plugin file without authentication
     * @param {string} name name
     * @param {string} pluginName pluginName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginPublicControllerApi
     */
    public getPublicFileUsingGET(name: string, pluginName: string, options?: any) {
        return PluginPublicControllerApiFp(this.configuration).getPublicFileUsingGET(name, pluginName, options)(this.fetch, this.basePath);
    }

}

/**
 * ProjectControllerApi - fetch parameter creator
 * @export
 */
export const ProjectControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary addUserPreference
         * @param {number} filterId filterId
         * @param {string} login login
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserPreferenceUsingPUT(filterId: number, login: string, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'filterId' is not null or undefined
            if (filterId === null || filterId === undefined) {
                throw new RequiredError('filterId', 'Required parameter filterId was null or undefined when calling addUserPreferenceUsingPUT.');
            }
            // verify required parameter 'login' is not null or undefined
            if (login === null || login === undefined) {
                throw new RequiredError('login', 'Required parameter login was null or undefined when calling addUserPreferenceUsingPUT.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling addUserPreferenceUsingPUT.');
            }
            const localVarPath = `/v1/project/{projectName}/preference/{login}/{filterId}`
                .replace(`{${"filterId"}}`, encodeURIComponent(String(filterId)))
                .replace(`{${"login"}}`, encodeURIComponent(String(login)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'PUT'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Assign users
         * @param {AssignUsersRQ} assignUsersRQ assignUsersRQ
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignProjectUsersUsingPUT(assignUsersRQ: AssignUsersRQ, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'assignUsersRQ' is not null or undefined
            if (assignUsersRQ === null || assignUsersRQ === undefined) {
                throw new RequiredError('assignUsersRQ', 'Required parameter assignUsersRQ was null or undefined when calling assignProjectUsersUsingPUT.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling assignProjectUsersUsingPUT.');
            }
            const localVarPath = `/v1/project/{projectName}/assign`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'PUT'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AssignUsersRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(assignUsersRQ || {}) : (assignUsersRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create new project
         * @param {CreateProjectRQ} createProjectRQ createProjectRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectUsingPOST(createProjectRQ: CreateProjectRQ, options: any = {}): FetchArgs {
            // verify required parameter 'createProjectRQ' is not null or undefined
            if (createProjectRQ === null || createProjectRQ === undefined) {
                throw new RequiredError('createProjectRQ', 'Required parameter createProjectRQ was null or undefined when calling createProjectUsingPOST.');
            }
            const localVarPath = `/v1/project`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateProjectRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(createProjectRQ || {}) : (createProjectRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete project index from ML
         * @param {string} projectName projectName
         * @param {string} [name]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectIndexUsingDELETE(projectName: string, name?: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling deleteProjectIndexUsingDELETE.');
            }
            const localVarPath = `/v1/project/{projectName}/index`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'DELETE'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Could be deleted only by users with administrator role
         * @summary Delete project
         * @param {number} projectId projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectUsingDELETE(projectId: number, options: any = {}): FetchArgs {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId', 'Required parameter projectId was null or undefined when calling deleteProjectUsingDELETE.');
            }
            const localVarPath = `/v1/project/{projectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'DELETE'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Could be deleted only by users with administrator role
         * @summary Delete multiple projects
         * @param {DeleteBulkRQ} deleteBulkRQ deleteBulkRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectUsingDELETE1(deleteBulkRQ: DeleteBulkRQ, options: any = {}): FetchArgs {
            // verify required parameter 'deleteBulkRQ' is not null or undefined
            if (deleteBulkRQ === null || deleteBulkRQ === undefined) {
                throw new RequiredError('deleteBulkRQ', 'Required parameter deleteBulkRQ was null or undefined when calling deleteProjectUsingDELETE1.');
            }
            const localVarPath = `/v1/project`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'DELETE'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DeleteBulkRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(deleteBulkRQ || {}) : (deleteBulkRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allowable only for users with administrator role
         * @summary Exports information about all projects
         * @param {Date} [filterEqCreationDate] Filters by &#39;creationDate&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {Date} [filterEqLastRun] Filters by &#39;lastRun&#39;
         * @param {number} [filterEqLaunchesQuantity] Filters by &#39;launchesQuantity&#39;
         * @param {string} [filterEqName] Filters by &#39;name&#39;
         * @param {string} [filterEqOrganization] Filters by &#39;organization&#39;
         * @param {string} [filterEqType] Filters by &#39;type&#39;
         * @param {number} [filterEqUsersQuantity] Filters by &#39;usersQuantity&#39;
         * @param {'csv'} [view] view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportProjectsUsingGET(filterEqCreationDate?: Date, filterEqId?: number, filterEqLastRun?: Date, filterEqLaunchesQuantity?: number, filterEqName?: string, filterEqOrganization?: string, filterEqType?: string, filterEqUsersQuantity?: number, view?: 'csv', options: any = {}): FetchArgs {
            const localVarPath = `/v1/project/export`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filterEqCreationDate !== undefined) {
                localVarQueryParameter['filter.eq.creationDate'] = (filterEqCreationDate as any).toISOString();
            }

            if (filterEqId !== undefined) {
                localVarQueryParameter['filter.eq.id'] = filterEqId;
            }

            if (filterEqLastRun !== undefined) {
                localVarQueryParameter['filter.eq.lastRun'] = (filterEqLastRun as any).toISOString();
            }

            if (filterEqLaunchesQuantity !== undefined) {
                localVarQueryParameter['filter.eq.launchesQuantity'] = filterEqLaunchesQuantity;
            }

            if (filterEqName !== undefined) {
                localVarQueryParameter['filter.eq.name'] = filterEqName;
            }

            if (filterEqOrganization !== undefined) {
                localVarQueryParameter['filter.eq.organization'] = filterEqOrganization;
            }

            if (filterEqType !== undefined) {
                localVarQueryParameter['filter.eq.type'] = filterEqType;
            }

            if (filterEqUsersQuantity !== undefined) {
                localVarQueryParameter['filter.eq.usersQuantity'] = filterEqUsersQuantity;
            }

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary getAllProjectNames
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProjectNamesUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/v1/project/names`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary getAllProjectsInfo
         * @param {Date} [filterEqCreationDate] Filters by &#39;creationDate&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {Date} [filterEqLastRun] Filters by &#39;lastRun&#39;
         * @param {number} [filterEqLaunchesQuantity] Filters by &#39;launchesQuantity&#39;
         * @param {string} [filterEqName] Filters by &#39;name&#39;
         * @param {string} [filterEqOrganization] Filters by &#39;organization&#39;
         * @param {string} [filterEqType] Filters by &#39;type&#39;
         * @param {number} [filterEqUsersQuantity] Filters by &#39;usersQuantity&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProjectsInfoUsingGET(filterEqCreationDate?: Date, filterEqId?: number, filterEqLastRun?: Date, filterEqLaunchesQuantity?: number, filterEqName?: string, filterEqOrganization?: string, filterEqType?: string, filterEqUsersQuantity?: number, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/v1/project/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filterEqCreationDate !== undefined) {
                localVarQueryParameter['filter.eq.creationDate'] = (filterEqCreationDate as any).toISOString();
            }

            if (filterEqId !== undefined) {
                localVarQueryParameter['filter.eq.id'] = filterEqId;
            }

            if (filterEqLastRun !== undefined) {
                localVarQueryParameter['filter.eq.lastRun'] = (filterEqLastRun as any).toISOString();
            }

            if (filterEqLaunchesQuantity !== undefined) {
                localVarQueryParameter['filter.eq.launchesQuantity'] = filterEqLaunchesQuantity;
            }

            if (filterEqName !== undefined) {
                localVarQueryParameter['filter.eq.name'] = filterEqName;
            }

            if (filterEqOrganization !== undefined) {
                localVarQueryParameter['filter.eq.organization'] = filterEqOrganization;
            }

            if (filterEqType !== undefined) {
                localVarQueryParameter['filter.eq.type'] = filterEqType;
            }

            if (filterEqUsersQuantity !== undefined) {
                localVarQueryParameter['filter.eq.usersQuantity'] = filterEqUsersQuantity;
            }

            if (pagePage !== undefined) {
                localVarQueryParameter['page.page'] = pagePage;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page.size'] = pageSize;
            }

            if (pageSort) {
                localVarQueryParameter['page.sort'] = pageSort;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary getAnalyzerIndexingStatus
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalyzerIndexingStatusUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/v1/project/analyzer/status`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary getProjectInfo
         * @param {string} projectName projectName
         * @param {string} [interval] interval
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectInfoUsingGET(projectName: string, interval?: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getProjectInfoUsingGET.');
            }
            const localVarPath = `/v1/project/list/{projectName}`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only for users that are members of the project
         * @summary Load project users by filter
         * @param {string} filterCntUsers filter.cnt.users
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectUsersUsingGET(filterCntUsers: string, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'filterCntUsers' is not null or undefined
            if (filterCntUsers === null || filterCntUsers === undefined) {
                throw new RequiredError('filterCntUsers', 'Required parameter filterCntUsers was null or undefined when calling getProjectUsersUsingGET.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getProjectUsersUsingGET.');
            }
            const localVarPath = `/v1/project/{projectName}/usernames`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filterCntUsers !== undefined) {
                localVarQueryParameter['filter.cnt.users'] = filterCntUsers;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get users assigned on current project
         * @param {string} projectName projectName
         * @param {string} [filterEqEmail] Filters by &#39;email&#39;
         * @param {boolean} [filterEqExpired] Filters by &#39;expired&#39;
         * @param {string} [filterEqFullName] Filters by &#39;fullName&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {number} [filterEqLastLogin] Filters by &#39;lastLogin&#39;
         * @param {Array<any>} [filterEqProject] Filters by &#39;project&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {string} [filterEqRole] Filters by &#39;role&#39;
         * @param {number} [filterEqSynchronizationDate] Filters by &#39;synchronizationDate&#39;
         * @param {string} [filterEqType] Filters by &#39;type&#39;
         * @param {string} [filterEqUser] Filters by &#39;user&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectUsersUsingGET1(projectName: string, filterEqEmail?: string, filterEqExpired?: boolean, filterEqFullName?: string, filterEqId?: number, filterEqLastLogin?: number, filterEqProject?: Array<any>, filterEqProjectId?: number, filterEqRole?: string, filterEqSynchronizationDate?: number, filterEqType?: string, filterEqUser?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getProjectUsersUsingGET1.');
            }
            const localVarPath = `/v1/project/{projectName}/users`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filterEqEmail !== undefined) {
                localVarQueryParameter['filter.eq.email'] = filterEqEmail;
            }

            if (filterEqExpired !== undefined) {
                localVarQueryParameter['filter.eq.expired'] = filterEqExpired;
            }

            if (filterEqFullName !== undefined) {
                localVarQueryParameter['filter.eq.fullName'] = filterEqFullName;
            }

            if (filterEqId !== undefined) {
                localVarQueryParameter['filter.eq.id'] = filterEqId;
            }

            if (filterEqLastLogin !== undefined) {
                localVarQueryParameter['filter.eq.lastLogin'] = filterEqLastLogin;
            }

            if (filterEqProject) {
                localVarQueryParameter['filter.eq.project'] = filterEqProject;
            }

            if (filterEqProjectId !== undefined) {
                localVarQueryParameter['filter.eq.projectId'] = filterEqProjectId;
            }

            if (filterEqRole !== undefined) {
                localVarQueryParameter['filter.eq.role'] = filterEqRole;
            }

            if (filterEqSynchronizationDate !== undefined) {
                localVarQueryParameter['filter.eq.synchronizationDate'] = filterEqSynchronizationDate;
            }

            if (filterEqType !== undefined) {
                localVarQueryParameter['filter.eq.type'] = filterEqType;
            }

            if (filterEqUser !== undefined) {
                localVarQueryParameter['filter.eq.user'] = filterEqUser;
            }

            if (pagePage !== undefined) {
                localVarQueryParameter['page.page'] = pagePage;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page.size'] = pageSize;
            }

            if (pageSort) {
                localVarQueryParameter['page.sort'] = pageSort;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only for users that are assigned to the project
         * @summary Get information about project
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectUsingGET(projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getProjectUsingGET.');
            }
            const localVarPath = `/v1/project/{projectName}`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary getProjectWidget
         * @param {string} projectName projectName
         * @param {string} widgetCode widgetCode
         * @param {string} [interval] interval
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectWidgetUsingGET(projectName: string, widgetCode: string, interval?: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getProjectWidgetUsingGET.');
            }
            // verify required parameter 'widgetCode' is not null or undefined
            if (widgetCode === null || widgetCode === undefined) {
                throw new RequiredError('widgetCode', 'Required parameter widgetCode was null or undefined when calling getProjectWidgetUsingGET.');
            }
            const localVarPath = `/v1/project/{projectName}/widget/{widgetCode}`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)))
                .replace(`{${"widgetCode"}}`, encodeURIComponent(String(widgetCode)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only for users that allowed to edit other users
         * @summary Load user preferences
         * @param {string} login login
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPreferenceUsingGET(login: string, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'login' is not null or undefined
            if (login === null || login === undefined) {
                throw new RequiredError('login', 'Required parameter login was null or undefined when calling getUserPreferenceUsingGET.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getUserPreferenceUsingGET.');
            }
            const localVarPath = `/v1/project/{projectName}/preference/{login}`
                .replace(`{${"login"}}`, encodeURIComponent(String(login)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only for users with project manager permissions
         * @summary Load users which can be assigned to specified project
         * @param {string} projectName projectName
         * @param {string} [filterEqEmail] Filters by &#39;email&#39;
         * @param {boolean} [filterEqExpired] Filters by &#39;expired&#39;
         * @param {string} [filterEqFullName] Filters by &#39;fullName&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {number} [filterEqLastLogin] Filters by &#39;lastLogin&#39;
         * @param {Array<any>} [filterEqProject] Filters by &#39;project&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {string} [filterEqRole] Filters by &#39;role&#39;
         * @param {number} [filterEqSynchronizationDate] Filters by &#39;synchronizationDate&#39;
         * @param {string} [filterEqType] Filters by &#39;type&#39;
         * @param {string} [filterEqUser] Filters by &#39;user&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersForAssignUsingGET(projectName: string, filterEqEmail?: string, filterEqExpired?: boolean, filterEqFullName?: string, filterEqId?: number, filterEqLastLogin?: number, filterEqProject?: Array<any>, filterEqProjectId?: number, filterEqRole?: string, filterEqSynchronizationDate?: number, filterEqType?: string, filterEqUser?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getUsersForAssignUsingGET.');
            }
            const localVarPath = `/v1/project/{projectName}/assignable`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filterEqEmail !== undefined) {
                localVarQueryParameter['filter.eq.email'] = filterEqEmail;
            }

            if (filterEqExpired !== undefined) {
                localVarQueryParameter['filter.eq.expired'] = filterEqExpired;
            }

            if (filterEqFullName !== undefined) {
                localVarQueryParameter['filter.eq.fullName'] = filterEqFullName;
            }

            if (filterEqId !== undefined) {
                localVarQueryParameter['filter.eq.id'] = filterEqId;
            }

            if (filterEqLastLogin !== undefined) {
                localVarQueryParameter['filter.eq.lastLogin'] = filterEqLastLogin;
            }

            if (filterEqProject) {
                localVarQueryParameter['filter.eq.project'] = filterEqProject;
            }

            if (filterEqProjectId !== undefined) {
                localVarQueryParameter['filter.eq.projectId'] = filterEqProjectId;
            }

            if (filterEqRole !== undefined) {
                localVarQueryParameter['filter.eq.role'] = filterEqRole;
            }

            if (filterEqSynchronizationDate !== undefined) {
                localVarQueryParameter['filter.eq.synchronizationDate'] = filterEqSynchronizationDate;
            }

            if (filterEqType !== undefined) {
                localVarQueryParameter['filter.eq.type'] = filterEqType;
            }

            if (filterEqUser !== undefined) {
                localVarQueryParameter['filter.eq.user'] = filterEqUser;
            }

            if (pagePage !== undefined) {
                localVarQueryParameter['page.page'] = pagePage;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page.size'] = pageSize;
            }

            if (pageSort) {
                localVarQueryParameter['page.sort'] = pageSort;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Starts reindex all project data in ML
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexProjectDataUsingPUT(projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling indexProjectDataUsingPUT.');
            }
            const localVarPath = `/v1/project/{projectName}/index`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'PUT'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary removeUserPreference
         * @param {number} filterId filterId
         * @param {string} login login
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserPreferenceUsingDELETE(filterId: number, login: string, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'filterId' is not null or undefined
            if (filterId === null || filterId === undefined) {
                throw new RequiredError('filterId', 'Required parameter filterId was null or undefined when calling removeUserPreferenceUsingDELETE.');
            }
            // verify required parameter 'login' is not null or undefined
            if (login === null || login === undefined) {
                throw new RequiredError('login', 'Required parameter login was null or undefined when calling removeUserPreferenceUsingDELETE.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling removeUserPreferenceUsingDELETE.');
            }
            const localVarPath = `/v1/project/{projectName}/preference/{login}/{filterId}`
                .replace(`{${"filterId"}}`, encodeURIComponent(String(filterId)))
                .replace(`{${"login"}}`, encodeURIComponent(String(login)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'DELETE'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary searchForUser
         * @param {string} projectName projectName
         * @param {string} term term
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchForUserUsingGET(projectName: string, term: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling searchForUserUsingGET.');
            }
            // verify required parameter 'term' is not null or undefined
            if (term === null || term === undefined) {
                throw new RequiredError('term', 'Required parameter term was null or undefined when calling searchForUserUsingGET.');
            }
            const localVarPath = `/v1/project/{projectName}/usernames/search`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pagePage !== undefined) {
                localVarQueryParameter['page.page'] = pagePage;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page.size'] = pageSize;
            }

            if (pageSort) {
                localVarQueryParameter['page.sort'] = pageSort;
            }

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary searchProjectNames
         * @param {string} term term
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchProjectNamesUsingGET(term: string, options: any = {}): FetchArgs {
            // verify required parameter 'term' is not null or undefined
            if (term === null || term === undefined) {
                throw new RequiredError('term', 'Required parameter term was null or undefined when calling searchProjectNamesUsingGET.');
            }
            const localVarPath = `/v1/project/names/search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Un assign users
         * @param {string} projectName projectName
         * @param {UnassignUsersRQ} unassignUsersRQ unassignUsersRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unassignProjectUsersUsingPUT(projectName: string, unassignUsersRQ: UnassignUsersRQ, options: any = {}): FetchArgs {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling unassignProjectUsersUsingPUT.');
            }
            // verify required parameter 'unassignUsersRQ' is not null or undefined
            if (unassignUsersRQ === null || unassignUsersRQ === undefined) {
                throw new RequiredError('unassignUsersRQ', 'Required parameter unassignUsersRQ was null or undefined when calling unassignProjectUsersUsingPUT.');
            }
            const localVarPath = `/v1/project/{projectName}/unassign`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'PUT'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UnassignUsersRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(unassignUsersRQ || {}) : (unassignUsersRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update project notifications configuration
         * @param {string} projectName projectName
         * @param {ProjectNotificationConfigDTO} updateProjectNotificationConfigRQ updateProjectNotificationConfigRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectNotificationConfigUsingPUT(projectName: string, updateProjectNotificationConfigRQ: ProjectNotificationConfigDTO, options: any = {}): FetchArgs {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling updateProjectNotificationConfigUsingPUT.');
            }
            // verify required parameter 'updateProjectNotificationConfigRQ' is not null or undefined
            if (updateProjectNotificationConfigRQ === null || updateProjectNotificationConfigRQ === undefined) {
                throw new RequiredError('updateProjectNotificationConfigRQ', 'Required parameter updateProjectNotificationConfigRQ was null or undefined when calling updateProjectNotificationConfigUsingPUT.');
            }
            const localVarPath = `/v1/project/{projectName}/notification`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'PUT'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProjectNotificationConfigDTO" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(updateProjectNotificationConfigRQ || {}) : (updateProjectNotificationConfigRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update project
         * @param {string} projectName projectName
         * @param {UpdateProjectRQ} updateProjectRQ updateProjectRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectUsingPUT(projectName: string, updateProjectRQ: UpdateProjectRQ, options: any = {}): FetchArgs {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling updateProjectUsingPUT.');
            }
            // verify required parameter 'updateProjectRQ' is not null or undefined
            if (updateProjectRQ === null || updateProjectRQ === undefined) {
                throw new RequiredError('updateProjectRQ', 'Required parameter updateProjectRQ was null or undefined when calling updateProjectUsingPUT.');
            }
            const localVarPath = `/v1/project/{projectName}`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'PUT'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateProjectRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(updateProjectRQ || {}) : (updateProjectRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectControllerApi - functional programming interface
 * @export
 */
export const ProjectControllerApiFp = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary addUserPreference
         * @param {number} filterId filterId
         * @param {string} login login
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserPreferenceUsingPUT(filterId: number, login: string, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = ProjectControllerApiFetchParamCreator(configuration).addUserPreferenceUsingPUT(filterId, login, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Assign users
         * @param {AssignUsersRQ} assignUsersRQ assignUsersRQ
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignProjectUsersUsingPUT(assignUsersRQ: AssignUsersRQ, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = ProjectControllerApiFetchParamCreator(configuration).assignProjectUsersUsingPUT(assignUsersRQ, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create new project
         * @param {CreateProjectRQ} createProjectRQ createProjectRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectUsingPOST(createProjectRQ: CreateProjectRQ, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EntryCreatedRS> {
            const localVarFetchArgs = ProjectControllerApiFetchParamCreator(configuration).createProjectUsingPOST(createProjectRQ, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete project index from ML
         * @param {string} projectName projectName
         * @param {string} [name]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectIndexUsingDELETE(projectName: string, name?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = ProjectControllerApiFetchParamCreator(configuration).deleteProjectIndexUsingDELETE(projectName, name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Could be deleted only by users with administrator role
         * @summary Delete project
         * @param {number} projectId projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectUsingDELETE(projectId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = ProjectControllerApiFetchParamCreator(configuration).deleteProjectUsingDELETE(projectId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Could be deleted only by users with administrator role
         * @summary Delete multiple projects
         * @param {DeleteBulkRQ} deleteBulkRQ deleteBulkRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectUsingDELETE1(deleteBulkRQ: DeleteBulkRQ, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteBulkRS> {
            const localVarFetchArgs = ProjectControllerApiFetchParamCreator(configuration).deleteProjectUsingDELETE1(deleteBulkRQ, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Allowable only for users with administrator role
         * @summary Exports information about all projects
         * @param {Date} [filterEqCreationDate] Filters by &#39;creationDate&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {Date} [filterEqLastRun] Filters by &#39;lastRun&#39;
         * @param {number} [filterEqLaunchesQuantity] Filters by &#39;launchesQuantity&#39;
         * @param {string} [filterEqName] Filters by &#39;name&#39;
         * @param {string} [filterEqOrganization] Filters by &#39;organization&#39;
         * @param {string} [filterEqType] Filters by &#39;type&#39;
         * @param {number} [filterEqUsersQuantity] Filters by &#39;usersQuantity&#39;
         * @param {'csv'} [view] view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportProjectsUsingGET(filterEqCreationDate?: Date, filterEqId?: number, filterEqLastRun?: Date, filterEqLaunchesQuantity?: number, filterEqName?: string, filterEqOrganization?: string, filterEqType?: string, filterEqUsersQuantity?: number, view?: 'csv', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectControllerApiFetchParamCreator(configuration).exportProjectsUsingGET(filterEqCreationDate, filterEqId, filterEqLastRun, filterEqLaunchesQuantity, filterEqName, filterEqOrganization, filterEqType, filterEqUsersQuantity, view, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary getAllProjectNames
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProjectNamesUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Iterablestring> {
            const localVarFetchArgs = ProjectControllerApiFetchParamCreator(configuration).getAllProjectNamesUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary getAllProjectsInfo
         * @param {Date} [filterEqCreationDate] Filters by &#39;creationDate&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {Date} [filterEqLastRun] Filters by &#39;lastRun&#39;
         * @param {number} [filterEqLaunchesQuantity] Filters by &#39;launchesQuantity&#39;
         * @param {string} [filterEqName] Filters by &#39;name&#39;
         * @param {string} [filterEqOrganization] Filters by &#39;organization&#39;
         * @param {string} [filterEqType] Filters by &#39;type&#39;
         * @param {number} [filterEqUsersQuantity] Filters by &#39;usersQuantity&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProjectsInfoUsingGET(filterEqCreationDate?: Date, filterEqId?: number, filterEqLastRun?: Date, filterEqLaunchesQuantity?: number, filterEqName?: string, filterEqOrganization?: string, filterEqType?: string, filterEqUsersQuantity?: number, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<IterableProjectInfoResource> {
            const localVarFetchArgs = ProjectControllerApiFetchParamCreator(configuration).getAllProjectsInfoUsingGET(filterEqCreationDate, filterEqId, filterEqLastRun, filterEqLaunchesQuantity, filterEqName, filterEqOrganization, filterEqType, filterEqUsersQuantity, pagePage, pageSize, pageSort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary getAnalyzerIndexingStatus
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalyzerIndexingStatusUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{
            [key: string]: boolean;
        }> {
            const localVarFetchArgs = ProjectControllerApiFetchParamCreator(configuration).getAnalyzerIndexingStatusUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary getProjectInfo
         * @param {string} projectName projectName
         * @param {string} [interval] interval
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectInfoUsingGET(projectName: string, interval?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectInfoResource> {
            const localVarFetchArgs = ProjectControllerApiFetchParamCreator(configuration).getProjectInfoUsingGET(projectName, interval, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Only for users that are members of the project
         * @summary Load project users by filter
         * @param {string} filterCntUsers filter.cnt.users
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectUsersUsingGET(filterCntUsers: string, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = ProjectControllerApiFetchParamCreator(configuration).getProjectUsersUsingGET(filterCntUsers, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get users assigned on current project
         * @param {string} projectName projectName
         * @param {string} [filterEqEmail] Filters by &#39;email&#39;
         * @param {boolean} [filterEqExpired] Filters by &#39;expired&#39;
         * @param {string} [filterEqFullName] Filters by &#39;fullName&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {number} [filterEqLastLogin] Filters by &#39;lastLogin&#39;
         * @param {Array<any>} [filterEqProject] Filters by &#39;project&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {string} [filterEqRole] Filters by &#39;role&#39;
         * @param {number} [filterEqSynchronizationDate] Filters by &#39;synchronizationDate&#39;
         * @param {string} [filterEqType] Filters by &#39;type&#39;
         * @param {string} [filterEqUser] Filters by &#39;user&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectUsersUsingGET1(projectName: string, filterEqEmail?: string, filterEqExpired?: boolean, filterEqFullName?: string, filterEqId?: number, filterEqLastLogin?: number, filterEqProject?: Array<any>, filterEqProjectId?: number, filterEqRole?: string, filterEqSynchronizationDate?: number, filterEqType?: string, filterEqUser?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<IterableUserResource> {
            const localVarFetchArgs = ProjectControllerApiFetchParamCreator(configuration).getProjectUsersUsingGET1(projectName, filterEqEmail, filterEqExpired, filterEqFullName, filterEqId, filterEqLastLogin, filterEqProject, filterEqProjectId, filterEqRole, filterEqSynchronizationDate, filterEqType, filterEqUser, pagePage, pageSize, pageSort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Only for users that are assigned to the project
         * @summary Get information about project
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectUsingGET(projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectResource> {
            const localVarFetchArgs = ProjectControllerApiFetchParamCreator(configuration).getProjectUsingGET(projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary getProjectWidget
         * @param {string} projectName projectName
         * @param {string} widgetCode widgetCode
         * @param {string} [interval] interval
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectWidgetUsingGET(projectName: string, widgetCode: string, interval?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = ProjectControllerApiFetchParamCreator(configuration).getProjectWidgetUsingGET(projectName, widgetCode, interval, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Only for users that allowed to edit other users
         * @summary Load user preferences
         * @param {string} login login
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPreferenceUsingGET(login: string, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PreferenceResource> {
            const localVarFetchArgs = ProjectControllerApiFetchParamCreator(configuration).getUserPreferenceUsingGET(login, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Only for users with project manager permissions
         * @summary Load users which can be assigned to specified project
         * @param {string} projectName projectName
         * @param {string} [filterEqEmail] Filters by &#39;email&#39;
         * @param {boolean} [filterEqExpired] Filters by &#39;expired&#39;
         * @param {string} [filterEqFullName] Filters by &#39;fullName&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {number} [filterEqLastLogin] Filters by &#39;lastLogin&#39;
         * @param {Array<any>} [filterEqProject] Filters by &#39;project&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {string} [filterEqRole] Filters by &#39;role&#39;
         * @param {number} [filterEqSynchronizationDate] Filters by &#39;synchronizationDate&#39;
         * @param {string} [filterEqType] Filters by &#39;type&#39;
         * @param {string} [filterEqUser] Filters by &#39;user&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersForAssignUsingGET(projectName: string, filterEqEmail?: string, filterEqExpired?: boolean, filterEqFullName?: string, filterEqId?: number, filterEqLastLogin?: number, filterEqProject?: Array<any>, filterEqProjectId?: number, filterEqRole?: string, filterEqSynchronizationDate?: number, filterEqType?: string, filterEqUser?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<IterableUserResource> {
            const localVarFetchArgs = ProjectControllerApiFetchParamCreator(configuration).getUsersForAssignUsingGET(projectName, filterEqEmail, filterEqExpired, filterEqFullName, filterEqId, filterEqLastLogin, filterEqProject, filterEqProjectId, filterEqRole, filterEqSynchronizationDate, filterEqType, filterEqUser, pagePage, pageSize, pageSort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Starts reindex all project data in ML
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexProjectDataUsingPUT(projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = ProjectControllerApiFetchParamCreator(configuration).indexProjectDataUsingPUT(projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary removeUserPreference
         * @param {number} filterId filterId
         * @param {string} login login
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserPreferenceUsingDELETE(filterId: number, login: string, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = ProjectControllerApiFetchParamCreator(configuration).removeUserPreferenceUsingDELETE(filterId, login, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary searchForUser
         * @param {string} projectName projectName
         * @param {string} term term
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchForUserUsingGET(projectName: string, term: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<IterableSearchUserResource> {
            const localVarFetchArgs = ProjectControllerApiFetchParamCreator(configuration).searchForUserUsingGET(projectName, term, pagePage, pageSize, pageSort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary searchProjectNames
         * @param {string} term term
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchProjectNamesUsingGET(term: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Iterablestring> {
            const localVarFetchArgs = ProjectControllerApiFetchParamCreator(configuration).searchProjectNamesUsingGET(term, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Un assign users
         * @param {string} projectName projectName
         * @param {UnassignUsersRQ} unassignUsersRQ unassignUsersRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unassignProjectUsersUsingPUT(projectName: string, unassignUsersRQ: UnassignUsersRQ, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = ProjectControllerApiFetchParamCreator(configuration).unassignProjectUsersUsingPUT(projectName, unassignUsersRQ, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update project notifications configuration
         * @param {string} projectName projectName
         * @param {ProjectNotificationConfigDTO} updateProjectNotificationConfigRQ updateProjectNotificationConfigRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectNotificationConfigUsingPUT(projectName: string, updateProjectNotificationConfigRQ: ProjectNotificationConfigDTO, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = ProjectControllerApiFetchParamCreator(configuration).updateProjectNotificationConfigUsingPUT(projectName, updateProjectNotificationConfigRQ, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update project
         * @param {string} projectName projectName
         * @param {UpdateProjectRQ} updateProjectRQ updateProjectRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectUsingPUT(projectName: string, updateProjectRQ: UpdateProjectRQ, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = ProjectControllerApiFetchParamCreator(configuration).updateProjectUsingPUT(projectName, updateProjectRQ, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProjectControllerApi - factory interface
 * @export
 */
export const ProjectControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary addUserPreference
         * @param {number} filterId filterId
         * @param {string} login login
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserPreferenceUsingPUT(filterId: number, login: string, projectName: string, options?: any) {
            return ProjectControllerApiFp(configuration).addUserPreferenceUsingPUT(filterId, login, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Assign users
         * @param {AssignUsersRQ} assignUsersRQ assignUsersRQ
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignProjectUsersUsingPUT(assignUsersRQ: AssignUsersRQ, projectName: string, options?: any) {
            return ProjectControllerApiFp(configuration).assignProjectUsersUsingPUT(assignUsersRQ, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create new project
         * @param {CreateProjectRQ} createProjectRQ createProjectRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectUsingPOST(createProjectRQ: CreateProjectRQ, options?: any) {
            return ProjectControllerApiFp(configuration).createProjectUsingPOST(createProjectRQ, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete project index from ML
         * @param {string} projectName projectName
         * @param {string} [name]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectIndexUsingDELETE(projectName: string, name?: string, options?: any) {
            return ProjectControllerApiFp(configuration).deleteProjectIndexUsingDELETE(projectName, name, options)(fetch, basePath);
        },
        /**
         * Could be deleted only by users with administrator role
         * @summary Delete project
         * @param {number} projectId projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectUsingDELETE(projectId: number, options?: any) {
            return ProjectControllerApiFp(configuration).deleteProjectUsingDELETE(projectId, options)(fetch, basePath);
        },
        /**
         * Could be deleted only by users with administrator role
         * @summary Delete multiple projects
         * @param {DeleteBulkRQ} deleteBulkRQ deleteBulkRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectUsingDELETE1(deleteBulkRQ: DeleteBulkRQ, options?: any) {
            return ProjectControllerApiFp(configuration).deleteProjectUsingDELETE1(deleteBulkRQ, options)(fetch, basePath);
        },
        /**
         * Allowable only for users with administrator role
         * @summary Exports information about all projects
         * @param {Date} [filterEqCreationDate] Filters by &#39;creationDate&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {Date} [filterEqLastRun] Filters by &#39;lastRun&#39;
         * @param {number} [filterEqLaunchesQuantity] Filters by &#39;launchesQuantity&#39;
         * @param {string} [filterEqName] Filters by &#39;name&#39;
         * @param {string} [filterEqOrganization] Filters by &#39;organization&#39;
         * @param {string} [filterEqType] Filters by &#39;type&#39;
         * @param {number} [filterEqUsersQuantity] Filters by &#39;usersQuantity&#39;
         * @param {'csv'} [view] view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportProjectsUsingGET(filterEqCreationDate?: Date, filterEqId?: number, filterEqLastRun?: Date, filterEqLaunchesQuantity?: number, filterEqName?: string, filterEqOrganization?: string, filterEqType?: string, filterEqUsersQuantity?: number, view?: 'csv', options?: any) {
            return ProjectControllerApiFp(configuration).exportProjectsUsingGET(filterEqCreationDate, filterEqId, filterEqLastRun, filterEqLaunchesQuantity, filterEqName, filterEqOrganization, filterEqType, filterEqUsersQuantity, view, options)(fetch, basePath);
        },
        /**
         *
         * @summary getAllProjectNames
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProjectNamesUsingGET(options?: any) {
            return ProjectControllerApiFp(configuration).getAllProjectNamesUsingGET(options)(fetch, basePath);
        },
        /**
         *
         * @summary getAllProjectsInfo
         * @param {Date} [filterEqCreationDate] Filters by &#39;creationDate&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {Date} [filterEqLastRun] Filters by &#39;lastRun&#39;
         * @param {number} [filterEqLaunchesQuantity] Filters by &#39;launchesQuantity&#39;
         * @param {string} [filterEqName] Filters by &#39;name&#39;
         * @param {string} [filterEqOrganization] Filters by &#39;organization&#39;
         * @param {string} [filterEqType] Filters by &#39;type&#39;
         * @param {number} [filterEqUsersQuantity] Filters by &#39;usersQuantity&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProjectsInfoUsingGET(filterEqCreationDate?: Date, filterEqId?: number, filterEqLastRun?: Date, filterEqLaunchesQuantity?: number, filterEqName?: string, filterEqOrganization?: string, filterEqType?: string, filterEqUsersQuantity?: number, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any) {
            return ProjectControllerApiFp(configuration).getAllProjectsInfoUsingGET(filterEqCreationDate, filterEqId, filterEqLastRun, filterEqLaunchesQuantity, filterEqName, filterEqOrganization, filterEqType, filterEqUsersQuantity, pagePage, pageSize, pageSort, options)(fetch, basePath);
        },
        /**
         *
         * @summary getAnalyzerIndexingStatus
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnalyzerIndexingStatusUsingGET(options?: any) {
            return ProjectControllerApiFp(configuration).getAnalyzerIndexingStatusUsingGET(options)(fetch, basePath);
        },
        /**
         *
         * @summary getProjectInfo
         * @param {string} projectName projectName
         * @param {string} [interval] interval
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectInfoUsingGET(projectName: string, interval?: string, options?: any) {
            return ProjectControllerApiFp(configuration).getProjectInfoUsingGET(projectName, interval, options)(fetch, basePath);
        },
        /**
         * Only for users that are members of the project
         * @summary Load project users by filter
         * @param {string} filterCntUsers filter.cnt.users
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectUsersUsingGET(filterCntUsers: string, projectName: string, options?: any) {
            return ProjectControllerApiFp(configuration).getProjectUsersUsingGET(filterCntUsers, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get users assigned on current project
         * @param {string} projectName projectName
         * @param {string} [filterEqEmail] Filters by &#39;email&#39;
         * @param {boolean} [filterEqExpired] Filters by &#39;expired&#39;
         * @param {string} [filterEqFullName] Filters by &#39;fullName&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {number} [filterEqLastLogin] Filters by &#39;lastLogin&#39;
         * @param {Array<any>} [filterEqProject] Filters by &#39;project&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {string} [filterEqRole] Filters by &#39;role&#39;
         * @param {number} [filterEqSynchronizationDate] Filters by &#39;synchronizationDate&#39;
         * @param {string} [filterEqType] Filters by &#39;type&#39;
         * @param {string} [filterEqUser] Filters by &#39;user&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectUsersUsingGET1(projectName: string, filterEqEmail?: string, filterEqExpired?: boolean, filterEqFullName?: string, filterEqId?: number, filterEqLastLogin?: number, filterEqProject?: Array<any>, filterEqProjectId?: number, filterEqRole?: string, filterEqSynchronizationDate?: number, filterEqType?: string, filterEqUser?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any) {
            return ProjectControllerApiFp(configuration).getProjectUsersUsingGET1(projectName, filterEqEmail, filterEqExpired, filterEqFullName, filterEqId, filterEqLastLogin, filterEqProject, filterEqProjectId, filterEqRole, filterEqSynchronizationDate, filterEqType, filterEqUser, pagePage, pageSize, pageSort, options)(fetch, basePath);
        },
        /**
         * Only for users that are assigned to the project
         * @summary Get information about project
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectUsingGET(projectName: string, options?: any) {
            return ProjectControllerApiFp(configuration).getProjectUsingGET(projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary getProjectWidget
         * @param {string} projectName projectName
         * @param {string} widgetCode widgetCode
         * @param {string} [interval] interval
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectWidgetUsingGET(projectName: string, widgetCode: string, interval?: string, options?: any) {
            return ProjectControllerApiFp(configuration).getProjectWidgetUsingGET(projectName, widgetCode, interval, options)(fetch, basePath);
        },
        /**
         * Only for users that allowed to edit other users
         * @summary Load user preferences
         * @param {string} login login
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPreferenceUsingGET(login: string, projectName: string, options?: any) {
            return ProjectControllerApiFp(configuration).getUserPreferenceUsingGET(login, projectName, options)(fetch, basePath);
        },
        /**
         * Only for users with project manager permissions
         * @summary Load users which can be assigned to specified project
         * @param {string} projectName projectName
         * @param {string} [filterEqEmail] Filters by &#39;email&#39;
         * @param {boolean} [filterEqExpired] Filters by &#39;expired&#39;
         * @param {string} [filterEqFullName] Filters by &#39;fullName&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {number} [filterEqLastLogin] Filters by &#39;lastLogin&#39;
         * @param {Array<any>} [filterEqProject] Filters by &#39;project&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {string} [filterEqRole] Filters by &#39;role&#39;
         * @param {number} [filterEqSynchronizationDate] Filters by &#39;synchronizationDate&#39;
         * @param {string} [filterEqType] Filters by &#39;type&#39;
         * @param {string} [filterEqUser] Filters by &#39;user&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersForAssignUsingGET(projectName: string, filterEqEmail?: string, filterEqExpired?: boolean, filterEqFullName?: string, filterEqId?: number, filterEqLastLogin?: number, filterEqProject?: Array<any>, filterEqProjectId?: number, filterEqRole?: string, filterEqSynchronizationDate?: number, filterEqType?: string, filterEqUser?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any) {
            return ProjectControllerApiFp(configuration).getUsersForAssignUsingGET(projectName, filterEqEmail, filterEqExpired, filterEqFullName, filterEqId, filterEqLastLogin, filterEqProject, filterEqProjectId, filterEqRole, filterEqSynchronizationDate, filterEqType, filterEqUser, pagePage, pageSize, pageSort, options)(fetch, basePath);
        },
        /**
         *
         * @summary Starts reindex all project data in ML
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        indexProjectDataUsingPUT(projectName: string, options?: any) {
            return ProjectControllerApiFp(configuration).indexProjectDataUsingPUT(projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary removeUserPreference
         * @param {number} filterId filterId
         * @param {string} login login
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserPreferenceUsingDELETE(filterId: number, login: string, projectName: string, options?: any) {
            return ProjectControllerApiFp(configuration).removeUserPreferenceUsingDELETE(filterId, login, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary searchForUser
         * @param {string} projectName projectName
         * @param {string} term term
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchForUserUsingGET(projectName: string, term: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any) {
            return ProjectControllerApiFp(configuration).searchForUserUsingGET(projectName, term, pagePage, pageSize, pageSort, options)(fetch, basePath);
        },
        /**
         *
         * @summary searchProjectNames
         * @param {string} term term
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchProjectNamesUsingGET(term: string, options?: any) {
            return ProjectControllerApiFp(configuration).searchProjectNamesUsingGET(term, options)(fetch, basePath);
        },
        /**
         *
         * @summary Un assign users
         * @param {string} projectName projectName
         * @param {UnassignUsersRQ} unassignUsersRQ unassignUsersRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unassignProjectUsersUsingPUT(projectName: string, unassignUsersRQ: UnassignUsersRQ, options?: any) {
            return ProjectControllerApiFp(configuration).unassignProjectUsersUsingPUT(projectName, unassignUsersRQ, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update project notifications configuration
         * @param {string} projectName projectName
         * @param {ProjectNotificationConfigDTO} updateProjectNotificationConfigRQ updateProjectNotificationConfigRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectNotificationConfigUsingPUT(projectName: string, updateProjectNotificationConfigRQ: ProjectNotificationConfigDTO, options?: any) {
            return ProjectControllerApiFp(configuration).updateProjectNotificationConfigUsingPUT(projectName, updateProjectNotificationConfigRQ, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update project
         * @param {string} projectName projectName
         * @param {UpdateProjectRQ} updateProjectRQ updateProjectRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectUsingPUT(projectName: string, updateProjectRQ: UpdateProjectRQ, options?: any) {
            return ProjectControllerApiFp(configuration).updateProjectUsingPUT(projectName, updateProjectRQ, options)(fetch, basePath);
        },
    };
};

/**
 * ProjectControllerApi - object-oriented interface
 * @export
 * @class ProjectControllerApi
 * @extends {BaseAPI}
 */
export class ProjectControllerApi extends BaseAPI {
    /**
     *
     * @summary addUserPreference
     * @param {number} filterId filterId
     * @param {string} login login
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectControllerApi
     */
    public addUserPreferenceUsingPUT(filterId: number, login: string, projectName: string, options?: any) {
        return ProjectControllerApiFp(this.configuration).addUserPreferenceUsingPUT(filterId, login, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Assign users
     * @param {AssignUsersRQ} assignUsersRQ assignUsersRQ
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectControllerApi
     */
    public assignProjectUsersUsingPUT(assignUsersRQ: AssignUsersRQ, projectName: string, options?: any) {
        return ProjectControllerApiFp(this.configuration).assignProjectUsersUsingPUT(assignUsersRQ, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Create new project
     * @param {CreateProjectRQ} createProjectRQ createProjectRQ
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectControllerApi
     */
    public createProjectUsingPOST(createProjectRQ: CreateProjectRQ, options?: any) {
        return ProjectControllerApiFp(this.configuration).createProjectUsingPOST(createProjectRQ, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete project index from ML
     * @param {string} projectName projectName
     * @param {string} [name]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectControllerApi
     */
    public deleteProjectIndexUsingDELETE(projectName: string, name?: string, options?: any) {
        return ProjectControllerApiFp(this.configuration).deleteProjectIndexUsingDELETE(projectName, name, options)(this.fetch, this.basePath);
    }

    /**
     * Could be deleted only by users with administrator role
     * @summary Delete project
     * @param {number} projectId projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectControllerApi
     */
    public deleteProjectUsingDELETE(projectId: number, options?: any) {
        return ProjectControllerApiFp(this.configuration).deleteProjectUsingDELETE(projectId, options)(this.fetch, this.basePath);
    }

    /**
     * Could be deleted only by users with administrator role
     * @summary Delete multiple projects
     * @param {DeleteBulkRQ} deleteBulkRQ deleteBulkRQ
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectControllerApi
     */
    public deleteProjectUsingDELETE1(deleteBulkRQ: DeleteBulkRQ, options?: any) {
        return ProjectControllerApiFp(this.configuration).deleteProjectUsingDELETE1(deleteBulkRQ, options)(this.fetch, this.basePath);
    }

    /**
     * Allowable only for users with administrator role
     * @summary Exports information about all projects
     * @param {Date} [filterEqCreationDate] Filters by &#39;creationDate&#39;
     * @param {number} [filterEqId] Filters by &#39;id&#39;
     * @param {Date} [filterEqLastRun] Filters by &#39;lastRun&#39;
     * @param {number} [filterEqLaunchesQuantity] Filters by &#39;launchesQuantity&#39;
     * @param {string} [filterEqName] Filters by &#39;name&#39;
     * @param {string} [filterEqOrganization] Filters by &#39;organization&#39;
     * @param {string} [filterEqType] Filters by &#39;type&#39;
     * @param {number} [filterEqUsersQuantity] Filters by &#39;usersQuantity&#39;
     * @param {'csv'} [view] view
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectControllerApi
     */
    public exportProjectsUsingGET(filterEqCreationDate?: Date, filterEqId?: number, filterEqLastRun?: Date, filterEqLaunchesQuantity?: number, filterEqName?: string, filterEqOrganization?: string, filterEqType?: string, filterEqUsersQuantity?: number, view?: 'csv', options?: any) {
        return ProjectControllerApiFp(this.configuration).exportProjectsUsingGET(filterEqCreationDate, filterEqId, filterEqLastRun, filterEqLaunchesQuantity, filterEqName, filterEqOrganization, filterEqType, filterEqUsersQuantity, view, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary getAllProjectNames
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectControllerApi
     */
    public getAllProjectNamesUsingGET(options?: any) {
        return ProjectControllerApiFp(this.configuration).getAllProjectNamesUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary getAllProjectsInfo
     * @param {Date} [filterEqCreationDate] Filters by &#39;creationDate&#39;
     * @param {number} [filterEqId] Filters by &#39;id&#39;
     * @param {Date} [filterEqLastRun] Filters by &#39;lastRun&#39;
     * @param {number} [filterEqLaunchesQuantity] Filters by &#39;launchesQuantity&#39;
     * @param {string} [filterEqName] Filters by &#39;name&#39;
     * @param {string} [filterEqOrganization] Filters by &#39;organization&#39;
     * @param {string} [filterEqType] Filters by &#39;type&#39;
     * @param {number} [filterEqUsersQuantity] Filters by &#39;usersQuantity&#39;
     * @param {number} [pagePage] Results page you want to retrieve (0..N)
     * @param {number} [pageSize] Number of records per page
     * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectControllerApi
     */
    public getAllProjectsInfoUsingGET(filterEqCreationDate?: Date, filterEqId?: number, filterEqLastRun?: Date, filterEqLaunchesQuantity?: number, filterEqName?: string, filterEqOrganization?: string, filterEqType?: string, filterEqUsersQuantity?: number, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any) {
        return ProjectControllerApiFp(this.configuration).getAllProjectsInfoUsingGET(filterEqCreationDate, filterEqId, filterEqLastRun, filterEqLaunchesQuantity, filterEqName, filterEqOrganization, filterEqType, filterEqUsersQuantity, pagePage, pageSize, pageSort, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary getAnalyzerIndexingStatus
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectControllerApi
     */
    public getAnalyzerIndexingStatusUsingGET(options?: any) {
        return ProjectControllerApiFp(this.configuration).getAnalyzerIndexingStatusUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary getProjectInfo
     * @param {string} projectName projectName
     * @param {string} [interval] interval
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectControllerApi
     */
    public getProjectInfoUsingGET(projectName: string, interval?: string, options?: any) {
        return ProjectControllerApiFp(this.configuration).getProjectInfoUsingGET(projectName, interval, options)(this.fetch, this.basePath);
    }

    /**
     * Only for users that are members of the project
     * @summary Load project users by filter
     * @param {string} filterCntUsers filter.cnt.users
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectControllerApi
     */
    public getProjectUsersUsingGET(filterCntUsers: string, projectName: string, options?: any) {
        return ProjectControllerApiFp(this.configuration).getProjectUsersUsingGET(filterCntUsers, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get users assigned on current project
     * @param {string} projectName projectName
     * @param {string} [filterEqEmail] Filters by &#39;email&#39;
     * @param {boolean} [filterEqExpired] Filters by &#39;expired&#39;
     * @param {string} [filterEqFullName] Filters by &#39;fullName&#39;
     * @param {number} [filterEqId] Filters by &#39;id&#39;
     * @param {number} [filterEqLastLogin] Filters by &#39;lastLogin&#39;
     * @param {Array<any>} [filterEqProject] Filters by &#39;project&#39;
     * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
     * @param {string} [filterEqRole] Filters by &#39;role&#39;
     * @param {number} [filterEqSynchronizationDate] Filters by &#39;synchronizationDate&#39;
     * @param {string} [filterEqType] Filters by &#39;type&#39;
     * @param {string} [filterEqUser] Filters by &#39;user&#39;
     * @param {number} [pagePage] Results page you want to retrieve (0..N)
     * @param {number} [pageSize] Number of records per page
     * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectControllerApi
     */
    public getProjectUsersUsingGET1(projectName: string, filterEqEmail?: string, filterEqExpired?: boolean, filterEqFullName?: string, filterEqId?: number, filterEqLastLogin?: number, filterEqProject?: Array<any>, filterEqProjectId?: number, filterEqRole?: string, filterEqSynchronizationDate?: number, filterEqType?: string, filterEqUser?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any) {
        return ProjectControllerApiFp(this.configuration).getProjectUsersUsingGET1(projectName, filterEqEmail, filterEqExpired, filterEqFullName, filterEqId, filterEqLastLogin, filterEqProject, filterEqProjectId, filterEqRole, filterEqSynchronizationDate, filterEqType, filterEqUser, pagePage, pageSize, pageSort, options)(this.fetch, this.basePath);
    }

    /**
     * Only for users that are assigned to the project
     * @summary Get information about project
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectControllerApi
     */
    public getProjectUsingGET(projectName: string, options?: any) {
        return ProjectControllerApiFp(this.configuration).getProjectUsingGET(projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary getProjectWidget
     * @param {string} projectName projectName
     * @param {string} widgetCode widgetCode
     * @param {string} [interval] interval
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectControllerApi
     */
    public getProjectWidgetUsingGET(projectName: string, widgetCode: string, interval?: string, options?: any) {
        return ProjectControllerApiFp(this.configuration).getProjectWidgetUsingGET(projectName, widgetCode, interval, options)(this.fetch, this.basePath);
    }

    /**
     * Only for users that allowed to edit other users
     * @summary Load user preferences
     * @param {string} login login
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectControllerApi
     */
    public getUserPreferenceUsingGET(login: string, projectName: string, options?: any) {
        return ProjectControllerApiFp(this.configuration).getUserPreferenceUsingGET(login, projectName, options)(this.fetch, this.basePath);
    }

    /**
     * Only for users with project manager permissions
     * @summary Load users which can be assigned to specified project
     * @param {string} projectName projectName
     * @param {string} [filterEqEmail] Filters by &#39;email&#39;
     * @param {boolean} [filterEqExpired] Filters by &#39;expired&#39;
     * @param {string} [filterEqFullName] Filters by &#39;fullName&#39;
     * @param {number} [filterEqId] Filters by &#39;id&#39;
     * @param {number} [filterEqLastLogin] Filters by &#39;lastLogin&#39;
     * @param {Array<any>} [filterEqProject] Filters by &#39;project&#39;
     * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
     * @param {string} [filterEqRole] Filters by &#39;role&#39;
     * @param {number} [filterEqSynchronizationDate] Filters by &#39;synchronizationDate&#39;
     * @param {string} [filterEqType] Filters by &#39;type&#39;
     * @param {string} [filterEqUser] Filters by &#39;user&#39;
     * @param {number} [pagePage] Results page you want to retrieve (0..N)
     * @param {number} [pageSize] Number of records per page
     * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectControllerApi
     */
    public getUsersForAssignUsingGET(projectName: string, filterEqEmail?: string, filterEqExpired?: boolean, filterEqFullName?: string, filterEqId?: number, filterEqLastLogin?: number, filterEqProject?: Array<any>, filterEqProjectId?: number, filterEqRole?: string, filterEqSynchronizationDate?: number, filterEqType?: string, filterEqUser?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any) {
        return ProjectControllerApiFp(this.configuration).getUsersForAssignUsingGET(projectName, filterEqEmail, filterEqExpired, filterEqFullName, filterEqId, filterEqLastLogin, filterEqProject, filterEqProjectId, filterEqRole, filterEqSynchronizationDate, filterEqType, filterEqUser, pagePage, pageSize, pageSort, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Starts reindex all project data in ML
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectControllerApi
     */
    public indexProjectDataUsingPUT(projectName: string, options?: any) {
        return ProjectControllerApiFp(this.configuration).indexProjectDataUsingPUT(projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary removeUserPreference
     * @param {number} filterId filterId
     * @param {string} login login
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectControllerApi
     */
    public removeUserPreferenceUsingDELETE(filterId: number, login: string, projectName: string, options?: any) {
        return ProjectControllerApiFp(this.configuration).removeUserPreferenceUsingDELETE(filterId, login, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary searchForUser
     * @param {string} projectName projectName
     * @param {string} term term
     * @param {number} [pagePage] Results page you want to retrieve (0..N)
     * @param {number} [pageSize] Number of records per page
     * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectControllerApi
     */
    public searchForUserUsingGET(projectName: string, term: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any) {
        return ProjectControllerApiFp(this.configuration).searchForUserUsingGET(projectName, term, pagePage, pageSize, pageSort, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary searchProjectNames
     * @param {string} term term
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectControllerApi
     */
    public searchProjectNamesUsingGET(term: string, options?: any) {
        return ProjectControllerApiFp(this.configuration).searchProjectNamesUsingGET(term, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Un assign users
     * @param {string} projectName projectName
     * @param {UnassignUsersRQ} unassignUsersRQ unassignUsersRQ
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectControllerApi
     */
    public unassignProjectUsersUsingPUT(projectName: string, unassignUsersRQ: UnassignUsersRQ, options?: any) {
        return ProjectControllerApiFp(this.configuration).unassignProjectUsersUsingPUT(projectName, unassignUsersRQ, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Update project notifications configuration
     * @param {string} projectName projectName
     * @param {ProjectNotificationConfigDTO} updateProjectNotificationConfigRQ updateProjectNotificationConfigRQ
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectControllerApi
     */
    public updateProjectNotificationConfigUsingPUT(projectName: string, updateProjectNotificationConfigRQ: ProjectNotificationConfigDTO, options?: any) {
        return ProjectControllerApiFp(this.configuration).updateProjectNotificationConfigUsingPUT(projectName, updateProjectNotificationConfigRQ, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Update project
     * @param {string} projectName projectName
     * @param {UpdateProjectRQ} updateProjectRQ updateProjectRQ
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectControllerApi
     */
    public updateProjectUsingPUT(projectName: string, updateProjectRQ: UpdateProjectRQ, options?: any) {
        return ProjectControllerApiFp(this.configuration).updateProjectUsingPUT(projectName, updateProjectRQ, options)(this.fetch, this.basePath);
    }

}

/**
 * ProjectSettingsControllerApi - fetch parameter creator
 * @export
 */
export const ProjectSettingsControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Only for users with PROJECT_MANAGER or ADMIN roles
         * @summary Creates notification for specified project
         * @param {SenderCaseDTO} createNotificationRQ createNotificationRQ
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNotificationUsingPOST(createNotificationRQ: SenderCaseDTO, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'createNotificationRQ' is not null or undefined
            if (createNotificationRQ === null || createNotificationRQ === undefined) {
                throw new RequiredError('createNotificationRQ', 'Required parameter createNotificationRQ was null or undefined when calling createNotificationUsingPOST.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling createNotificationUsingPOST.');
            }
            const localVarPath = `/v1/{projectName}/settings/notification`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SenderCaseDTO" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(createNotificationRQ || {}) : (createNotificationRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create pattern template for items' log messages pattern analysis
         * @param {CreatePatternTemplateRQ} createPatternTemplateRQ createPatternTemplateRQ
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPatternTemplateUsingPOST(createPatternTemplateRQ: CreatePatternTemplateRQ, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'createPatternTemplateRQ' is not null or undefined
            if (createPatternTemplateRQ === null || createPatternTemplateRQ === undefined) {
                throw new RequiredError('createPatternTemplateRQ', 'Required parameter createPatternTemplateRQ was null or undefined when calling createPatternTemplateUsingPOST.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling createPatternTemplateUsingPOST.');
            }
            const localVarPath = `/v1/{projectName}/settings/pattern`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreatePatternTemplateRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(createPatternTemplateRQ || {}) : (createPatternTemplateRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Creation of custom project specific issue sub-type
         * @param {string} projectName projectName
         * @param {CreateIssueSubTypeRQ} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectIssueSubTypeUsingPOST(projectName: string, request: CreateIssueSubTypeRQ, options: any = {}): FetchArgs {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling createProjectIssueSubTypeUsingPOST.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request', 'Required parameter request was null or undefined when calling createProjectIssueSubTypeUsingPOST.');
            }
            const localVarPath = `/v1/{projectName}/settings/sub-type`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateIssueSubTypeRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only for users with PROJECT_MANAGER or ADMIN roles
         * @summary Deletes notification for specified project
         * @param {number} notificationId notificationId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotificationUsingDELETE(notificationId: number, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'notificationId' is not null or undefined
            if (notificationId === null || notificationId === undefined) {
                throw new RequiredError('notificationId', 'Required parameter notificationId was null or undefined when calling deleteNotificationUsingDELETE.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling deleteNotificationUsingDELETE.');
            }
            const localVarPath = `/v1/{projectName}/settings/notification/{notificationId}`
                .replace(`{${"notificationId"}}`, encodeURIComponent(String(notificationId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'DELETE'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete pattern template for items' log messages pattern analysis
         * @param {number} id id
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePatternTemplateUsingDELETE(id: number, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling deletePatternTemplateUsingDELETE.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling deletePatternTemplateUsingDELETE.');
            }
            const localVarPath = `/v1/{projectName}/settings/pattern/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'DELETE'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete custom project specific issue sub-type
         * @param {number} id id
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectIssueSubTypeUsingDELETE(id: number, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling deleteProjectIssueSubTypeUsingDELETE.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling deleteProjectIssueSubTypeUsingDELETE.');
            }
            const localVarPath = `/v1/{projectName}/settings/sub-type/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'DELETE'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only for users assigned to specified project
         * @summary Returns notifications config of specified project
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationsUsingGET(projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getNotificationsUsingGET.');
            }
            const localVarPath = `/v1/{projectName}/settings/notification`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only for users that are assigned to the project
         * @summary Get project specific issue sub-types
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectSettingsUsingGET(projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getProjectSettingsUsingGET.');
            }
            const localVarPath = `/v1/{projectName}/settings`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only for users with PROJECT_MANAGER or ADMIN roles
         * @summary Updates notification for specified project
         * @param {string} projectName projectName
         * @param {SenderCaseDTO} updateNotificationRQ updateNotificationRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotificationUsingPUT(projectName: string, updateNotificationRQ: SenderCaseDTO, options: any = {}): FetchArgs {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling updateNotificationUsingPUT.');
            }
            // verify required parameter 'updateNotificationRQ' is not null or undefined
            if (updateNotificationRQ === null || updateNotificationRQ === undefined) {
                throw new RequiredError('updateNotificationRQ', 'Required parameter updateNotificationRQ was null or undefined when calling updateNotificationUsingPUT.');
            }
            const localVarPath = `/v1/{projectName}/settings/notification`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'PUT'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SenderCaseDTO" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(updateNotificationRQ || {}) : (updateNotificationRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update pattern template for items' log messages pattern analysis
         * @param {number} id id
         * @param {string} projectName projectName
         * @param {UpdatePatternTemplateRQ} updatePatternTemplateRQ updatePatternTemplateRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePatternTemplateUsingPUT(id: number, projectName: string, updatePatternTemplateRQ: UpdatePatternTemplateRQ, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling updatePatternTemplateUsingPUT.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling updatePatternTemplateUsingPUT.');
            }
            // verify required parameter 'updatePatternTemplateRQ' is not null or undefined
            if (updatePatternTemplateRQ === null || updatePatternTemplateRQ === undefined) {
                throw new RequiredError('updatePatternTemplateRQ', 'Required parameter updatePatternTemplateRQ was null or undefined when calling updatePatternTemplateUsingPUT.');
            }
            const localVarPath = `/v1/{projectName}/settings/pattern/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'PUT'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdatePatternTemplateRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(updatePatternTemplateRQ || {}) : (updatePatternTemplateRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update of custom project specific issue sub-type
         * @param {string} projectName projectName
         * @param {UpdateIssueSubTypeRQ} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectIssueSubTypeUsingPUT(projectName: string, request: UpdateIssueSubTypeRQ, options: any = {}): FetchArgs {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling updateProjectIssueSubTypeUsingPUT.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request', 'Required parameter request was null or undefined when calling updateProjectIssueSubTypeUsingPUT.');
            }
            const localVarPath = `/v1/{projectName}/settings/sub-type`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'PUT'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateIssueSubTypeRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectSettingsControllerApi - functional programming interface
 * @export
 */
export const ProjectSettingsControllerApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Only for users with PROJECT_MANAGER or ADMIN roles
         * @summary Creates notification for specified project
         * @param {SenderCaseDTO} createNotificationRQ createNotificationRQ
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNotificationUsingPOST(createNotificationRQ: SenderCaseDTO, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EntryCreatedRS> {
            const localVarFetchArgs = ProjectSettingsControllerApiFetchParamCreator(configuration).createNotificationUsingPOST(createNotificationRQ, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create pattern template for items' log messages pattern analysis
         * @param {CreatePatternTemplateRQ} createPatternTemplateRQ createPatternTemplateRQ
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPatternTemplateUsingPOST(createPatternTemplateRQ: CreatePatternTemplateRQ, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EntryCreatedRS> {
            const localVarFetchArgs = ProjectSettingsControllerApiFetchParamCreator(configuration).createPatternTemplateUsingPOST(createPatternTemplateRQ, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Creation of custom project specific issue sub-type
         * @param {string} projectName projectName
         * @param {CreateIssueSubTypeRQ} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectIssueSubTypeUsingPOST(projectName: string, request: CreateIssueSubTypeRQ, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<IssueSubTypeCreatedRS> {
            const localVarFetchArgs = ProjectSettingsControllerApiFetchParamCreator(configuration).createProjectIssueSubTypeUsingPOST(projectName, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Only for users with PROJECT_MANAGER or ADMIN roles
         * @summary Deletes notification for specified project
         * @param {number} notificationId notificationId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotificationUsingDELETE(notificationId: number, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = ProjectSettingsControllerApiFetchParamCreator(configuration).deleteNotificationUsingDELETE(notificationId, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete pattern template for items' log messages pattern analysis
         * @param {number} id id
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePatternTemplateUsingDELETE(id: number, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = ProjectSettingsControllerApiFetchParamCreator(configuration).deletePatternTemplateUsingDELETE(id, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete custom project specific issue sub-type
         * @param {number} id id
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectIssueSubTypeUsingDELETE(id: number, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = ProjectSettingsControllerApiFetchParamCreator(configuration).deleteProjectIssueSubTypeUsingDELETE(id, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Only for users assigned to specified project
         * @summary Returns notifications config of specified project
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationsUsingGET(projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SenderCaseDTO>> {
            const localVarFetchArgs = ProjectSettingsControllerApiFetchParamCreator(configuration).getNotificationsUsingGET(projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Only for users that are assigned to the project
         * @summary Get project specific issue sub-types
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectSettingsUsingGET(projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProjectSettingsResource> {
            const localVarFetchArgs = ProjectSettingsControllerApiFetchParamCreator(configuration).getProjectSettingsUsingGET(projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Only for users with PROJECT_MANAGER or ADMIN roles
         * @summary Updates notification for specified project
         * @param {string} projectName projectName
         * @param {SenderCaseDTO} updateNotificationRQ updateNotificationRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotificationUsingPUT(projectName: string, updateNotificationRQ: SenderCaseDTO, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = ProjectSettingsControllerApiFetchParamCreator(configuration).updateNotificationUsingPUT(projectName, updateNotificationRQ, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update pattern template for items' log messages pattern analysis
         * @param {number} id id
         * @param {string} projectName projectName
         * @param {UpdatePatternTemplateRQ} updatePatternTemplateRQ updatePatternTemplateRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePatternTemplateUsingPUT(id: number, projectName: string, updatePatternTemplateRQ: UpdatePatternTemplateRQ, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = ProjectSettingsControllerApiFetchParamCreator(configuration).updatePatternTemplateUsingPUT(id, projectName, updatePatternTemplateRQ, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update of custom project specific issue sub-type
         * @param {string} projectName projectName
         * @param {UpdateIssueSubTypeRQ} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectIssueSubTypeUsingPUT(projectName: string, request: UpdateIssueSubTypeRQ, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = ProjectSettingsControllerApiFetchParamCreator(configuration).updateProjectIssueSubTypeUsingPUT(projectName, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProjectSettingsControllerApi - factory interface
 * @export
 */
export const ProjectSettingsControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Only for users with PROJECT_MANAGER or ADMIN roles
         * @summary Creates notification for specified project
         * @param {SenderCaseDTO} createNotificationRQ createNotificationRQ
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNotificationUsingPOST(createNotificationRQ: SenderCaseDTO, projectName: string, options?: any) {
            return ProjectSettingsControllerApiFp(configuration).createNotificationUsingPOST(createNotificationRQ, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create pattern template for items' log messages pattern analysis
         * @param {CreatePatternTemplateRQ} createPatternTemplateRQ createPatternTemplateRQ
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPatternTemplateUsingPOST(createPatternTemplateRQ: CreatePatternTemplateRQ, projectName: string, options?: any) {
            return ProjectSettingsControllerApiFp(configuration).createPatternTemplateUsingPOST(createPatternTemplateRQ, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creation of custom project specific issue sub-type
         * @param {string} projectName projectName
         * @param {CreateIssueSubTypeRQ} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProjectIssueSubTypeUsingPOST(projectName: string, request: CreateIssueSubTypeRQ, options?: any) {
            return ProjectSettingsControllerApiFp(configuration).createProjectIssueSubTypeUsingPOST(projectName, request, options)(fetch, basePath);
        },
        /**
         * Only for users with PROJECT_MANAGER or ADMIN roles
         * @summary Deletes notification for specified project
         * @param {number} notificationId notificationId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotificationUsingDELETE(notificationId: number, projectName: string, options?: any) {
            return ProjectSettingsControllerApiFp(configuration).deleteNotificationUsingDELETE(notificationId, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete pattern template for items' log messages pattern analysis
         * @param {number} id id
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePatternTemplateUsingDELETE(id: number, projectName: string, options?: any) {
            return ProjectSettingsControllerApiFp(configuration).deletePatternTemplateUsingDELETE(id, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete custom project specific issue sub-type
         * @param {number} id id
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProjectIssueSubTypeUsingDELETE(id: number, projectName: string, options?: any) {
            return ProjectSettingsControllerApiFp(configuration).deleteProjectIssueSubTypeUsingDELETE(id, projectName, options)(fetch, basePath);
        },
        /**
         * Only for users assigned to specified project
         * @summary Returns notifications config of specified project
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationsUsingGET(projectName: string, options?: any) {
            return ProjectSettingsControllerApiFp(configuration).getNotificationsUsingGET(projectName, options)(fetch, basePath);
        },
        /**
         * Only for users that are assigned to the project
         * @summary Get project specific issue sub-types
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjectSettingsUsingGET(projectName: string, options?: any) {
            return ProjectSettingsControllerApiFp(configuration).getProjectSettingsUsingGET(projectName, options)(fetch, basePath);
        },
        /**
         * Only for users with PROJECT_MANAGER or ADMIN roles
         * @summary Updates notification for specified project
         * @param {string} projectName projectName
         * @param {SenderCaseDTO} updateNotificationRQ updateNotificationRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotificationUsingPUT(projectName: string, updateNotificationRQ: SenderCaseDTO, options?: any) {
            return ProjectSettingsControllerApiFp(configuration).updateNotificationUsingPUT(projectName, updateNotificationRQ, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update pattern template for items' log messages pattern analysis
         * @param {number} id id
         * @param {string} projectName projectName
         * @param {UpdatePatternTemplateRQ} updatePatternTemplateRQ updatePatternTemplateRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePatternTemplateUsingPUT(id: number, projectName: string, updatePatternTemplateRQ: UpdatePatternTemplateRQ, options?: any) {
            return ProjectSettingsControllerApiFp(configuration).updatePatternTemplateUsingPUT(id, projectName, updatePatternTemplateRQ, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update of custom project specific issue sub-type
         * @param {string} projectName projectName
         * @param {UpdateIssueSubTypeRQ} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProjectIssueSubTypeUsingPUT(projectName: string, request: UpdateIssueSubTypeRQ, options?: any) {
            return ProjectSettingsControllerApiFp(configuration).updateProjectIssueSubTypeUsingPUT(projectName, request, options)(fetch, basePath);
        },
    };
};

/**
 * ProjectSettingsControllerApi - object-oriented interface
 * @export
 * @class ProjectSettingsControllerApi
 * @extends {BaseAPI}
 */
export class ProjectSettingsControllerApi extends BaseAPI {
    /**
     * Only for users with PROJECT_MANAGER or ADMIN roles
     * @summary Creates notification for specified project
     * @param {SenderCaseDTO} createNotificationRQ createNotificationRQ
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSettingsControllerApi
     */
    public createNotificationUsingPOST(createNotificationRQ: SenderCaseDTO, projectName: string, options?: any) {
        return ProjectSettingsControllerApiFp(this.configuration).createNotificationUsingPOST(createNotificationRQ, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Create pattern template for items' log messages pattern analysis
     * @param {CreatePatternTemplateRQ} createPatternTemplateRQ createPatternTemplateRQ
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSettingsControllerApi
     */
    public createPatternTemplateUsingPOST(createPatternTemplateRQ: CreatePatternTemplateRQ, projectName: string, options?: any) {
        return ProjectSettingsControllerApiFp(this.configuration).createPatternTemplateUsingPOST(createPatternTemplateRQ, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Creation of custom project specific issue sub-type
     * @param {string} projectName projectName
     * @param {CreateIssueSubTypeRQ} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSettingsControllerApi
     */
    public createProjectIssueSubTypeUsingPOST(projectName: string, request: CreateIssueSubTypeRQ, options?: any) {
        return ProjectSettingsControllerApiFp(this.configuration).createProjectIssueSubTypeUsingPOST(projectName, request, options)(this.fetch, this.basePath);
    }

    /**
     * Only for users with PROJECT_MANAGER or ADMIN roles
     * @summary Deletes notification for specified project
     * @param {number} notificationId notificationId
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSettingsControllerApi
     */
    public deleteNotificationUsingDELETE(notificationId: number, projectName: string, options?: any) {
        return ProjectSettingsControllerApiFp(this.configuration).deleteNotificationUsingDELETE(notificationId, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete pattern template for items' log messages pattern analysis
     * @param {number} id id
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSettingsControllerApi
     */
    public deletePatternTemplateUsingDELETE(id: number, projectName: string, options?: any) {
        return ProjectSettingsControllerApiFp(this.configuration).deletePatternTemplateUsingDELETE(id, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete custom project specific issue sub-type
     * @param {number} id id
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSettingsControllerApi
     */
    public deleteProjectIssueSubTypeUsingDELETE(id: number, projectName: string, options?: any) {
        return ProjectSettingsControllerApiFp(this.configuration).deleteProjectIssueSubTypeUsingDELETE(id, projectName, options)(this.fetch, this.basePath);
    }

    /**
     * Only for users assigned to specified project
     * @summary Returns notifications config of specified project
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSettingsControllerApi
     */
    public getNotificationsUsingGET(projectName: string, options?: any) {
        return ProjectSettingsControllerApiFp(this.configuration).getNotificationsUsingGET(projectName, options)(this.fetch, this.basePath);
    }

    /**
     * Only for users that are assigned to the project
     * @summary Get project specific issue sub-types
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSettingsControllerApi
     */
    public getProjectSettingsUsingGET(projectName: string, options?: any) {
        return ProjectSettingsControllerApiFp(this.configuration).getProjectSettingsUsingGET(projectName, options)(this.fetch, this.basePath);
    }

    /**
     * Only for users with PROJECT_MANAGER or ADMIN roles
     * @summary Updates notification for specified project
     * @param {string} projectName projectName
     * @param {SenderCaseDTO} updateNotificationRQ updateNotificationRQ
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSettingsControllerApi
     */
    public updateNotificationUsingPUT(projectName: string, updateNotificationRQ: SenderCaseDTO, options?: any) {
        return ProjectSettingsControllerApiFp(this.configuration).updateNotificationUsingPUT(projectName, updateNotificationRQ, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Update pattern template for items' log messages pattern analysis
     * @param {number} id id
     * @param {string} projectName projectName
     * @param {UpdatePatternTemplateRQ} updatePatternTemplateRQ updatePatternTemplateRQ
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSettingsControllerApi
     */
    public updatePatternTemplateUsingPUT(id: number, projectName: string, updatePatternTemplateRQ: UpdatePatternTemplateRQ, options?: any) {
        return ProjectSettingsControllerApiFp(this.configuration).updatePatternTemplateUsingPUT(id, projectName, updatePatternTemplateRQ, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Update of custom project specific issue sub-type
     * @param {string} projectName projectName
     * @param {UpdateIssueSubTypeRQ} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectSettingsControllerApi
     */
    public updateProjectIssueSubTypeUsingPUT(projectName: string, request: UpdateIssueSubTypeRQ, options?: any) {
        return ProjectSettingsControllerApiFp(this.configuration).updateProjectIssueSubTypeUsingPUT(projectName, request, options)(this.fetch, this.basePath);
    }

}

/**
 * SettingsControllerApi - fetch parameter creator
 * @export
 */
export const SettingsControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Get server settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerSettingsUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/v1/settings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update analytics settings
         * @param {AnalyticsResource} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveAnalyticsSettingsUsingPOST(request: AnalyticsResource, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request', 'Required parameter request was null or undefined when calling saveAnalyticsSettingsUsingPOST.');
            }
            const localVarPath = `/v1/settings/analytics`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AnalyticsResource" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update analytics settings
         * @param {AnalyticsResource} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveAnalyticsSettingsUsingPUT(request: AnalyticsResource, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request', 'Required parameter request was null or undefined when calling saveAnalyticsSettingsUsingPUT.');
            }
            const localVarPath = `/v1/settings/analytics`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'PUT'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AnalyticsResource" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsControllerApi - functional programming interface
 * @export
 */
export const SettingsControllerApiFp = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Get server settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerSettingsUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{
            [key: string]: string;
        }> {
            const localVarFetchArgs = SettingsControllerApiFetchParamCreator(configuration).getServerSettingsUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update analytics settings
         * @param {AnalyticsResource} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveAnalyticsSettingsUsingPOST(request: AnalyticsResource, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = SettingsControllerApiFetchParamCreator(configuration).saveAnalyticsSettingsUsingPOST(request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update analytics settings
         * @param {AnalyticsResource} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveAnalyticsSettingsUsingPUT(request: AnalyticsResource, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = SettingsControllerApiFetchParamCreator(configuration).saveAnalyticsSettingsUsingPUT(request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SettingsControllerApi - factory interface
 * @export
 */
export const SettingsControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Get server settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerSettingsUsingGET(options?: any) {
            return SettingsControllerApiFp(configuration).getServerSettingsUsingGET(options)(fetch, basePath);
        },
        /**
         *
         * @summary Update analytics settings
         * @param {AnalyticsResource} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveAnalyticsSettingsUsingPOST(request: AnalyticsResource, options?: any) {
            return SettingsControllerApiFp(configuration).saveAnalyticsSettingsUsingPOST(request, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update analytics settings
         * @param {AnalyticsResource} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveAnalyticsSettingsUsingPUT(request: AnalyticsResource, options?: any) {
            return SettingsControllerApiFp(configuration).saveAnalyticsSettingsUsingPUT(request, options)(fetch, basePath);
        },
    };
};

/**
 * SettingsControllerApi - object-oriented interface
 * @export
 * @class SettingsControllerApi
 * @extends {BaseAPI}
 */
export class SettingsControllerApi extends BaseAPI {
    /**
     *
     * @summary Get server settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsControllerApi
     */
    public getServerSettingsUsingGET(options?: any) {
        return SettingsControllerApiFp(this.configuration).getServerSettingsUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Update analytics settings
     * @param {AnalyticsResource} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsControllerApi
     */
    public saveAnalyticsSettingsUsingPOST(request: AnalyticsResource, options?: any) {
        return SettingsControllerApiFp(this.configuration).saveAnalyticsSettingsUsingPOST(request, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Update analytics settings
     * @param {AnalyticsResource} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsControllerApi
     */
    public saveAnalyticsSettingsUsingPUT(request: AnalyticsResource, options?: any) {
        return SettingsControllerApiFp(this.configuration).saveAnalyticsSettingsUsingPUT(request, options)(this.fetch, this.basePath);
    }

}

/**
 * TestItemAsyncControllerApi - fetch parameter creator
 * @export
 */
export const TestItemAsyncControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Finish test item
         * @param {FinishTestItemRQ} finishExecutionRQ finishExecutionRQ
         * @param {string} projectName projectName
         * @param {string} testItemId testItemId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finishTestItemUsingPUT(finishExecutionRQ: FinishTestItemRQ, projectName: string, testItemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'finishExecutionRQ' is not null or undefined
            if (finishExecutionRQ === null || finishExecutionRQ === undefined) {
                throw new RequiredError('finishExecutionRQ', 'Required parameter finishExecutionRQ was null or undefined when calling finishTestItemUsingPUT.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling finishTestItemUsingPUT.');
            }
            // verify required parameter 'testItemId' is not null or undefined
            if (testItemId === null || testItemId === undefined) {
                throw new RequiredError('testItemId', 'Required parameter testItemId was null or undefined when calling finishTestItemUsingPUT.');
            }
            const localVarPath = `/v2/{projectName}/item/{testItemId}`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)))
                .replace(`{${"testItemId"}}`, encodeURIComponent(String(testItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'PUT'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"FinishTestItemRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(finishExecutionRQ || {}) : (finishExecutionRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Start a child test item
         * @param {string} parentItem parentItem
         * @param {string} projectName projectName
         * @param {StartTestItemRQ} startTestItemRQ startTestItemRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startChildItemUsingPOST(parentItem: string, projectName: string, startTestItemRQ: StartTestItemRQ, options: any = {}): FetchArgs {
            // verify required parameter 'parentItem' is not null or undefined
            if (parentItem === null || parentItem === undefined) {
                throw new RequiredError('parentItem', 'Required parameter parentItem was null or undefined when calling startChildItemUsingPOST.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling startChildItemUsingPOST.');
            }
            // verify required parameter 'startTestItemRQ' is not null or undefined
            if (startTestItemRQ === null || startTestItemRQ === undefined) {
                throw new RequiredError('startTestItemRQ', 'Required parameter startTestItemRQ was null or undefined when calling startChildItemUsingPOST.');
            }
            const localVarPath = `/v2/{projectName}/item/{parentItem}`
                .replace(`{${"parentItem"}}`, encodeURIComponent(String(parentItem)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"StartTestItemRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(startTestItemRQ || {}) : (startTestItemRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Start a root test item
         * @param {string} projectName projectName
         * @param {StartTestItemRQ} startTestItemRQ startTestItemRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRootItemUsingPOST(projectName: string, startTestItemRQ: StartTestItemRQ, options: any = {}): FetchArgs {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling startRootItemUsingPOST.');
            }
            // verify required parameter 'startTestItemRQ' is not null or undefined
            if (startTestItemRQ === null || startTestItemRQ === undefined) {
                throw new RequiredError('startTestItemRQ', 'Required parameter startTestItemRQ was null or undefined when calling startRootItemUsingPOST.');
            }
            const localVarPath = `/v2/{projectName}/item`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"StartTestItemRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(startTestItemRQ || {}) : (startTestItemRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TestItemAsyncControllerApi - functional programming interface
 * @export
 */
export const TestItemAsyncControllerApiFp = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Finish test item
         * @param {FinishTestItemRQ} finishExecutionRQ finishExecutionRQ
         * @param {string} projectName projectName
         * @param {string} testItemId testItemId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finishTestItemUsingPUT(finishExecutionRQ: FinishTestItemRQ, projectName: string, testItemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = TestItemAsyncControllerApiFetchParamCreator(configuration).finishTestItemUsingPUT(finishExecutionRQ, projectName, testItemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Start a child test item
         * @param {string} parentItem parentItem
         * @param {string} projectName projectName
         * @param {StartTestItemRQ} startTestItemRQ startTestItemRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startChildItemUsingPOST(parentItem: string, projectName: string, startTestItemRQ: StartTestItemRQ, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EntryCreatedAsyncRS> {
            const localVarFetchArgs = TestItemAsyncControllerApiFetchParamCreator(configuration).startChildItemUsingPOST(parentItem, projectName, startTestItemRQ, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Start a root test item
         * @param {string} projectName projectName
         * @param {StartTestItemRQ} startTestItemRQ startTestItemRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRootItemUsingPOST(projectName: string, startTestItemRQ: StartTestItemRQ, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EntryCreatedAsyncRS> {
            const localVarFetchArgs = TestItemAsyncControllerApiFetchParamCreator(configuration).startRootItemUsingPOST(projectName, startTestItemRQ, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TestItemAsyncControllerApi - factory interface
 * @export
 */
export const TestItemAsyncControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Finish test item
         * @param {FinishTestItemRQ} finishExecutionRQ finishExecutionRQ
         * @param {string} projectName projectName
         * @param {string} testItemId testItemId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finishTestItemUsingPUT(finishExecutionRQ: FinishTestItemRQ, projectName: string, testItemId: string, options?: any) {
            return TestItemAsyncControllerApiFp(configuration).finishTestItemUsingPUT(finishExecutionRQ, projectName, testItemId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Start a child test item
         * @param {string} parentItem parentItem
         * @param {string} projectName projectName
         * @param {StartTestItemRQ} startTestItemRQ startTestItemRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startChildItemUsingPOST(parentItem: string, projectName: string, startTestItemRQ: StartTestItemRQ, options?: any) {
            return TestItemAsyncControllerApiFp(configuration).startChildItemUsingPOST(parentItem, projectName, startTestItemRQ, options)(fetch, basePath);
        },
        /**
         *
         * @summary Start a root test item
         * @param {string} projectName projectName
         * @param {StartTestItemRQ} startTestItemRQ startTestItemRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRootItemUsingPOST(projectName: string, startTestItemRQ: StartTestItemRQ, options?: any) {
            return TestItemAsyncControllerApiFp(configuration).startRootItemUsingPOST(projectName, startTestItemRQ, options)(fetch, basePath);
        },
    };
};

/**
 * TestItemAsyncControllerApi - object-oriented interface
 * @export
 * @class TestItemAsyncControllerApi
 * @extends {BaseAPI}
 */
export class TestItemAsyncControllerApi extends BaseAPI {
    /**
     *
     * @summary Finish test item
     * @param {FinishTestItemRQ} finishExecutionRQ finishExecutionRQ
     * @param {string} projectName projectName
     * @param {string} testItemId testItemId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestItemAsyncControllerApi
     */
    public finishTestItemUsingPUT(finishExecutionRQ: FinishTestItemRQ, projectName: string, testItemId: string, options?: any) {
        return TestItemAsyncControllerApiFp(this.configuration).finishTestItemUsingPUT(finishExecutionRQ, projectName, testItemId, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Start a child test item
     * @param {string} parentItem parentItem
     * @param {string} projectName projectName
     * @param {StartTestItemRQ} startTestItemRQ startTestItemRQ
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestItemAsyncControllerApi
     */
    public startChildItemUsingPOST(parentItem: string, projectName: string, startTestItemRQ: StartTestItemRQ, options?: any) {
        return TestItemAsyncControllerApiFp(this.configuration).startChildItemUsingPOST(parentItem, projectName, startTestItemRQ, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Start a root test item
     * @param {string} projectName projectName
     * @param {StartTestItemRQ} startTestItemRQ startTestItemRQ
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestItemAsyncControllerApi
     */
    public startRootItemUsingPOST(projectName: string, startTestItemRQ: StartTestItemRQ, options?: any) {
        return TestItemAsyncControllerApiFp(this.configuration).startRootItemUsingPOST(projectName, startTestItemRQ, options)(this.fetch, this.basePath);
    }

}

/**
 * TestItemControllerApi - fetch parameter creator
 * @export
 */
export const TestItemControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Bulk update attributes and description
         * @param {BulkInfoUpdateRQ} bulkInfoUpdateRQ bulkInfoUpdateRQ
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateUsingPUT1(bulkInfoUpdateRQ: BulkInfoUpdateRQ, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'bulkInfoUpdateRQ' is not null or undefined
            if (bulkInfoUpdateRQ === null || bulkInfoUpdateRQ === undefined) {
                throw new RequiredError('bulkInfoUpdateRQ', 'Required parameter bulkInfoUpdateRQ was null or undefined when calling bulkUpdateUsingPUT1.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling bulkUpdateUsingPUT1.');
            }
            const localVarPath = `/v1/{projectName}/item/info`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'PUT'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BulkInfoUpdateRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(bulkInfoUpdateRQ || {}) : (bulkInfoUpdateRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update issues of specified test items
         * @param {string} projectName projectName
         * @param {DefineIssueRQ} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defineTestItemIssueTypeUsingPUT(projectName: string, request: DefineIssueRQ, options: any = {}): FetchArgs {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling defineTestItemIssueTypeUsingPUT.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request', 'Required parameter request was null or undefined when calling defineTestItemIssueTypeUsingPUT.');
            }
            const localVarPath = `/v1/{projectName}/item`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'PUT'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DefineIssueRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete test item
         * @param {number} itemId itemId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTestItemUsingDELETE(itemId: number, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId', 'Required parameter itemId was null or undefined when calling deleteTestItemUsingDELETE.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling deleteTestItemUsingDELETE.');
            }
            const localVarPath = `/v1/{projectName}/item/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'DELETE'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete test items by specified ids
         * @param {Array<number>} ids ids
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTestItemsUsingDELETE(ids: Array<number>, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'ids' is not null or undefined
            if (ids === null || ids === undefined) {
                throw new RequiredError('ids', 'Required parameter ids was null or undefined when calling deleteTestItemsUsingDELETE.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling deleteTestItemsUsingDELETE.');
            }
            const localVarPath = `/v1/{projectName}/item`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'DELETE'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Finish test item
         * @param {FinishTestItemRQ} finishExecutionRQ finishExecutionRQ
         * @param {string} projectName projectName
         * @param {string} testItemId testItemId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finishTestItemUsingPUT1(finishExecutionRQ: FinishTestItemRQ, projectName: string, testItemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'finishExecutionRQ' is not null or undefined
            if (finishExecutionRQ === null || finishExecutionRQ === undefined) {
                throw new RequiredError('finishExecutionRQ', 'Required parameter finishExecutionRQ was null or undefined when calling finishTestItemUsingPUT1.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling finishTestItemUsingPUT1.');
            }
            // verify required parameter 'testItemId' is not null or undefined
            if (testItemId === null || testItemId === undefined) {
                throw new RequiredError('testItemId', 'Required parameter testItemId was null or undefined when calling finishTestItemUsingPUT1.');
            }
            const localVarPath = `/v1/{projectName}/item/{testItemId}`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)))
                .replace(`{${"testItemId"}}`, encodeURIComponent(String(testItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'PUT'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"FinishTestItemRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(finishExecutionRQ || {}) : (finishExecutionRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all unique attribute keys of specified launch
         * @param {string} filterCntAttributeKey filter.cnt.attributeKey
         * @param {number} filterId filterId
         * @param {string} projectName projectName
         * @param {boolean} [isLatest] isLatest
         * @param {number} [launchesLimit] launchesLimit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributeKeysForProjectUsingGET(filterCntAttributeKey: string, filterId: number, projectName: string, isLatest?: boolean, launchesLimit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'filterCntAttributeKey' is not null or undefined
            if (filterCntAttributeKey === null || filterCntAttributeKey === undefined) {
                throw new RequiredError('filterCntAttributeKey', 'Required parameter filterCntAttributeKey was null or undefined when calling getAttributeKeysForProjectUsingGET.');
            }
            // verify required parameter 'filterId' is not null or undefined
            if (filterId === null || filterId === undefined) {
                throw new RequiredError('filterId', 'Required parameter filterId was null or undefined when calling getAttributeKeysForProjectUsingGET.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getAttributeKeysForProjectUsingGET.');
            }
            const localVarPath = `/v1/{projectName}/item/attribute/keys/all`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filterCntAttributeKey !== undefined) {
                localVarQueryParameter['filter.cnt.attributeKey'] = filterCntAttributeKey;
            }

            if (filterId !== undefined) {
                localVarQueryParameter['filterId'] = filterId;
            }

            if (isLatest !== undefined) {
                localVarQueryParameter['isLatest'] = isLatest;
            }

            if (launchesLimit !== undefined) {
                localVarQueryParameter['launchesLimit'] = launchesLimit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all unique attribute keys of specified launch
         * @param {string} filterCntAttributeKey filter.cnt.attributeKey
         * @param {number} launch launch
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributeKeysUsingGET1(filterCntAttributeKey: string, launch: number, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'filterCntAttributeKey' is not null or undefined
            if (filterCntAttributeKey === null || filterCntAttributeKey === undefined) {
                throw new RequiredError('filterCntAttributeKey', 'Required parameter filterCntAttributeKey was null or undefined when calling getAttributeKeysUsingGET1.');
            }
            // verify required parameter 'launch' is not null or undefined
            if (launch === null || launch === undefined) {
                throw new RequiredError('launch', 'Required parameter launch was null or undefined when calling getAttributeKeysUsingGET1.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getAttributeKeysUsingGET1.');
            }
            const localVarPath = `/v1/{projectName}/item/attribute/keys`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filterCntAttributeKey !== undefined) {
                localVarQueryParameter['filter.cnt.attributeKey'] = filterCntAttributeKey;
            }

            if (launch !== undefined) {
                localVarQueryParameter['launch'] = launch;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all unique attribute keys of step items under specified project
         * @param {string} filterCntAttributeKey filter.cnt.attributeKey
         * @param {string} projectName projectName
         * @param {string} [filterEqName] filter.eq.name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributeKeysUsingGET2(filterCntAttributeKey: string, projectName: string, filterEqName?: string, options: any = {}): FetchArgs {
            // verify required parameter 'filterCntAttributeKey' is not null or undefined
            if (filterCntAttributeKey === null || filterCntAttributeKey === undefined) {
                throw new RequiredError('filterCntAttributeKey', 'Required parameter filterCntAttributeKey was null or undefined when calling getAttributeKeysUsingGET2.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getAttributeKeysUsingGET2.');
            }
            const localVarPath = `/v1/{projectName}/item/step/attribute/keys`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filterCntAttributeKey !== undefined) {
                localVarQueryParameter['filter.cnt.attributeKey'] = filterCntAttributeKey;
            }

            if (filterEqName !== undefined) {
                localVarQueryParameter['filter.eq.name'] = filterEqName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all unique attribute values of specified launch
         * @param {string} filterCntAttributeValue filter.cnt.attributeValue
         * @param {number} launch launch
         * @param {string} projectName projectName
         * @param {string} [filterEqAttributeKey] filter.eq.attributeKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributeValuesUsingGET1(filterCntAttributeValue: string, launch: number, projectName: string, filterEqAttributeKey?: string, options: any = {}): FetchArgs {
            // verify required parameter 'filterCntAttributeValue' is not null or undefined
            if (filterCntAttributeValue === null || filterCntAttributeValue === undefined) {
                throw new RequiredError('filterCntAttributeValue', 'Required parameter filterCntAttributeValue was null or undefined when calling getAttributeValuesUsingGET1.');
            }
            // verify required parameter 'launch' is not null or undefined
            if (launch === null || launch === undefined) {
                throw new RequiredError('launch', 'Required parameter launch was null or undefined when calling getAttributeValuesUsingGET1.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getAttributeValuesUsingGET1.');
            }
            const localVarPath = `/v1/{projectName}/item/attribute/values`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filterCntAttributeValue !== undefined) {
                localVarQueryParameter['filter.cnt.attributeValue'] = filterCntAttributeValue;
            }

            if (filterEqAttributeKey !== undefined) {
                localVarQueryParameter['filter.eq.attributeKey'] = filterEqAttributeKey;
            }

            if (launch !== undefined) {
                localVarQueryParameter['launch'] = launch;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all unique attribute values of step items under specified project
         * @param {string} filterCntAttributeValue filter.cnt.attributeValue
         * @param {string} projectName projectName
         * @param {string} [filterEqAttributeKey] filter.eq.attributeKey
         * @param {string} [filterEqName] filter.eq.name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributeValuesUsingGET2(filterCntAttributeValue: string, projectName: string, filterEqAttributeKey?: string, filterEqName?: string, options: any = {}): FetchArgs {
            // verify required parameter 'filterCntAttributeValue' is not null or undefined
            if (filterCntAttributeValue === null || filterCntAttributeValue === undefined) {
                throw new RequiredError('filterCntAttributeValue', 'Required parameter filterCntAttributeValue was null or undefined when calling getAttributeValuesUsingGET2.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getAttributeValuesUsingGET2.');
            }
            const localVarPath = `/v1/{projectName}/item/step/attribute/values`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filterCntAttributeValue !== undefined) {
                localVarQueryParameter['filter.cnt.attributeValue'] = filterCntAttributeValue;
            }

            if (filterEqAttributeKey !== undefined) {
                localVarQueryParameter['filter.eq.attributeKey'] = filterEqAttributeKey;
            }

            if (filterEqName !== undefined) {
                localVarQueryParameter['filter.eq.name'] = filterEqName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Load history of test items
         * @param {string} projectName projectName
         * @param {Array<any>} [filterEqAttributeKey] Filters by &#39;attributeKey&#39;
         * @param {Array<any>} [filterEqAttributeValue] Filters by &#39;attributeValue&#39;
         * @param {boolean} [filterEqAutoAnalyzed] Filters by &#39;autoAnalyzed&#39;
         * @param {number} [filterEqClusterId] Filters by &#39;clusterId&#39;
         * @param {Array<string>} [filterEqCompositeAttribute] Filters by &#39;compositeAttribute&#39;
         * @param {Array<string>} [filterEqCompositeSystemAttribute] Filters by &#39;compositeSystemAttribute&#39;
         * @param {string} [filterEqDescription] Filters by &#39;description&#39;
         * @param {number} [filterEqDuration] Filters by &#39;duration&#39;
         * @param {Date} [filterEqEndTime] Filters by &#39;endTime&#39;
         * @param {boolean} [filterEqHasChildren] Filters by &#39;hasChildren&#39;
         * @param {boolean} [filterEqHasRetries] Filters by &#39;hasRetries&#39;
         * @param {boolean} [filterEqHasStats] Filters by &#39;hasStats&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {boolean} [filterEqIgnoreAnalyzer] Filters by &#39;ignoreAnalyzer&#39;
         * @param {string} [filterEqIssueComment] Filters by &#39;issueComment&#39;
         * @param {number} [filterEqIssueGroupId] Filters by &#39;issueGroupId&#39;
         * @param {number} [filterEqIssueId] Filters by &#39;issueId&#39;
         * @param {string} [filterEqIssueType] Filters by &#39;issueType&#39;
         * @param {number} [filterEqIssueTypeId] Filters by &#39;issueTypeId&#39;
         * @param {string} [filterEqKey] Filters by &#39;key&#39;
         * @param {string} [filterEqLastModified] Filters by &#39;lastModified&#39;
         * @param {number} [filterEqLaunchId] Filters by &#39;launchId&#39;
         * @param {Array<any>} [filterEqLevelAttribute] Filters by &#39;levelAttribute&#39;
         * @param {string} [filterEqLocator] Filters by &#39;locator&#39;
         * @param {string} [filterEqMode] Filters by &#39;mode&#39;
         * @param {string} [filterEqName] Filters by &#39;name&#39;
         * @param {number} [filterEqParentId] Filters by &#39;parentId&#39;
         * @param {number} [filterEqParentId2] Filters by &#39;parentId&#39;
         * @param {number} [filterEqPath] Filters by &#39;path&#39;
         * @param {Array<any>} [filterEqPatternName] Filters by &#39;patternName&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {number} [filterEqRetryParentId] Filters by &#39;retryParentId&#39;
         * @param {Date} [filterEqStartTime] Filters by &#39;startTime&#39;
         * @param {number} [filterEqStatisticsdefectsautomationBugab001] Filters by &#39;statistics$defects$automation_bug$ab001&#39;
         * @param {number} [filterEqStatisticsdefectsnoDefectnd001] Filters by &#39;statistics$defects$no_defect$nd001&#39;
         * @param {number} [filterEqStatisticsdefectsproductBugpb001] Filters by &#39;statistics$defects$product_bug$pb001&#39;
         * @param {number} [filterEqStatisticsdefectssystemIssuesi001] Filters by &#39;statistics$defects$system_issue$si001&#39;
         * @param {number} [filterEqStatisticsdefectstoInvestigateti001] Filters by &#39;statistics$defects$to_investigate$ti001&#39;
         * @param {number} [filterEqStatisticsexecutionsfailed] Filters by &#39;statistics$executions$failed&#39;
         * @param {number} [filterEqStatisticsexecutionspassed] Filters by &#39;statistics$executions$passed&#39;
         * @param {number} [filterEqStatisticsexecutionsskipped] Filters by &#39;statistics$executions$skipped&#39;
         * @param {number} [filterEqStatisticsexecutionstotal] Filters by &#39;statistics$executions$total&#39;
         * @param {string} [filterEqStatus] Filters by &#39;status&#39;
         * @param {number} [filterEqTestCaseHash] Filters by &#39;testCaseHash&#39;
         * @param {string} [filterEqTestCaseId] Filters by &#39;testCaseId&#39;
         * @param {string} [filterEqTicketId] Filters by &#39;ticketId&#39;
         * @param {string} [filterEqType] Filters by &#39;type&#39;
         * @param {string} [filterEqUniqueId] Filters by &#39;uniqueId&#39;
         * @param {string} [filterEqUuid] Filters by &#39;uuid&#39;
         * @param {string} [filterEqValue] Filters by &#39;value&#39;
         * @param {number} [filterId] filterId
         * @param {number} [historyDepth] historyDepth
         * @param {boolean} [isLatest] isLatest
         * @param {number} [launchesLimit] launchesLimit
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {string} [type] type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsHistoryUsingGET(projectName: string, filterEqAttributeKey?: Array<any>, filterEqAttributeValue?: Array<any>, filterEqAutoAnalyzed?: boolean, filterEqClusterId?: number, filterEqCompositeAttribute?: Array<string>, filterEqCompositeSystemAttribute?: Array<string>, filterEqDescription?: string, filterEqDuration?: number, filterEqEndTime?: Date, filterEqHasChildren?: boolean, filterEqHasRetries?: boolean, filterEqHasStats?: boolean, filterEqId?: number, filterEqIgnoreAnalyzer?: boolean, filterEqIssueComment?: string, filterEqIssueGroupId?: number, filterEqIssueId?: number, filterEqIssueType?: string, filterEqIssueTypeId?: number, filterEqKey?: string, filterEqLastModified?: string, filterEqLaunchId?: number, filterEqLevelAttribute?: Array<any>, filterEqLocator?: string, filterEqMode?: string, filterEqName?: string, filterEqParentId?: number, filterEqParentId2?: number, filterEqPath?: number, filterEqPatternName?: Array<any>, filterEqProjectId?: number, filterEqRetryParentId?: number, filterEqStartTime?: Date, filterEqStatisticsdefectsautomationBugab001?: number, filterEqStatisticsdefectsnoDefectnd001?: number, filterEqStatisticsdefectsproductBugpb001?: number, filterEqStatisticsdefectssystemIssuesi001?: number, filterEqStatisticsdefectstoInvestigateti001?: number, filterEqStatisticsexecutionsfailed?: number, filterEqStatisticsexecutionspassed?: number, filterEqStatisticsexecutionsskipped?: number, filterEqStatisticsexecutionstotal?: number, filterEqStatus?: string, filterEqTestCaseHash?: number, filterEqTestCaseId?: string, filterEqTicketId?: string, filterEqType?: string, filterEqUniqueId?: string, filterEqUuid?: string, filterEqValue?: string, filterId?: number, historyDepth?: number, isLatest?: boolean, launchesLimit?: number, pagePage?: number, pageSize?: number, pageSort?: Array<string>, type?: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getItemsHistoryUsingGET.');
            }
            const localVarPath = `/v1/{projectName}/item/history`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filterEqAttributeKey) {
                localVarQueryParameter['filter.eq.attributeKey'] = filterEqAttributeKey;
            }

            if (filterEqAttributeValue) {
                localVarQueryParameter['filter.eq.attributeValue'] = filterEqAttributeValue;
            }

            if (filterEqAutoAnalyzed !== undefined) {
                localVarQueryParameter['filter.eq.autoAnalyzed'] = filterEqAutoAnalyzed;
            }

            if (filterEqClusterId !== undefined) {
                localVarQueryParameter['filter.eq.clusterId'] = filterEqClusterId;
            }

            if (filterEqCompositeAttribute) {
                localVarQueryParameter['filter.eq.compositeAttribute'] = filterEqCompositeAttribute;
            }

            if (filterEqCompositeSystemAttribute) {
                localVarQueryParameter['filter.eq.compositeSystemAttribute'] = filterEqCompositeSystemAttribute;
            }

            if (filterEqDescription !== undefined) {
                localVarQueryParameter['filter.eq.description'] = filterEqDescription;
            }

            if (filterEqDuration !== undefined) {
                localVarQueryParameter['filter.eq.duration'] = filterEqDuration;
            }

            if (filterEqEndTime !== undefined) {
                localVarQueryParameter['filter.eq.endTime'] = (filterEqEndTime as any).toISOString();
            }

            if (filterEqHasChildren !== undefined) {
                localVarQueryParameter['filter.eq.hasChildren'] = filterEqHasChildren;
            }

            if (filterEqHasRetries !== undefined) {
                localVarQueryParameter['filter.eq.hasRetries'] = filterEqHasRetries;
            }

            if (filterEqHasStats !== undefined) {
                localVarQueryParameter['filter.eq.hasStats'] = filterEqHasStats;
            }

            if (filterEqId !== undefined) {
                localVarQueryParameter['filter.eq.id'] = filterEqId;
            }

            if (filterEqIgnoreAnalyzer !== undefined) {
                localVarQueryParameter['filter.eq.ignoreAnalyzer'] = filterEqIgnoreAnalyzer;
            }

            if (filterEqIssueComment !== undefined) {
                localVarQueryParameter['filter.eq.issueComment'] = filterEqIssueComment;
            }

            if (filterEqIssueGroupId !== undefined) {
                localVarQueryParameter['filter.eq.issueGroupId'] = filterEqIssueGroupId;
            }

            if (filterEqIssueId !== undefined) {
                localVarQueryParameter['filter.eq.issueId'] = filterEqIssueId;
            }

            if (filterEqIssueType !== undefined) {
                localVarQueryParameter['filter.eq.issueType'] = filterEqIssueType;
            }

            if (filterEqIssueTypeId !== undefined) {
                localVarQueryParameter['filter.eq.issueTypeId'] = filterEqIssueTypeId;
            }

            if (filterEqKey !== undefined) {
                localVarQueryParameter['filter.eq.key'] = filterEqKey;
            }

            if (filterEqLastModified !== undefined) {
                localVarQueryParameter['filter.eq.lastModified'] = filterEqLastModified;
            }

            if (filterEqLaunchId !== undefined) {
                localVarQueryParameter['filter.eq.launchId'] = filterEqLaunchId;
            }

            if (filterEqLevelAttribute) {
                localVarQueryParameter['filter.eq.levelAttribute'] = filterEqLevelAttribute;
            }

            if (filterEqLocator !== undefined) {
                localVarQueryParameter['filter.eq.locator'] = filterEqLocator;
            }

            if (filterEqMode !== undefined) {
                localVarQueryParameter['filter.eq.mode'] = filterEqMode;
            }

            if (filterEqName !== undefined) {
                localVarQueryParameter['filter.eq.name'] = filterEqName;
            }

            if (filterEqParentId !== undefined) {
                localVarQueryParameter['filter.eq.parentId'] = filterEqParentId;
            }

            if (filterEqParentId2 !== undefined) {
                localVarQueryParameter['filter.eq.parentId'] = filterEqParentId2;
            }

            if (filterEqPath !== undefined) {
                localVarQueryParameter['filter.eq.path'] = filterEqPath;
            }

            if (filterEqPatternName) {
                localVarQueryParameter['filter.eq.patternName'] = filterEqPatternName;
            }

            if (filterEqProjectId !== undefined) {
                localVarQueryParameter['filter.eq.projectId'] = filterEqProjectId;
            }

            if (filterEqRetryParentId !== undefined) {
                localVarQueryParameter['filter.eq.retryParentId'] = filterEqRetryParentId;
            }

            if (filterEqStartTime !== undefined) {
                localVarQueryParameter['filter.eq.startTime'] = (filterEqStartTime as any).toISOString();
            }

            if (filterEqStatisticsdefectsautomationBugab001 !== undefined) {
                localVarQueryParameter['filter.eq.statistics$defects$automation_bug$ab001'] = filterEqStatisticsdefectsautomationBugab001;
            }

            if (filterEqStatisticsdefectsnoDefectnd001 !== undefined) {
                localVarQueryParameter['filter.eq.statistics$defects$no_defect$nd001'] = filterEqStatisticsdefectsnoDefectnd001;
            }

            if (filterEqStatisticsdefectsproductBugpb001 !== undefined) {
                localVarQueryParameter['filter.eq.statistics$defects$product_bug$pb001'] = filterEqStatisticsdefectsproductBugpb001;
            }

            if (filterEqStatisticsdefectssystemIssuesi001 !== undefined) {
                localVarQueryParameter['filter.eq.statistics$defects$system_issue$si001'] = filterEqStatisticsdefectssystemIssuesi001;
            }

            if (filterEqStatisticsdefectstoInvestigateti001 !== undefined) {
                localVarQueryParameter['filter.eq.statistics$defects$to_investigate$ti001'] = filterEqStatisticsdefectstoInvestigateti001;
            }

            if (filterEqStatisticsexecutionsfailed !== undefined) {
                localVarQueryParameter['filter.eq.statistics$executions$failed'] = filterEqStatisticsexecutionsfailed;
            }

            if (filterEqStatisticsexecutionspassed !== undefined) {
                localVarQueryParameter['filter.eq.statistics$executions$passed'] = filterEqStatisticsexecutionspassed;
            }

            if (filterEqStatisticsexecutionsskipped !== undefined) {
                localVarQueryParameter['filter.eq.statistics$executions$skipped'] = filterEqStatisticsexecutionsskipped;
            }

            if (filterEqStatisticsexecutionstotal !== undefined) {
                localVarQueryParameter['filter.eq.statistics$executions$total'] = filterEqStatisticsexecutionstotal;
            }

            if (filterEqStatus !== undefined) {
                localVarQueryParameter['filter.eq.status'] = filterEqStatus;
            }

            if (filterEqTestCaseHash !== undefined) {
                localVarQueryParameter['filter.eq.testCaseHash'] = filterEqTestCaseHash;
            }

            if (filterEqTestCaseId !== undefined) {
                localVarQueryParameter['filter.eq.testCaseId'] = filterEqTestCaseId;
            }

            if (filterEqTicketId !== undefined) {
                localVarQueryParameter['filter.eq.ticketId'] = filterEqTicketId;
            }

            if (filterEqType !== undefined) {
                localVarQueryParameter['filter.eq.type'] = filterEqType;
            }

            if (filterEqUniqueId !== undefined) {
                localVarQueryParameter['filter.eq.uniqueId'] = filterEqUniqueId;
            }

            if (filterEqUuid !== undefined) {
                localVarQueryParameter['filter.eq.uuid'] = filterEqUuid;
            }

            if (filterEqValue !== undefined) {
                localVarQueryParameter['filter.eq.value'] = filterEqValue;
            }

            if (filterId !== undefined) {
                localVarQueryParameter['filterId'] = filterId;
            }

            if (historyDepth !== undefined) {
                localVarQueryParameter['historyDepth'] = historyDepth;
            }

            if (isLatest !== undefined) {
                localVarQueryParameter['isLatest'] = isLatest;
            }

            if (launchesLimit !== undefined) {
                localVarQueryParameter['launchesLimit'] = launchesLimit;
            }

            if (pagePage !== undefined) {
                localVarQueryParameter['page.page'] = pagePage;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page.size'] = pageSize;
            }

            if (pageSort) {
                localVarQueryParameter['page.sort'] = pageSort;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Search suggested items in analyzer for provided one
         * @param {number} clusterId clusterId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSuggestedClusterItemsUsingGET(clusterId: number, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'clusterId' is not null or undefined
            if (clusterId === null || clusterId === undefined) {
                throw new RequiredError('clusterId', 'Required parameter clusterId was null or undefined when calling getSuggestedClusterItemsUsingGET.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getSuggestedClusterItemsUsingGET.');
            }
            const localVarPath = `/v1/{projectName}/item/suggest/cluster/{clusterId}`
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Search suggested items in analyzer for provided one
         * @param {number} itemId itemId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSuggestedItemsUsingGET(itemId: number, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId', 'Required parameter itemId was null or undefined when calling getSuggestedItemsUsingGET.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getSuggestedItemsUsingGET.');
            }
            const localVarPath = `/v1/{projectName}/item/suggest/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find test item by UUID
         * @param {string} itemId itemId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestItemByUuidUsingGET(itemId: string, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId', 'Required parameter itemId was null or undefined when calling getTestItemByUuidUsingGET.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getTestItemByUuidUsingGET.');
            }
            const localVarPath = `/v1/{projectName}/item/uuid/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find test item by ID
         * @param {string} itemId itemId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestItemUsingGET(itemId: string, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId', 'Required parameter itemId was null or undefined when calling getTestItemUsingGET.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getTestItemUsingGET.');
            }
            const localVarPath = `/v1/{projectName}/item/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get test items by specified ids
         * @param {Array<number>} ids ids
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestItemsUsingGET(ids: Array<number>, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'ids' is not null or undefined
            if (ids === null || ids === undefined) {
                throw new RequiredError('ids', 'Required parameter ids was null or undefined when calling getTestItemsUsingGET.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getTestItemsUsingGET.');
            }
            const localVarPath = `/v1/{projectName}/item/items`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find accumulated statistics of items by specified filter
         * @param {any} params params
         * @param {string} projectName projectName
         * @param {Array<any>} [filterEqAttributeKey] Filters by &#39;attributeKey&#39;
         * @param {Array<any>} [filterEqAttributeValue] Filters by &#39;attributeValue&#39;
         * @param {boolean} [filterEqAutoAnalyzed] Filters by &#39;autoAnalyzed&#39;
         * @param {number} [filterEqClusterId] Filters by &#39;clusterId&#39;
         * @param {Array<string>} [filterEqCompositeAttribute] Filters by &#39;compositeAttribute&#39;
         * @param {Array<string>} [filterEqCompositeSystemAttribute] Filters by &#39;compositeSystemAttribute&#39;
         * @param {string} [filterEqDescription] Filters by &#39;description&#39;
         * @param {number} [filterEqDuration] Filters by &#39;duration&#39;
         * @param {Date} [filterEqEndTime] Filters by &#39;endTime&#39;
         * @param {boolean} [filterEqHasChildren] Filters by &#39;hasChildren&#39;
         * @param {boolean} [filterEqHasRetries] Filters by &#39;hasRetries&#39;
         * @param {boolean} [filterEqHasStats] Filters by &#39;hasStats&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {boolean} [filterEqIgnoreAnalyzer] Filters by &#39;ignoreAnalyzer&#39;
         * @param {string} [filterEqIssueComment] Filters by &#39;issueComment&#39;
         * @param {number} [filterEqIssueGroupId] Filters by &#39;issueGroupId&#39;
         * @param {number} [filterEqIssueId] Filters by &#39;issueId&#39;
         * @param {string} [filterEqIssueType] Filters by &#39;issueType&#39;
         * @param {number} [filterEqIssueTypeId] Filters by &#39;issueTypeId&#39;
         * @param {string} [filterEqKey] Filters by &#39;key&#39;
         * @param {string} [filterEqLastModified] Filters by &#39;lastModified&#39;
         * @param {number} [filterEqLaunchId] Filters by &#39;launchId&#39;
         * @param {Array<any>} [filterEqLevelAttribute] Filters by &#39;levelAttribute&#39;
         * @param {string} [filterEqLocator] Filters by &#39;locator&#39;
         * @param {string} [filterEqMode] Filters by &#39;mode&#39;
         * @param {string} [filterEqName] Filters by &#39;name&#39;
         * @param {number} [filterEqParentId] Filters by &#39;parentId&#39;
         * @param {number} [filterEqParentId2] Filters by &#39;parentId&#39;
         * @param {number} [filterEqPath] Filters by &#39;path&#39;
         * @param {Array<any>} [filterEqPatternName] Filters by &#39;patternName&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {number} [filterEqRetryParentId] Filters by &#39;retryParentId&#39;
         * @param {Date} [filterEqStartTime] Filters by &#39;startTime&#39;
         * @param {number} [filterEqStatisticsdefectsautomationBugab001] Filters by &#39;statistics$defects$automation_bug$ab001&#39;
         * @param {number} [filterEqStatisticsdefectsnoDefectnd001] Filters by &#39;statistics$defects$no_defect$nd001&#39;
         * @param {number} [filterEqStatisticsdefectsproductBugpb001] Filters by &#39;statistics$defects$product_bug$pb001&#39;
         * @param {number} [filterEqStatisticsdefectssystemIssuesi001] Filters by &#39;statistics$defects$system_issue$si001&#39;
         * @param {number} [filterEqStatisticsdefectstoInvestigateti001] Filters by &#39;statistics$defects$to_investigate$ti001&#39;
         * @param {number} [filterEqStatisticsexecutionsfailed] Filters by &#39;statistics$executions$failed&#39;
         * @param {number} [filterEqStatisticsexecutionspassed] Filters by &#39;statistics$executions$passed&#39;
         * @param {number} [filterEqStatisticsexecutionsskipped] Filters by &#39;statistics$executions$skipped&#39;
         * @param {number} [filterEqStatisticsexecutionstotal] Filters by &#39;statistics$executions$total&#39;
         * @param {string} [filterEqStatus] Filters by &#39;status&#39;
         * @param {number} [filterEqTestCaseHash] Filters by &#39;testCaseHash&#39;
         * @param {string} [filterEqTestCaseId] Filters by &#39;testCaseId&#39;
         * @param {string} [filterEqTicketId] Filters by &#39;ticketId&#39;
         * @param {string} [filterEqType] Filters by &#39;type&#39;
         * @param {string} [filterEqUniqueId] Filters by &#39;uniqueId&#39;
         * @param {string} [filterEqUuid] Filters by &#39;uuid&#39;
         * @param {string} [filterEqValue] Filters by &#39;value&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestItemsUsingGET1(params: any, projectName: string, filterEqAttributeKey?: Array<any>, filterEqAttributeValue?: Array<any>, filterEqAutoAnalyzed?: boolean, filterEqClusterId?: number, filterEqCompositeAttribute?: Array<string>, filterEqCompositeSystemAttribute?: Array<string>, filterEqDescription?: string, filterEqDuration?: number, filterEqEndTime?: Date, filterEqHasChildren?: boolean, filterEqHasRetries?: boolean, filterEqHasStats?: boolean, filterEqId?: number, filterEqIgnoreAnalyzer?: boolean, filterEqIssueComment?: string, filterEqIssueGroupId?: number, filterEqIssueId?: number, filterEqIssueType?: string, filterEqIssueTypeId?: number, filterEqKey?: string, filterEqLastModified?: string, filterEqLaunchId?: number, filterEqLevelAttribute?: Array<any>, filterEqLocator?: string, filterEqMode?: string, filterEqName?: string, filterEqParentId?: number, filterEqParentId2?: number, filterEqPath?: number, filterEqPatternName?: Array<any>, filterEqProjectId?: number, filterEqRetryParentId?: number, filterEqStartTime?: Date, filterEqStatisticsdefectsautomationBugab001?: number, filterEqStatisticsdefectsnoDefectnd001?: number, filterEqStatisticsdefectsproductBugpb001?: number, filterEqStatisticsdefectssystemIssuesi001?: number, filterEqStatisticsdefectstoInvestigateti001?: number, filterEqStatisticsexecutionsfailed?: number, filterEqStatisticsexecutionspassed?: number, filterEqStatisticsexecutionsskipped?: number, filterEqStatisticsexecutionstotal?: number, filterEqStatus?: string, filterEqTestCaseHash?: number, filterEqTestCaseId?: string, filterEqTicketId?: string, filterEqType?: string, filterEqUniqueId?: string, filterEqUuid?: string, filterEqValue?: string, options: any = {}): FetchArgs {
            // verify required parameter 'params' is not null or undefined
            if (params === null || params === undefined) {
                throw new RequiredError('params', 'Required parameter params was null or undefined when calling getTestItemsUsingGET1.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getTestItemsUsingGET1.');
            }
            const localVarPath = `/v1/{projectName}/item/statistics`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filterEqAttributeKey) {
                localVarQueryParameter['filter.eq.attributeKey'] = filterEqAttributeKey;
            }

            if (filterEqAttributeValue) {
                localVarQueryParameter['filter.eq.attributeValue'] = filterEqAttributeValue;
            }

            if (filterEqAutoAnalyzed !== undefined) {
                localVarQueryParameter['filter.eq.autoAnalyzed'] = filterEqAutoAnalyzed;
            }

            if (filterEqClusterId !== undefined) {
                localVarQueryParameter['filter.eq.clusterId'] = filterEqClusterId;
            }

            if (filterEqCompositeAttribute) {
                localVarQueryParameter['filter.eq.compositeAttribute'] = filterEqCompositeAttribute;
            }

            if (filterEqCompositeSystemAttribute) {
                localVarQueryParameter['filter.eq.compositeSystemAttribute'] = filterEqCompositeSystemAttribute;
            }

            if (filterEqDescription !== undefined) {
                localVarQueryParameter['filter.eq.description'] = filterEqDescription;
            }

            if (filterEqDuration !== undefined) {
                localVarQueryParameter['filter.eq.duration'] = filterEqDuration;
            }

            if (filterEqEndTime !== undefined) {
                localVarQueryParameter['filter.eq.endTime'] = (filterEqEndTime as any).toISOString();
            }

            if (filterEqHasChildren !== undefined) {
                localVarQueryParameter['filter.eq.hasChildren'] = filterEqHasChildren;
            }

            if (filterEqHasRetries !== undefined) {
                localVarQueryParameter['filter.eq.hasRetries'] = filterEqHasRetries;
            }

            if (filterEqHasStats !== undefined) {
                localVarQueryParameter['filter.eq.hasStats'] = filterEqHasStats;
            }

            if (filterEqId !== undefined) {
                localVarQueryParameter['filter.eq.id'] = filterEqId;
            }

            if (filterEqIgnoreAnalyzer !== undefined) {
                localVarQueryParameter['filter.eq.ignoreAnalyzer'] = filterEqIgnoreAnalyzer;
            }

            if (filterEqIssueComment !== undefined) {
                localVarQueryParameter['filter.eq.issueComment'] = filterEqIssueComment;
            }

            if (filterEqIssueGroupId !== undefined) {
                localVarQueryParameter['filter.eq.issueGroupId'] = filterEqIssueGroupId;
            }

            if (filterEqIssueId !== undefined) {
                localVarQueryParameter['filter.eq.issueId'] = filterEqIssueId;
            }

            if (filterEqIssueType !== undefined) {
                localVarQueryParameter['filter.eq.issueType'] = filterEqIssueType;
            }

            if (filterEqIssueTypeId !== undefined) {
                localVarQueryParameter['filter.eq.issueTypeId'] = filterEqIssueTypeId;
            }

            if (filterEqKey !== undefined) {
                localVarQueryParameter['filter.eq.key'] = filterEqKey;
            }

            if (filterEqLastModified !== undefined) {
                localVarQueryParameter['filter.eq.lastModified'] = filterEqLastModified;
            }

            if (filterEqLaunchId !== undefined) {
                localVarQueryParameter['filter.eq.launchId'] = filterEqLaunchId;
            }

            if (filterEqLevelAttribute) {
                localVarQueryParameter['filter.eq.levelAttribute'] = filterEqLevelAttribute;
            }

            if (filterEqLocator !== undefined) {
                localVarQueryParameter['filter.eq.locator'] = filterEqLocator;
            }

            if (filterEqMode !== undefined) {
                localVarQueryParameter['filter.eq.mode'] = filterEqMode;
            }

            if (filterEqName !== undefined) {
                localVarQueryParameter['filter.eq.name'] = filterEqName;
            }

            if (filterEqParentId !== undefined) {
                localVarQueryParameter['filter.eq.parentId'] = filterEqParentId;
            }

            if (filterEqParentId2 !== undefined) {
                localVarQueryParameter['filter.eq.parentId'] = filterEqParentId2;
            }

            if (filterEqPath !== undefined) {
                localVarQueryParameter['filter.eq.path'] = filterEqPath;
            }

            if (filterEqPatternName) {
                localVarQueryParameter['filter.eq.patternName'] = filterEqPatternName;
            }

            if (filterEqProjectId !== undefined) {
                localVarQueryParameter['filter.eq.projectId'] = filterEqProjectId;
            }

            if (filterEqRetryParentId !== undefined) {
                localVarQueryParameter['filter.eq.retryParentId'] = filterEqRetryParentId;
            }

            if (filterEqStartTime !== undefined) {
                localVarQueryParameter['filter.eq.startTime'] = (filterEqStartTime as any).toISOString();
            }

            if (filterEqStatisticsdefectsautomationBugab001 !== undefined) {
                localVarQueryParameter['filter.eq.statistics$defects$automation_bug$ab001'] = filterEqStatisticsdefectsautomationBugab001;
            }

            if (filterEqStatisticsdefectsnoDefectnd001 !== undefined) {
                localVarQueryParameter['filter.eq.statistics$defects$no_defect$nd001'] = filterEqStatisticsdefectsnoDefectnd001;
            }

            if (filterEqStatisticsdefectsproductBugpb001 !== undefined) {
                localVarQueryParameter['filter.eq.statistics$defects$product_bug$pb001'] = filterEqStatisticsdefectsproductBugpb001;
            }

            if (filterEqStatisticsdefectssystemIssuesi001 !== undefined) {
                localVarQueryParameter['filter.eq.statistics$defects$system_issue$si001'] = filterEqStatisticsdefectssystemIssuesi001;
            }

            if (filterEqStatisticsdefectstoInvestigateti001 !== undefined) {
                localVarQueryParameter['filter.eq.statistics$defects$to_investigate$ti001'] = filterEqStatisticsdefectstoInvestigateti001;
            }

            if (filterEqStatisticsexecutionsfailed !== undefined) {
                localVarQueryParameter['filter.eq.statistics$executions$failed'] = filterEqStatisticsexecutionsfailed;
            }

            if (filterEqStatisticsexecutionspassed !== undefined) {
                localVarQueryParameter['filter.eq.statistics$executions$passed'] = filterEqStatisticsexecutionspassed;
            }

            if (filterEqStatisticsexecutionsskipped !== undefined) {
                localVarQueryParameter['filter.eq.statistics$executions$skipped'] = filterEqStatisticsexecutionsskipped;
            }

            if (filterEqStatisticsexecutionstotal !== undefined) {
                localVarQueryParameter['filter.eq.statistics$executions$total'] = filterEqStatisticsexecutionstotal;
            }

            if (filterEqStatus !== undefined) {
                localVarQueryParameter['filter.eq.status'] = filterEqStatus;
            }

            if (filterEqTestCaseHash !== undefined) {
                localVarQueryParameter['filter.eq.testCaseHash'] = filterEqTestCaseHash;
            }

            if (filterEqTestCaseId !== undefined) {
                localVarQueryParameter['filter.eq.testCaseId'] = filterEqTestCaseId;
            }

            if (filterEqTicketId !== undefined) {
                localVarQueryParameter['filter.eq.ticketId'] = filterEqTicketId;
            }

            if (filterEqType !== undefined) {
                localVarQueryParameter['filter.eq.type'] = filterEqType;
            }

            if (filterEqUniqueId !== undefined) {
                localVarQueryParameter['filter.eq.uniqueId'] = filterEqUniqueId;
            }

            if (filterEqUuid !== undefined) {
                localVarQueryParameter['filter.eq.uuid'] = filterEqUuid;
            }

            if (filterEqValue !== undefined) {
                localVarQueryParameter['filter.eq.value'] = filterEqValue;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find test items by specified filter
         * @param {string} projectName projectName
         * @param {Array<any>} [filterEqAttributeKey] Filters by &#39;attributeKey&#39;
         * @param {Array<any>} [filterEqAttributeValue] Filters by &#39;attributeValue&#39;
         * @param {boolean} [filterEqAutoAnalyzed] Filters by &#39;autoAnalyzed&#39;
         * @param {number} [filterEqClusterId] Filters by &#39;clusterId&#39;
         * @param {Array<string>} [filterEqCompositeAttribute] Filters by &#39;compositeAttribute&#39;
         * @param {Array<string>} [filterEqCompositeSystemAttribute] Filters by &#39;compositeSystemAttribute&#39;
         * @param {string} [filterEqDescription] Filters by &#39;description&#39;
         * @param {number} [filterEqDuration] Filters by &#39;duration&#39;
         * @param {Date} [filterEqEndTime] Filters by &#39;endTime&#39;
         * @param {boolean} [filterEqHasChildren] Filters by &#39;hasChildren&#39;
         * @param {boolean} [filterEqHasRetries] Filters by &#39;hasRetries&#39;
         * @param {boolean} [filterEqHasStats] Filters by &#39;hasStats&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {boolean} [filterEqIgnoreAnalyzer] Filters by &#39;ignoreAnalyzer&#39;
         * @param {string} [filterEqIssueComment] Filters by &#39;issueComment&#39;
         * @param {number} [filterEqIssueGroupId] Filters by &#39;issueGroupId&#39;
         * @param {number} [filterEqIssueId] Filters by &#39;issueId&#39;
         * @param {string} [filterEqIssueType] Filters by &#39;issueType&#39;
         * @param {number} [filterEqIssueTypeId] Filters by &#39;issueTypeId&#39;
         * @param {string} [filterEqKey] Filters by &#39;key&#39;
         * @param {string} [filterEqLastModified] Filters by &#39;lastModified&#39;
         * @param {number} [filterEqLaunchId] Filters by &#39;launchId&#39;
         * @param {Array<any>} [filterEqLevelAttribute] Filters by &#39;levelAttribute&#39;
         * @param {string} [filterEqLocator] Filters by &#39;locator&#39;
         * @param {string} [filterEqMode] Filters by &#39;mode&#39;
         * @param {string} [filterEqName] Filters by &#39;name&#39;
         * @param {number} [filterEqParentId] Filters by &#39;parentId&#39;
         * @param {number} [filterEqParentId2] Filters by &#39;parentId&#39;
         * @param {number} [filterEqPath] Filters by &#39;path&#39;
         * @param {Array<any>} [filterEqPatternName] Filters by &#39;patternName&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {number} [filterEqRetryParentId] Filters by &#39;retryParentId&#39;
         * @param {Date} [filterEqStartTime] Filters by &#39;startTime&#39;
         * @param {number} [filterEqStatisticsdefectsautomationBugab001] Filters by &#39;statistics$defects$automation_bug$ab001&#39;
         * @param {number} [filterEqStatisticsdefectsnoDefectnd001] Filters by &#39;statistics$defects$no_defect$nd001&#39;
         * @param {number} [filterEqStatisticsdefectsproductBugpb001] Filters by &#39;statistics$defects$product_bug$pb001&#39;
         * @param {number} [filterEqStatisticsdefectssystemIssuesi001] Filters by &#39;statistics$defects$system_issue$si001&#39;
         * @param {number} [filterEqStatisticsdefectstoInvestigateti001] Filters by &#39;statistics$defects$to_investigate$ti001&#39;
         * @param {number} [filterEqStatisticsexecutionsfailed] Filters by &#39;statistics$executions$failed&#39;
         * @param {number} [filterEqStatisticsexecutionspassed] Filters by &#39;statistics$executions$passed&#39;
         * @param {number} [filterEqStatisticsexecutionsskipped] Filters by &#39;statistics$executions$skipped&#39;
         * @param {number} [filterEqStatisticsexecutionstotal] Filters by &#39;statistics$executions$total&#39;
         * @param {string} [filterEqStatus] Filters by &#39;status&#39;
         * @param {number} [filterEqTestCaseHash] Filters by &#39;testCaseHash&#39;
         * @param {string} [filterEqTestCaseId] Filters by &#39;testCaseId&#39;
         * @param {string} [filterEqTicketId] Filters by &#39;ticketId&#39;
         * @param {string} [filterEqType] Filters by &#39;type&#39;
         * @param {string} [filterEqUniqueId] Filters by &#39;uniqueId&#39;
         * @param {string} [filterEqUuid] Filters by &#39;uuid&#39;
         * @param {string} [filterEqValue] Filters by &#39;value&#39;
         * @param {number} [filterId] filterId
         * @param {boolean} [isLatest] isLatest
         * @param {number} [launchesLimit] launchesLimit
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestItemsUsingGET2(projectName: string, filterEqAttributeKey?: Array<any>, filterEqAttributeValue?: Array<any>, filterEqAutoAnalyzed?: boolean, filterEqClusterId?: number, filterEqCompositeAttribute?: Array<string>, filterEqCompositeSystemAttribute?: Array<string>, filterEqDescription?: string, filterEqDuration?: number, filterEqEndTime?: Date, filterEqHasChildren?: boolean, filterEqHasRetries?: boolean, filterEqHasStats?: boolean, filterEqId?: number, filterEqIgnoreAnalyzer?: boolean, filterEqIssueComment?: string, filterEqIssueGroupId?: number, filterEqIssueId?: number, filterEqIssueType?: string, filterEqIssueTypeId?: number, filterEqKey?: string, filterEqLastModified?: string, filterEqLaunchId?: number, filterEqLevelAttribute?: Array<any>, filterEqLocator?: string, filterEqMode?: string, filterEqName?: string, filterEqParentId?: number, filterEqParentId2?: number, filterEqPath?: number, filterEqPatternName?: Array<any>, filterEqProjectId?: number, filterEqRetryParentId?: number, filterEqStartTime?: Date, filterEqStatisticsdefectsautomationBugab001?: number, filterEqStatisticsdefectsnoDefectnd001?: number, filterEqStatisticsdefectsproductBugpb001?: number, filterEqStatisticsdefectssystemIssuesi001?: number, filterEqStatisticsdefectstoInvestigateti001?: number, filterEqStatisticsexecutionsfailed?: number, filterEqStatisticsexecutionspassed?: number, filterEqStatisticsexecutionsskipped?: number, filterEqStatisticsexecutionstotal?: number, filterEqStatus?: string, filterEqTestCaseHash?: number, filterEqTestCaseId?: string, filterEqTicketId?: string, filterEqType?: string, filterEqUniqueId?: string, filterEqUuid?: string, filterEqValue?: string, filterId?: number, isLatest?: boolean, launchesLimit?: number, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getTestItemsUsingGET2.');
            }
            const localVarPath = `/v1/{projectName}/item`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filterEqAttributeKey) {
                localVarQueryParameter['filter.eq.attributeKey'] = filterEqAttributeKey;
            }

            if (filterEqAttributeValue) {
                localVarQueryParameter['filter.eq.attributeValue'] = filterEqAttributeValue;
            }

            if (filterEqAutoAnalyzed !== undefined) {
                localVarQueryParameter['filter.eq.autoAnalyzed'] = filterEqAutoAnalyzed;
            }

            if (filterEqClusterId !== undefined) {
                localVarQueryParameter['filter.eq.clusterId'] = filterEqClusterId;
            }

            if (filterEqCompositeAttribute) {
                localVarQueryParameter['filter.eq.compositeAttribute'] = filterEqCompositeAttribute;
            }

            if (filterEqCompositeSystemAttribute) {
                localVarQueryParameter['filter.eq.compositeSystemAttribute'] = filterEqCompositeSystemAttribute;
            }

            if (filterEqDescription !== undefined) {
                localVarQueryParameter['filter.eq.description'] = filterEqDescription;
            }

            if (filterEqDuration !== undefined) {
                localVarQueryParameter['filter.eq.duration'] = filterEqDuration;
            }

            if (filterEqEndTime !== undefined) {
                localVarQueryParameter['filter.eq.endTime'] = (filterEqEndTime as any).toISOString();
            }

            if (filterEqHasChildren !== undefined) {
                localVarQueryParameter['filter.eq.hasChildren'] = filterEqHasChildren;
            }

            if (filterEqHasRetries !== undefined) {
                localVarQueryParameter['filter.eq.hasRetries'] = filterEqHasRetries;
            }

            if (filterEqHasStats !== undefined) {
                localVarQueryParameter['filter.eq.hasStats'] = filterEqHasStats;
            }

            if (filterEqId !== undefined) {
                localVarQueryParameter['filter.eq.id'] = filterEqId;
            }

            if (filterEqIgnoreAnalyzer !== undefined) {
                localVarQueryParameter['filter.eq.ignoreAnalyzer'] = filterEqIgnoreAnalyzer;
            }

            if (filterEqIssueComment !== undefined) {
                localVarQueryParameter['filter.eq.issueComment'] = filterEqIssueComment;
            }

            if (filterEqIssueGroupId !== undefined) {
                localVarQueryParameter['filter.eq.issueGroupId'] = filterEqIssueGroupId;
            }

            if (filterEqIssueId !== undefined) {
                localVarQueryParameter['filter.eq.issueId'] = filterEqIssueId;
            }

            if (filterEqIssueType !== undefined) {
                localVarQueryParameter['filter.eq.issueType'] = filterEqIssueType;
            }

            if (filterEqIssueTypeId !== undefined) {
                localVarQueryParameter['filter.eq.issueTypeId'] = filterEqIssueTypeId;
            }

            if (filterEqKey !== undefined) {
                localVarQueryParameter['filter.eq.key'] = filterEqKey;
            }

            if (filterEqLastModified !== undefined) {
                localVarQueryParameter['filter.eq.lastModified'] = filterEqLastModified;
            }

            if (filterEqLaunchId !== undefined) {
                localVarQueryParameter['filter.eq.launchId'] = filterEqLaunchId;
            }

            if (filterEqLevelAttribute) {
                localVarQueryParameter['filter.eq.levelAttribute'] = filterEqLevelAttribute;
            }

            if (filterEqLocator !== undefined) {
                localVarQueryParameter['filter.eq.locator'] = filterEqLocator;
            }

            if (filterEqMode !== undefined) {
                localVarQueryParameter['filter.eq.mode'] = filterEqMode;
            }

            if (filterEqName !== undefined) {
                localVarQueryParameter['filter.eq.name'] = filterEqName;
            }

            if (filterEqParentId !== undefined) {
                localVarQueryParameter['filter.eq.parentId'] = filterEqParentId;
            }

            if (filterEqParentId2 !== undefined) {
                localVarQueryParameter['filter.eq.parentId'] = filterEqParentId2;
            }

            if (filterEqPath !== undefined) {
                localVarQueryParameter['filter.eq.path'] = filterEqPath;
            }

            if (filterEqPatternName) {
                localVarQueryParameter['filter.eq.patternName'] = filterEqPatternName;
            }

            if (filterEqProjectId !== undefined) {
                localVarQueryParameter['filter.eq.projectId'] = filterEqProjectId;
            }

            if (filterEqRetryParentId !== undefined) {
                localVarQueryParameter['filter.eq.retryParentId'] = filterEqRetryParentId;
            }

            if (filterEqStartTime !== undefined) {
                localVarQueryParameter['filter.eq.startTime'] = (filterEqStartTime as any).toISOString();
            }

            if (filterEqStatisticsdefectsautomationBugab001 !== undefined) {
                localVarQueryParameter['filter.eq.statistics$defects$automation_bug$ab001'] = filterEqStatisticsdefectsautomationBugab001;
            }

            if (filterEqStatisticsdefectsnoDefectnd001 !== undefined) {
                localVarQueryParameter['filter.eq.statistics$defects$no_defect$nd001'] = filterEqStatisticsdefectsnoDefectnd001;
            }

            if (filterEqStatisticsdefectsproductBugpb001 !== undefined) {
                localVarQueryParameter['filter.eq.statistics$defects$product_bug$pb001'] = filterEqStatisticsdefectsproductBugpb001;
            }

            if (filterEqStatisticsdefectssystemIssuesi001 !== undefined) {
                localVarQueryParameter['filter.eq.statistics$defects$system_issue$si001'] = filterEqStatisticsdefectssystemIssuesi001;
            }

            if (filterEqStatisticsdefectstoInvestigateti001 !== undefined) {
                localVarQueryParameter['filter.eq.statistics$defects$to_investigate$ti001'] = filterEqStatisticsdefectstoInvestigateti001;
            }

            if (filterEqStatisticsexecutionsfailed !== undefined) {
                localVarQueryParameter['filter.eq.statistics$executions$failed'] = filterEqStatisticsexecutionsfailed;
            }

            if (filterEqStatisticsexecutionspassed !== undefined) {
                localVarQueryParameter['filter.eq.statistics$executions$passed'] = filterEqStatisticsexecutionspassed;
            }

            if (filterEqStatisticsexecutionsskipped !== undefined) {
                localVarQueryParameter['filter.eq.statistics$executions$skipped'] = filterEqStatisticsexecutionsskipped;
            }

            if (filterEqStatisticsexecutionstotal !== undefined) {
                localVarQueryParameter['filter.eq.statistics$executions$total'] = filterEqStatisticsexecutionstotal;
            }

            if (filterEqStatus !== undefined) {
                localVarQueryParameter['filter.eq.status'] = filterEqStatus;
            }

            if (filterEqTestCaseHash !== undefined) {
                localVarQueryParameter['filter.eq.testCaseHash'] = filterEqTestCaseHash;
            }

            if (filterEqTestCaseId !== undefined) {
                localVarQueryParameter['filter.eq.testCaseId'] = filterEqTestCaseId;
            }

            if (filterEqTicketId !== undefined) {
                localVarQueryParameter['filter.eq.ticketId'] = filterEqTicketId;
            }

            if (filterEqType !== undefined) {
                localVarQueryParameter['filter.eq.type'] = filterEqType;
            }

            if (filterEqUniqueId !== undefined) {
                localVarQueryParameter['filter.eq.uniqueId'] = filterEqUniqueId;
            }

            if (filterEqUuid !== undefined) {
                localVarQueryParameter['filter.eq.uuid'] = filterEqUuid;
            }

            if (filterEqValue !== undefined) {
                localVarQueryParameter['filter.eq.value'] = filterEqValue;
            }

            if (filterId !== undefined) {
                localVarQueryParameter['filterId'] = filterId;
            }

            if (isLatest !== undefined) {
                localVarQueryParameter['isLatest'] = isLatest;
            }

            if (launchesLimit !== undefined) {
                localVarQueryParameter['launchesLimit'] = launchesLimit;
            }

            if (pagePage !== undefined) {
                localVarQueryParameter['page.page'] = pagePage;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page.size'] = pageSize;
            }

            if (pageSort) {
                localVarQueryParameter['page.sort'] = pageSort;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Find test items by specified filter
         * @param {any} params params
         * @param {string} projectName projectName
         * @param {Array<any>} [filterEqAttributeKey] Filters by &#39;attributeKey&#39;
         * @param {Array<any>} [filterEqAttributeValue] Filters by &#39;attributeValue&#39;
         * @param {boolean} [filterEqAutoAnalyzed] Filters by &#39;autoAnalyzed&#39;
         * @param {number} [filterEqClusterId] Filters by &#39;clusterId&#39;
         * @param {Array<string>} [filterEqCompositeAttribute] Filters by &#39;compositeAttribute&#39;
         * @param {Array<string>} [filterEqCompositeSystemAttribute] Filters by &#39;compositeSystemAttribute&#39;
         * @param {string} [filterEqDescription] Filters by &#39;description&#39;
         * @param {number} [filterEqDuration] Filters by &#39;duration&#39;
         * @param {Date} [filterEqEndTime] Filters by &#39;endTime&#39;
         * @param {boolean} [filterEqHasChildren] Filters by &#39;hasChildren&#39;
         * @param {boolean} [filterEqHasRetries] Filters by &#39;hasRetries&#39;
         * @param {boolean} [filterEqHasStats] Filters by &#39;hasStats&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {boolean} [filterEqIgnoreAnalyzer] Filters by &#39;ignoreAnalyzer&#39;
         * @param {string} [filterEqIssueComment] Filters by &#39;issueComment&#39;
         * @param {number} [filterEqIssueGroupId] Filters by &#39;issueGroupId&#39;
         * @param {number} [filterEqIssueId] Filters by &#39;issueId&#39;
         * @param {string} [filterEqIssueType] Filters by &#39;issueType&#39;
         * @param {number} [filterEqIssueTypeId] Filters by &#39;issueTypeId&#39;
         * @param {string} [filterEqKey] Filters by &#39;key&#39;
         * @param {string} [filterEqLastModified] Filters by &#39;lastModified&#39;
         * @param {number} [filterEqLaunchId] Filters by &#39;launchId&#39;
         * @param {Array<any>} [filterEqLevelAttribute] Filters by &#39;levelAttribute&#39;
         * @param {string} [filterEqLocator] Filters by &#39;locator&#39;
         * @param {string} [filterEqMode] Filters by &#39;mode&#39;
         * @param {string} [filterEqName] Filters by &#39;name&#39;
         * @param {number} [filterEqParentId] Filters by &#39;parentId&#39;
         * @param {number} [filterEqParentId2] Filters by &#39;parentId&#39;
         * @param {number} [filterEqPath] Filters by &#39;path&#39;
         * @param {Array<any>} [filterEqPatternName] Filters by &#39;patternName&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {number} [filterEqRetryParentId] Filters by &#39;retryParentId&#39;
         * @param {Date} [filterEqStartTime] Filters by &#39;startTime&#39;
         * @param {number} [filterEqStatisticsdefectsautomationBugab001] Filters by &#39;statistics$defects$automation_bug$ab001&#39;
         * @param {number} [filterEqStatisticsdefectsnoDefectnd001] Filters by &#39;statistics$defects$no_defect$nd001&#39;
         * @param {number} [filterEqStatisticsdefectsproductBugpb001] Filters by &#39;statistics$defects$product_bug$pb001&#39;
         * @param {number} [filterEqStatisticsdefectssystemIssuesi001] Filters by &#39;statistics$defects$system_issue$si001&#39;
         * @param {number} [filterEqStatisticsdefectstoInvestigateti001] Filters by &#39;statistics$defects$to_investigate$ti001&#39;
         * @param {number} [filterEqStatisticsexecutionsfailed] Filters by &#39;statistics$executions$failed&#39;
         * @param {number} [filterEqStatisticsexecutionspassed] Filters by &#39;statistics$executions$passed&#39;
         * @param {number} [filterEqStatisticsexecutionsskipped] Filters by &#39;statistics$executions$skipped&#39;
         * @param {number} [filterEqStatisticsexecutionstotal] Filters by &#39;statistics$executions$total&#39;
         * @param {string} [filterEqStatus] Filters by &#39;status&#39;
         * @param {number} [filterEqTestCaseHash] Filters by &#39;testCaseHash&#39;
         * @param {string} [filterEqTestCaseId] Filters by &#39;testCaseId&#39;
         * @param {string} [filterEqTicketId] Filters by &#39;ticketId&#39;
         * @param {string} [filterEqType] Filters by &#39;type&#39;
         * @param {string} [filterEqUniqueId] Filters by &#39;uniqueId&#39;
         * @param {string} [filterEqUuid] Filters by &#39;uuid&#39;
         * @param {string} [filterEqValue] Filters by &#39;value&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestItemsV2UsingGET(params: any, projectName: string, filterEqAttributeKey?: Array<any>, filterEqAttributeValue?: Array<any>, filterEqAutoAnalyzed?: boolean, filterEqClusterId?: number, filterEqCompositeAttribute?: Array<string>, filterEqCompositeSystemAttribute?: Array<string>, filterEqDescription?: string, filterEqDuration?: number, filterEqEndTime?: Date, filterEqHasChildren?: boolean, filterEqHasRetries?: boolean, filterEqHasStats?: boolean, filterEqId?: number, filterEqIgnoreAnalyzer?: boolean, filterEqIssueComment?: string, filterEqIssueGroupId?: number, filterEqIssueId?: number, filterEqIssueType?: string, filterEqIssueTypeId?: number, filterEqKey?: string, filterEqLastModified?: string, filterEqLaunchId?: number, filterEqLevelAttribute?: Array<any>, filterEqLocator?: string, filterEqMode?: string, filterEqName?: string, filterEqParentId?: number, filterEqParentId2?: number, filterEqPath?: number, filterEqPatternName?: Array<any>, filterEqProjectId?: number, filterEqRetryParentId?: number, filterEqStartTime?: Date, filterEqStatisticsdefectsautomationBugab001?: number, filterEqStatisticsdefectsnoDefectnd001?: number, filterEqStatisticsdefectsproductBugpb001?: number, filterEqStatisticsdefectssystemIssuesi001?: number, filterEqStatisticsdefectstoInvestigateti001?: number, filterEqStatisticsexecutionsfailed?: number, filterEqStatisticsexecutionspassed?: number, filterEqStatisticsexecutionsskipped?: number, filterEqStatisticsexecutionstotal?: number, filterEqStatus?: string, filterEqTestCaseHash?: number, filterEqTestCaseId?: string, filterEqTicketId?: string, filterEqType?: string, filterEqUniqueId?: string, filterEqUuid?: string, filterEqValue?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options: any = {}): FetchArgs {
            // // verify required parameter 'params' is not null or undefined
            if (params === null || params === undefined) {
                throw new RequiredError('params', 'Required parameter params was null or undefined when calling getTestItemsV2UsingGET.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getTestItemsV2UsingGET.');
            }
            const localVarPath = `/v1/{projectName}/item/v2`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filterEqAttributeKey) {
                localVarQueryParameter['filter.eq.attributeKey'] = filterEqAttributeKey;
            }

            if (filterEqAttributeValue) {
                localVarQueryParameter['filter.eq.attributeValue'] = filterEqAttributeValue;
            }

            if (filterEqAutoAnalyzed !== undefined) {
                localVarQueryParameter['filter.eq.autoAnalyzed'] = filterEqAutoAnalyzed;
            }

            if (filterEqClusterId !== undefined) {
                localVarQueryParameter['filter.eq.clusterId'] = filterEqClusterId;
            }

            if (filterEqCompositeAttribute) {
                localVarQueryParameter['filter.eq.compositeAttribute'] = filterEqCompositeAttribute;
            }

            if (filterEqCompositeSystemAttribute) {
                localVarQueryParameter['filter.eq.compositeSystemAttribute'] = filterEqCompositeSystemAttribute;
            }

            if (filterEqDescription !== undefined) {
                localVarQueryParameter['filter.eq.description'] = filterEqDescription;
            }

            if (filterEqDuration !== undefined) {
                localVarQueryParameter['filter.eq.duration'] = filterEqDuration;
            }

            if (filterEqEndTime !== undefined) {
                localVarQueryParameter['filter.eq.endTime'] = (filterEqEndTime as any).toISOString();
            }

            if (filterEqHasChildren !== undefined) {
                localVarQueryParameter['filter.eq.hasChildren'] = filterEqHasChildren;
            }

            if (filterEqHasRetries !== undefined) {
                localVarQueryParameter['filter.eq.hasRetries'] = filterEqHasRetries;
            }

            if (filterEqHasStats !== undefined) {
                localVarQueryParameter['filter.eq.hasStats'] = filterEqHasStats;
            }

            if (filterEqId !== undefined) {
                localVarQueryParameter['filter.eq.id'] = filterEqId;
            }

            if (filterEqIgnoreAnalyzer !== undefined) {
                localVarQueryParameter['filter.eq.ignoreAnalyzer'] = filterEqIgnoreAnalyzer;
            }

            if (filterEqIssueComment !== undefined) {
                localVarQueryParameter['filter.eq.issueComment'] = filterEqIssueComment;
            }

            if (filterEqIssueGroupId !== undefined) {
                localVarQueryParameter['filter.eq.issueGroupId'] = filterEqIssueGroupId;
            }

            if (filterEqIssueId !== undefined) {
                localVarQueryParameter['filter.eq.issueId'] = filterEqIssueId;
            }

            if (filterEqIssueType !== undefined) {
                localVarQueryParameter['filter.eq.issueType'] = filterEqIssueType;
            }

            if (filterEqIssueTypeId !== undefined) {
                localVarQueryParameter['filter.eq.issueTypeId'] = filterEqIssueTypeId;
            }

            if (filterEqKey !== undefined) {
                localVarQueryParameter['filter.eq.key'] = filterEqKey;
            }

            if (filterEqLastModified !== undefined) {
                localVarQueryParameter['filter.eq.lastModified'] = filterEqLastModified;
            }

            if (filterEqLaunchId !== undefined) {
                localVarQueryParameter['filter.eq.launchId'] = filterEqLaunchId;
            }

            if (filterEqLevelAttribute) {
                localVarQueryParameter['filter.eq.levelAttribute'] = filterEqLevelAttribute;
            }

            if (filterEqLocator !== undefined) {
                localVarQueryParameter['filter.eq.locator'] = filterEqLocator;
            }

            if (filterEqMode !== undefined) {
                localVarQueryParameter['filter.eq.mode'] = filterEqMode;
            }

            if (filterEqName !== undefined) {
                localVarQueryParameter['filter.eq.name'] = filterEqName;
            }

            if (filterEqParentId !== undefined) {
                localVarQueryParameter['filter.eq.parentId'] = filterEqParentId;
            }

            if (filterEqParentId2 !== undefined) {
                localVarQueryParameter['filter.eq.parentId'] = filterEqParentId2;
            }

            if (filterEqPath !== undefined) {
                localVarQueryParameter['filter.eq.path'] = filterEqPath;
            }

            if (filterEqPatternName) {
                localVarQueryParameter['filter.eq.patternName'] = filterEqPatternName;
            }

            if (filterEqProjectId !== undefined) {
                localVarQueryParameter['filter.eq.projectId'] = filterEqProjectId;
            }

            if (filterEqRetryParentId !== undefined) {
                localVarQueryParameter['filter.eq.retryParentId'] = filterEqRetryParentId;
            }

            if (filterEqStartTime !== undefined) {
                localVarQueryParameter['filter.eq.startTime'] = (filterEqStartTime as any).toISOString();
            }

            if (filterEqStatisticsdefectsautomationBugab001 !== undefined) {
                localVarQueryParameter['filter.eq.statistics$defects$automation_bug$ab001'] = filterEqStatisticsdefectsautomationBugab001;
            }

            if (filterEqStatisticsdefectsnoDefectnd001 !== undefined) {
                localVarQueryParameter['filter.eq.statistics$defects$no_defect$nd001'] = filterEqStatisticsdefectsnoDefectnd001;
            }

            if (filterEqStatisticsdefectsproductBugpb001 !== undefined) {
                localVarQueryParameter['filter.eq.statistics$defects$product_bug$pb001'] = filterEqStatisticsdefectsproductBugpb001;
            }

            if (filterEqStatisticsdefectssystemIssuesi001 !== undefined) {
                localVarQueryParameter['filter.eq.statistics$defects$system_issue$si001'] = filterEqStatisticsdefectssystemIssuesi001;
            }

            if (filterEqStatisticsdefectstoInvestigateti001 !== undefined) {
                localVarQueryParameter['filter.eq.statistics$defects$to_investigate$ti001'] = filterEqStatisticsdefectstoInvestigateti001;
            }

            if (filterEqStatisticsexecutionsfailed !== undefined) {
                localVarQueryParameter['filter.eq.statistics$executions$failed'] = filterEqStatisticsexecutionsfailed;
            }

            if (filterEqStatisticsexecutionspassed !== undefined) {
                localVarQueryParameter['filter.eq.statistics$executions$passed'] = filterEqStatisticsexecutionspassed;
            }

            if (filterEqStatisticsexecutionsskipped !== undefined) {
                localVarQueryParameter['filter.eq.statistics$executions$skipped'] = filterEqStatisticsexecutionsskipped;
            }

            if (filterEqStatisticsexecutionstotal !== undefined) {
                localVarQueryParameter['filter.eq.statistics$executions$total'] = filterEqStatisticsexecutionstotal;
            }

            if (filterEqStatus !== undefined) {
                localVarQueryParameter['filter.eq.status'] = filterEqStatus;
            }

            if (filterEqTestCaseHash !== undefined) {
                localVarQueryParameter['filter.eq.testCaseHash'] = filterEqTestCaseHash;
            }

            if (filterEqTestCaseId !== undefined) {
                localVarQueryParameter['filter.eq.testCaseId'] = filterEqTestCaseId;
            }

            if (filterEqTicketId !== undefined) {
                localVarQueryParameter['filter.eq.ticketId'] = filterEqTicketId;
            }

            if (filterEqType !== undefined) {
                localVarQueryParameter['filter.eq.type'] = filterEqType;
            }

            if (filterEqUniqueId !== undefined) {
                localVarQueryParameter['filter.eq.uniqueId'] = filterEqUniqueId;
            }

            if (filterEqUuid !== undefined) {
                localVarQueryParameter['filter.eq.uuid'] = filterEqUuid;
            }

            if (filterEqValue !== undefined) {
                localVarQueryParameter['filter.eq.value'] = filterEqValue;
            }

            if (pagePage !== undefined) {
                localVarQueryParameter['page.page'] = pagePage;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page.size'] = pageSize;
            }

            if (pageSort) {
                localVarQueryParameter['page.sort'] = pageSort;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get tickets that contains a term as a part inside for specified launch
         * @param {string} projectName projectName
         * @param {string} term term
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicketIdsForProjectUsingGET(projectName: string, term: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getTicketIdsForProjectUsingGET.');
            }
            // verify required parameter 'term' is not null or undefined
            if (term === null || term === undefined) {
                throw new RequiredError('term', 'Required parameter term was null or undefined when calling getTicketIdsForProjectUsingGET.');
            }
            const localVarPath = `/v1/{projectName}/item/ticket/ids/all`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get tickets that contains a term as a part inside for specified launch
         * @param {number} launch launch
         * @param {string} projectName projectName
         * @param {string} term term
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicketIdsUsingGET(launch: number, projectName: string, term: string, options: any = {}): FetchArgs {
            // verify required parameter 'launch' is not null or undefined
            if (launch === null || launch === undefined) {
                throw new RequiredError('launch', 'Required parameter launch was null or undefined when calling getTicketIdsUsingGET.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getTicketIdsUsingGET.');
            }
            // verify required parameter 'term' is not null or undefined
            if (term === null || term === undefined) {
                throw new RequiredError('term', 'Required parameter term was null or undefined when calling getTicketIdsUsingGET.');
            }
            const localVarPath = `/v1/{projectName}/item/ticket/ids`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (launch !== undefined) {
                localVarQueryParameter['launch'] = launch;
            }

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Handle user choice from suggested items
         * @param {string} projectName projectName
         * @param {Array<SuggestInfo>} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleSuggestChooseUsingPUT(projectName: string, request: Array<SuggestInfo>, options: any = {}): FetchArgs {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling handleSuggestChooseUsingPUT.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request', 'Required parameter request was null or undefined when calling handleSuggestChooseUsingPUT.');
            }
            const localVarPath = `/v1/{projectName}/item/suggest/choice`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'PUT'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;SuggestInfo&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Attach external issue for specified test items
         * @param {string} projectName projectName
         * @param {LinkExternalIssueRQ} rq rq
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkExternalIssuesUsingPUT(projectName: string, rq: LinkExternalIssueRQ, options: any = {}): FetchArgs {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling linkExternalIssuesUsingPUT.');
            }
            // verify required parameter 'rq' is not null or undefined
            if (rq === null || rq === undefined) {
                throw new RequiredError('rq', 'Required parameter rq was null or undefined when calling linkExternalIssuesUsingPUT.');
            }
            const localVarPath = `/v1/{projectName}/item/issue/link`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'PUT'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LinkExternalIssueRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(rq || {}) : (rq || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Start a child test item
         * @param {string} parentItem parentItem
         * @param {string} projectName projectName
         * @param {StartTestItemRQ} startTestItemRQ startTestItemRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startChildItemUsingPOST1(parentItem: string, projectName: string, startTestItemRQ: StartTestItemRQ, options: any = {}): FetchArgs {
            // verify required parameter 'parentItem' is not null or undefined
            if (parentItem === null || parentItem === undefined) {
                throw new RequiredError('parentItem', 'Required parameter parentItem was null or undefined when calling startChildItemUsingPOST1.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling startChildItemUsingPOST1.');
            }
            // verify required parameter 'startTestItemRQ' is not null or undefined
            if (startTestItemRQ === null || startTestItemRQ === undefined) {
                throw new RequiredError('startTestItemRQ', 'Required parameter startTestItemRQ was null or undefined when calling startChildItemUsingPOST1.');
            }
            const localVarPath = `/v1/{projectName}/item/{parentItem}`
                .replace(`{${"parentItem"}}`, encodeURIComponent(String(parentItem)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"StartTestItemRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(startTestItemRQ || {}) : (startTestItemRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Start a root test item
         * @param {string} projectName projectName
         * @param {StartTestItemRQ} startTestItemRQ startTestItemRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRootItemUsingPOST1(projectName: string, startTestItemRQ: StartTestItemRQ, options: any = {}): FetchArgs {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling startRootItemUsingPOST1.');
            }
            // verify required parameter 'startTestItemRQ' is not null or undefined
            if (startTestItemRQ === null || startTestItemRQ === undefined) {
                throw new RequiredError('startTestItemRQ', 'Required parameter startTestItemRQ was null or undefined when calling startRootItemUsingPOST1.');
            }
            const localVarPath = `/v1/{projectName}/item`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"StartTestItemRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(startTestItemRQ || {}) : (startTestItemRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Unlink external issue for specified test items
         * @param {string} projectName projectName
         * @param {UnlinkExternalIssueRQ} rq rq
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkExternalIssuesUsingPUT(projectName: string, rq: UnlinkExternalIssueRQ, options: any = {}): FetchArgs {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling unlinkExternalIssuesUsingPUT.');
            }
            // verify required parameter 'rq' is not null or undefined
            if (rq === null || rq === undefined) {
                throw new RequiredError('rq', 'Required parameter rq was null or undefined when calling unlinkExternalIssuesUsingPUT.');
            }
            const localVarPath = `/v1/{projectName}/item/issue/unlink`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'PUT'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UnlinkExternalIssueRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(rq || {}) : (rq || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update test item
         * @param {number} itemId itemId
         * @param {string} projectName projectName
         * @param {UpdateTestItemRQ} rq rq
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTestItemUsingPUT(itemId: number, projectName: string, rq: UpdateTestItemRQ, options: any = {}): FetchArgs {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId', 'Required parameter itemId was null or undefined when calling updateTestItemUsingPUT.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling updateTestItemUsingPUT.');
            }
            // verify required parameter 'rq' is not null or undefined
            if (rq === null || rq === undefined) {
                throw new RequiredError('rq', 'Required parameter rq was null or undefined when calling updateTestItemUsingPUT.');
            }
            const localVarPath = `/v1/{projectName}/item/{itemId}/update`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'PUT'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateTestItemRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(rq || {}) : (rq || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TestItemControllerApi - functional programming interface
 * @export
 */
export const TestItemControllerApiFp = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Bulk update attributes and description
         * @param {BulkInfoUpdateRQ} bulkInfoUpdateRQ bulkInfoUpdateRQ
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateUsingPUT1(bulkInfoUpdateRQ: BulkInfoUpdateRQ, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = TestItemControllerApiFetchParamCreator(configuration).bulkUpdateUsingPUT1(bulkInfoUpdateRQ, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update issues of specified test items
         * @param {string} projectName projectName
         * @param {DefineIssueRQ} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defineTestItemIssueTypeUsingPUT(projectName: string, request: DefineIssueRQ, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Issue>> {
            const localVarFetchArgs = TestItemControllerApiFetchParamCreator(configuration).defineTestItemIssueTypeUsingPUT(projectName, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete test item
         * @param {number} itemId itemId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTestItemUsingDELETE(itemId: number, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = TestItemControllerApiFetchParamCreator(configuration).deleteTestItemUsingDELETE(itemId, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete test items by specified ids
         * @param {Array<number>} ids ids
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTestItemsUsingDELETE(ids: Array<number>, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<OperationCompletionRS>> {
            const localVarFetchArgs = TestItemControllerApiFetchParamCreator(configuration).deleteTestItemsUsingDELETE(ids, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Finish test item
         * @param {FinishTestItemRQ} finishExecutionRQ finishExecutionRQ
         * @param {string} projectName projectName
         * @param {string} testItemId testItemId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finishTestItemUsingPUT1(finishExecutionRQ: FinishTestItemRQ, projectName: string, testItemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = TestItemControllerApiFetchParamCreator(configuration).finishTestItemUsingPUT1(finishExecutionRQ, projectName, testItemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all unique attribute keys of specified launch
         * @param {string} filterCntAttributeKey filter.cnt.attributeKey
         * @param {number} filterId filterId
         * @param {string} projectName projectName
         * @param {boolean} [isLatest] isLatest
         * @param {number} [launchesLimit] launchesLimit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributeKeysForProjectUsingGET(filterCntAttributeKey: string, filterId: number, projectName: string, isLatest?: boolean, launchesLimit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = TestItemControllerApiFetchParamCreator(configuration).getAttributeKeysForProjectUsingGET(filterCntAttributeKey, filterId, projectName, isLatest, launchesLimit, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all unique attribute keys of specified launch
         * @param {string} filterCntAttributeKey filter.cnt.attributeKey
         * @param {number} launch launch
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributeKeysUsingGET1(filterCntAttributeKey: string, launch: number, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = TestItemControllerApiFetchParamCreator(configuration).getAttributeKeysUsingGET1(filterCntAttributeKey, launch, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all unique attribute keys of step items under specified project
         * @param {string} filterCntAttributeKey filter.cnt.attributeKey
         * @param {string} projectName projectName
         * @param {string} [filterEqName] filter.eq.name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributeKeysUsingGET2(filterCntAttributeKey: string, projectName: string, filterEqName?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = TestItemControllerApiFetchParamCreator(configuration).getAttributeKeysUsingGET2(filterCntAttributeKey, projectName, filterEqName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all unique attribute values of specified launch
         * @param {string} filterCntAttributeValue filter.cnt.attributeValue
         * @param {number} launch launch
         * @param {string} projectName projectName
         * @param {string} [filterEqAttributeKey] filter.eq.attributeKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributeValuesUsingGET1(filterCntAttributeValue: string, launch: number, projectName: string, filterEqAttributeKey?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = TestItemControllerApiFetchParamCreator(configuration).getAttributeValuesUsingGET1(filterCntAttributeValue, launch, projectName, filterEqAttributeKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all unique attribute values of step items under specified project
         * @param {string} filterCntAttributeValue filter.cnt.attributeValue
         * @param {string} projectName projectName
         * @param {string} [filterEqAttributeKey] filter.eq.attributeKey
         * @param {string} [filterEqName] filter.eq.name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributeValuesUsingGET2(filterCntAttributeValue: string, projectName: string, filterEqAttributeKey?: string, filterEqName?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = TestItemControllerApiFetchParamCreator(configuration).getAttributeValuesUsingGET2(filterCntAttributeValue, projectName, filterEqAttributeKey, filterEqName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Load history of test items
         * @param {string} projectName projectName
         * @param {Array<any>} [filterEqAttributeKey] Filters by &#39;attributeKey&#39;
         * @param {Array<any>} [filterEqAttributeValue] Filters by &#39;attributeValue&#39;
         * @param {boolean} [filterEqAutoAnalyzed] Filters by &#39;autoAnalyzed&#39;
         * @param {number} [filterEqClusterId] Filters by &#39;clusterId&#39;
         * @param {Array<string>} [filterEqCompositeAttribute] Filters by &#39;compositeAttribute&#39;
         * @param {Array<string>} [filterEqCompositeSystemAttribute] Filters by &#39;compositeSystemAttribute&#39;
         * @param {string} [filterEqDescription] Filters by &#39;description&#39;
         * @param {number} [filterEqDuration] Filters by &#39;duration&#39;
         * @param {Date} [filterEqEndTime] Filters by &#39;endTime&#39;
         * @param {boolean} [filterEqHasChildren] Filters by &#39;hasChildren&#39;
         * @param {boolean} [filterEqHasRetries] Filters by &#39;hasRetries&#39;
         * @param {boolean} [filterEqHasStats] Filters by &#39;hasStats&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {boolean} [filterEqIgnoreAnalyzer] Filters by &#39;ignoreAnalyzer&#39;
         * @param {string} [filterEqIssueComment] Filters by &#39;issueComment&#39;
         * @param {number} [filterEqIssueGroupId] Filters by &#39;issueGroupId&#39;
         * @param {number} [filterEqIssueId] Filters by &#39;issueId&#39;
         * @param {string} [filterEqIssueType] Filters by &#39;issueType&#39;
         * @param {number} [filterEqIssueTypeId] Filters by &#39;issueTypeId&#39;
         * @param {string} [filterEqKey] Filters by &#39;key&#39;
         * @param {string} [filterEqLastModified] Filters by &#39;lastModified&#39;
         * @param {number} [filterEqLaunchId] Filters by &#39;launchId&#39;
         * @param {Array<any>} [filterEqLevelAttribute] Filters by &#39;levelAttribute&#39;
         * @param {string} [filterEqLocator] Filters by &#39;locator&#39;
         * @param {string} [filterEqMode] Filters by &#39;mode&#39;
         * @param {string} [filterEqName] Filters by &#39;name&#39;
         * @param {number} [filterEqParentId] Filters by &#39;parentId&#39;
         * @param {number} [filterEqParentId2] Filters by &#39;parentId&#39;
         * @param {number} [filterEqPath] Filters by &#39;path&#39;
         * @param {Array<any>} [filterEqPatternName] Filters by &#39;patternName&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {number} [filterEqRetryParentId] Filters by &#39;retryParentId&#39;
         * @param {Date} [filterEqStartTime] Filters by &#39;startTime&#39;
         * @param {number} [filterEqStatisticsdefectsautomationBugab001] Filters by &#39;statistics$defects$automation_bug$ab001&#39;
         * @param {number} [filterEqStatisticsdefectsnoDefectnd001] Filters by &#39;statistics$defects$no_defect$nd001&#39;
         * @param {number} [filterEqStatisticsdefectsproductBugpb001] Filters by &#39;statistics$defects$product_bug$pb001&#39;
         * @param {number} [filterEqStatisticsdefectssystemIssuesi001] Filters by &#39;statistics$defects$system_issue$si001&#39;
         * @param {number} [filterEqStatisticsdefectstoInvestigateti001] Filters by &#39;statistics$defects$to_investigate$ti001&#39;
         * @param {number} [filterEqStatisticsexecutionsfailed] Filters by &#39;statistics$executions$failed&#39;
         * @param {number} [filterEqStatisticsexecutionspassed] Filters by &#39;statistics$executions$passed&#39;
         * @param {number} [filterEqStatisticsexecutionsskipped] Filters by &#39;statistics$executions$skipped&#39;
         * @param {number} [filterEqStatisticsexecutionstotal] Filters by &#39;statistics$executions$total&#39;
         * @param {string} [filterEqStatus] Filters by &#39;status&#39;
         * @param {number} [filterEqTestCaseHash] Filters by &#39;testCaseHash&#39;
         * @param {string} [filterEqTestCaseId] Filters by &#39;testCaseId&#39;
         * @param {string} [filterEqTicketId] Filters by &#39;ticketId&#39;
         * @param {string} [filterEqType] Filters by &#39;type&#39;
         * @param {string} [filterEqUniqueId] Filters by &#39;uniqueId&#39;
         * @param {string} [filterEqUuid] Filters by &#39;uuid&#39;
         * @param {string} [filterEqValue] Filters by &#39;value&#39;
         * @param {number} [filterId] filterId
         * @param {number} [historyDepth] historyDepth
         * @param {boolean} [isLatest] isLatest
         * @param {number} [launchesLimit] launchesLimit
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {string} [type] type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsHistoryUsingGET(projectName: string, filterEqAttributeKey?: Array<any>, filterEqAttributeValue?: Array<any>, filterEqAutoAnalyzed?: boolean, filterEqClusterId?: number, filterEqCompositeAttribute?: Array<string>, filterEqCompositeSystemAttribute?: Array<string>, filterEqDescription?: string, filterEqDuration?: number, filterEqEndTime?: Date, filterEqHasChildren?: boolean, filterEqHasRetries?: boolean, filterEqHasStats?: boolean, filterEqId?: number, filterEqIgnoreAnalyzer?: boolean, filterEqIssueComment?: string, filterEqIssueGroupId?: number, filterEqIssueId?: number, filterEqIssueType?: string, filterEqIssueTypeId?: number, filterEqKey?: string, filterEqLastModified?: string, filterEqLaunchId?: number, filterEqLevelAttribute?: Array<any>, filterEqLocator?: string, filterEqMode?: string, filterEqName?: string, filterEqParentId?: number, filterEqParentId2?: number, filterEqPath?: number, filterEqPatternName?: Array<any>, filterEqProjectId?: number, filterEqRetryParentId?: number, filterEqStartTime?: Date, filterEqStatisticsdefectsautomationBugab001?: number, filterEqStatisticsdefectsnoDefectnd001?: number, filterEqStatisticsdefectsproductBugpb001?: number, filterEqStatisticsdefectssystemIssuesi001?: number, filterEqStatisticsdefectstoInvestigateti001?: number, filterEqStatisticsexecutionsfailed?: number, filterEqStatisticsexecutionspassed?: number, filterEqStatisticsexecutionsskipped?: number, filterEqStatisticsexecutionstotal?: number, filterEqStatus?: string, filterEqTestCaseHash?: number, filterEqTestCaseId?: string, filterEqTicketId?: string, filterEqType?: string, filterEqUniqueId?: string, filterEqUuid?: string, filterEqValue?: string, filterId?: number, historyDepth?: number, isLatest?: boolean, launchesLimit?: number, pagePage?: number, pageSize?: number, pageSort?: Array<string>, type?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<IterableTestItemHistoryElement> {
            const localVarFetchArgs = TestItemControllerApiFetchParamCreator(configuration).getItemsHistoryUsingGET(projectName, filterEqAttributeKey, filterEqAttributeValue, filterEqAutoAnalyzed, filterEqClusterId, filterEqCompositeAttribute, filterEqCompositeSystemAttribute, filterEqDescription, filterEqDuration, filterEqEndTime, filterEqHasChildren, filterEqHasRetries, filterEqHasStats, filterEqId, filterEqIgnoreAnalyzer, filterEqIssueComment, filterEqIssueGroupId, filterEqIssueId, filterEqIssueType, filterEqIssueTypeId, filterEqKey, filterEqLastModified, filterEqLaunchId, filterEqLevelAttribute, filterEqLocator, filterEqMode, filterEqName, filterEqParentId, filterEqParentId2, filterEqPath, filterEqPatternName, filterEqProjectId, filterEqRetryParentId, filterEqStartTime, filterEqStatisticsdefectsautomationBugab001, filterEqStatisticsdefectsnoDefectnd001, filterEqStatisticsdefectsproductBugpb001, filterEqStatisticsdefectssystemIssuesi001, filterEqStatisticsdefectstoInvestigateti001, filterEqStatisticsexecutionsfailed, filterEqStatisticsexecutionspassed, filterEqStatisticsexecutionsskipped, filterEqStatisticsexecutionstotal, filterEqStatus, filterEqTestCaseHash, filterEqTestCaseId, filterEqTicketId, filterEqType, filterEqUniqueId, filterEqUuid, filterEqValue, filterId, historyDepth, isLatest, launchesLimit, pagePage, pageSize, pageSort, type, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Search suggested items in analyzer for provided one
         * @param {number} clusterId clusterId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSuggestedClusterItemsUsingGET(clusterId: number, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SuggestedItem>> {
            const localVarFetchArgs = TestItemControllerApiFetchParamCreator(configuration).getSuggestedClusterItemsUsingGET(clusterId, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Search suggested items in analyzer for provided one
         * @param {number} itemId itemId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSuggestedItemsUsingGET(itemId: number, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SuggestedItem>> {
            const localVarFetchArgs = TestItemControllerApiFetchParamCreator(configuration).getSuggestedItemsUsingGET(itemId, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find test item by UUID
         * @param {string} itemId itemId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestItemByUuidUsingGET(itemId: string, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TestItemResource> {
            const localVarFetchArgs = TestItemControllerApiFetchParamCreator(configuration).getTestItemByUuidUsingGET(itemId, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find test item by ID
         * @param {string} itemId itemId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestItemUsingGET(itemId: string, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TestItemResource> {
            const localVarFetchArgs = TestItemControllerApiFetchParamCreator(configuration).getTestItemUsingGET(itemId, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get test items by specified ids
         * @param {Array<number>} ids ids
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestItemsUsingGET(ids: Array<number>, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TestItemResource>> {
            const localVarFetchArgs = TestItemControllerApiFetchParamCreator(configuration).getTestItemsUsingGET(ids, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find accumulated statistics of items by specified filter
         * @param {any} params params
         * @param {string} projectName projectName
         * @param {Array<any>} [filterEqAttributeKey] Filters by &#39;attributeKey&#39;
         * @param {Array<any>} [filterEqAttributeValue] Filters by &#39;attributeValue&#39;
         * @param {boolean} [filterEqAutoAnalyzed] Filters by &#39;autoAnalyzed&#39;
         * @param {number} [filterEqClusterId] Filters by &#39;clusterId&#39;
         * @param {Array<string>} [filterEqCompositeAttribute] Filters by &#39;compositeAttribute&#39;
         * @param {Array<string>} [filterEqCompositeSystemAttribute] Filters by &#39;compositeSystemAttribute&#39;
         * @param {string} [filterEqDescription] Filters by &#39;description&#39;
         * @param {number} [filterEqDuration] Filters by &#39;duration&#39;
         * @param {Date} [filterEqEndTime] Filters by &#39;endTime&#39;
         * @param {boolean} [filterEqHasChildren] Filters by &#39;hasChildren&#39;
         * @param {boolean} [filterEqHasRetries] Filters by &#39;hasRetries&#39;
         * @param {boolean} [filterEqHasStats] Filters by &#39;hasStats&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {boolean} [filterEqIgnoreAnalyzer] Filters by &#39;ignoreAnalyzer&#39;
         * @param {string} [filterEqIssueComment] Filters by &#39;issueComment&#39;
         * @param {number} [filterEqIssueGroupId] Filters by &#39;issueGroupId&#39;
         * @param {number} [filterEqIssueId] Filters by &#39;issueId&#39;
         * @param {string} [filterEqIssueType] Filters by &#39;issueType&#39;
         * @param {number} [filterEqIssueTypeId] Filters by &#39;issueTypeId&#39;
         * @param {string} [filterEqKey] Filters by &#39;key&#39;
         * @param {string} [filterEqLastModified] Filters by &#39;lastModified&#39;
         * @param {number} [filterEqLaunchId] Filters by &#39;launchId&#39;
         * @param {Array<any>} [filterEqLevelAttribute] Filters by &#39;levelAttribute&#39;
         * @param {string} [filterEqLocator] Filters by &#39;locator&#39;
         * @param {string} [filterEqMode] Filters by &#39;mode&#39;
         * @param {string} [filterEqName] Filters by &#39;name&#39;
         * @param {number} [filterEqParentId] Filters by &#39;parentId&#39;
         * @param {number} [filterEqParentId2] Filters by &#39;parentId&#39;
         * @param {number} [filterEqPath] Filters by &#39;path&#39;
         * @param {Array<any>} [filterEqPatternName] Filters by &#39;patternName&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {number} [filterEqRetryParentId] Filters by &#39;retryParentId&#39;
         * @param {Date} [filterEqStartTime] Filters by &#39;startTime&#39;
         * @param {number} [filterEqStatisticsdefectsautomationBugab001] Filters by &#39;statistics$defects$automation_bug$ab001&#39;
         * @param {number} [filterEqStatisticsdefectsnoDefectnd001] Filters by &#39;statistics$defects$no_defect$nd001&#39;
         * @param {number} [filterEqStatisticsdefectsproductBugpb001] Filters by &#39;statistics$defects$product_bug$pb001&#39;
         * @param {number} [filterEqStatisticsdefectssystemIssuesi001] Filters by &#39;statistics$defects$system_issue$si001&#39;
         * @param {number} [filterEqStatisticsdefectstoInvestigateti001] Filters by &#39;statistics$defects$to_investigate$ti001&#39;
         * @param {number} [filterEqStatisticsexecutionsfailed] Filters by &#39;statistics$executions$failed&#39;
         * @param {number} [filterEqStatisticsexecutionspassed] Filters by &#39;statistics$executions$passed&#39;
         * @param {number} [filterEqStatisticsexecutionsskipped] Filters by &#39;statistics$executions$skipped&#39;
         * @param {number} [filterEqStatisticsexecutionstotal] Filters by &#39;statistics$executions$total&#39;
         * @param {string} [filterEqStatus] Filters by &#39;status&#39;
         * @param {number} [filterEqTestCaseHash] Filters by &#39;testCaseHash&#39;
         * @param {string} [filterEqTestCaseId] Filters by &#39;testCaseId&#39;
         * @param {string} [filterEqTicketId] Filters by &#39;ticketId&#39;
         * @param {string} [filterEqType] Filters by &#39;type&#39;
         * @param {string} [filterEqUniqueId] Filters by &#39;uniqueId&#39;
         * @param {string} [filterEqUuid] Filters by &#39;uuid&#39;
         * @param {string} [filterEqValue] Filters by &#39;value&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestItemsUsingGET1(params: any, projectName: string, filterEqAttributeKey?: Array<any>, filterEqAttributeValue?: Array<any>, filterEqAutoAnalyzed?: boolean, filterEqClusterId?: number, filterEqCompositeAttribute?: Array<string>, filterEqCompositeSystemAttribute?: Array<string>, filterEqDescription?: string, filterEqDuration?: number, filterEqEndTime?: Date, filterEqHasChildren?: boolean, filterEqHasRetries?: boolean, filterEqHasStats?: boolean, filterEqId?: number, filterEqIgnoreAnalyzer?: boolean, filterEqIssueComment?: string, filterEqIssueGroupId?: number, filterEqIssueId?: number, filterEqIssueType?: string, filterEqIssueTypeId?: number, filterEqKey?: string, filterEqLastModified?: string, filterEqLaunchId?: number, filterEqLevelAttribute?: Array<any>, filterEqLocator?: string, filterEqMode?: string, filterEqName?: string, filterEqParentId?: number, filterEqParentId2?: number, filterEqPath?: number, filterEqPatternName?: Array<any>, filterEqProjectId?: number, filterEqRetryParentId?: number, filterEqStartTime?: Date, filterEqStatisticsdefectsautomationBugab001?: number, filterEqStatisticsdefectsnoDefectnd001?: number, filterEqStatisticsdefectsproductBugpb001?: number, filterEqStatisticsdefectssystemIssuesi001?: number, filterEqStatisticsdefectstoInvestigateti001?: number, filterEqStatisticsexecutionsfailed?: number, filterEqStatisticsexecutionspassed?: number, filterEqStatisticsexecutionsskipped?: number, filterEqStatisticsexecutionstotal?: number, filterEqStatus?: string, filterEqTestCaseHash?: number, filterEqTestCaseId?: string, filterEqTicketId?: string, filterEqType?: string, filterEqUniqueId?: string, filterEqUuid?: string, filterEqValue?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StatisticsResource> {
            const localVarFetchArgs = TestItemControllerApiFetchParamCreator(configuration).getTestItemsUsingGET1(params, projectName, filterEqAttributeKey, filterEqAttributeValue, filterEqAutoAnalyzed, filterEqClusterId, filterEqCompositeAttribute, filterEqCompositeSystemAttribute, filterEqDescription, filterEqDuration, filterEqEndTime, filterEqHasChildren, filterEqHasRetries, filterEqHasStats, filterEqId, filterEqIgnoreAnalyzer, filterEqIssueComment, filterEqIssueGroupId, filterEqIssueId, filterEqIssueType, filterEqIssueTypeId, filterEqKey, filterEqLastModified, filterEqLaunchId, filterEqLevelAttribute, filterEqLocator, filterEqMode, filterEqName, filterEqParentId, filterEqParentId2, filterEqPath, filterEqPatternName, filterEqProjectId, filterEqRetryParentId, filterEqStartTime, filterEqStatisticsdefectsautomationBugab001, filterEqStatisticsdefectsnoDefectnd001, filterEqStatisticsdefectsproductBugpb001, filterEqStatisticsdefectssystemIssuesi001, filterEqStatisticsdefectstoInvestigateti001, filterEqStatisticsexecutionsfailed, filterEqStatisticsexecutionspassed, filterEqStatisticsexecutionsskipped, filterEqStatisticsexecutionstotal, filterEqStatus, filterEqTestCaseHash, filterEqTestCaseId, filterEqTicketId, filterEqType, filterEqUniqueId, filterEqUuid, filterEqValue, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find test items by specified filter
         * @param {string} projectName projectName
         * @param {Array<any>} [filterEqAttributeKey] Filters by &#39;attributeKey&#39;
         * @param {Array<any>} [filterEqAttributeValue] Filters by &#39;attributeValue&#39;
         * @param {boolean} [filterEqAutoAnalyzed] Filters by &#39;autoAnalyzed&#39;
         * @param {number} [filterEqClusterId] Filters by &#39;clusterId&#39;
         * @param {Array<string>} [filterEqCompositeAttribute] Filters by &#39;compositeAttribute&#39;
         * @param {Array<string>} [filterEqCompositeSystemAttribute] Filters by &#39;compositeSystemAttribute&#39;
         * @param {string} [filterEqDescription] Filters by &#39;description&#39;
         * @param {number} [filterEqDuration] Filters by &#39;duration&#39;
         * @param {Date} [filterEqEndTime] Filters by &#39;endTime&#39;
         * @param {boolean} [filterEqHasChildren] Filters by &#39;hasChildren&#39;
         * @param {boolean} [filterEqHasRetries] Filters by &#39;hasRetries&#39;
         * @param {boolean} [filterEqHasStats] Filters by &#39;hasStats&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {boolean} [filterEqIgnoreAnalyzer] Filters by &#39;ignoreAnalyzer&#39;
         * @param {string} [filterEqIssueComment] Filters by &#39;issueComment&#39;
         * @param {number} [filterEqIssueGroupId] Filters by &#39;issueGroupId&#39;
         * @param {number} [filterEqIssueId] Filters by &#39;issueId&#39;
         * @param {string} [filterEqIssueType] Filters by &#39;issueType&#39;
         * @param {number} [filterEqIssueTypeId] Filters by &#39;issueTypeId&#39;
         * @param {string} [filterEqKey] Filters by &#39;key&#39;
         * @param {string} [filterEqLastModified] Filters by &#39;lastModified&#39;
         * @param {number} [filterEqLaunchId] Filters by &#39;launchId&#39;
         * @param {Array<any>} [filterEqLevelAttribute] Filters by &#39;levelAttribute&#39;
         * @param {string} [filterEqLocator] Filters by &#39;locator&#39;
         * @param {string} [filterEqMode] Filters by &#39;mode&#39;
         * @param {string} [filterEqName] Filters by &#39;name&#39;
         * @param {number} [filterEqParentId] Filters by &#39;parentId&#39;
         * @param {number} [filterEqParentId2] Filters by &#39;parentId&#39;
         * @param {number} [filterEqPath] Filters by &#39;path&#39;
         * @param {Array<any>} [filterEqPatternName] Filters by &#39;patternName&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {number} [filterEqRetryParentId] Filters by &#39;retryParentId&#39;
         * @param {Date} [filterEqStartTime] Filters by &#39;startTime&#39;
         * @param {number} [filterEqStatisticsdefectsautomationBugab001] Filters by &#39;statistics$defects$automation_bug$ab001&#39;
         * @param {number} [filterEqStatisticsdefectsnoDefectnd001] Filters by &#39;statistics$defects$no_defect$nd001&#39;
         * @param {number} [filterEqStatisticsdefectsproductBugpb001] Filters by &#39;statistics$defects$product_bug$pb001&#39;
         * @param {number} [filterEqStatisticsdefectssystemIssuesi001] Filters by &#39;statistics$defects$system_issue$si001&#39;
         * @param {number} [filterEqStatisticsdefectstoInvestigateti001] Filters by &#39;statistics$defects$to_investigate$ti001&#39;
         * @param {number} [filterEqStatisticsexecutionsfailed] Filters by &#39;statistics$executions$failed&#39;
         * @param {number} [filterEqStatisticsexecutionspassed] Filters by &#39;statistics$executions$passed&#39;
         * @param {number} [filterEqStatisticsexecutionsskipped] Filters by &#39;statistics$executions$skipped&#39;
         * @param {number} [filterEqStatisticsexecutionstotal] Filters by &#39;statistics$executions$total&#39;
         * @param {string} [filterEqStatus] Filters by &#39;status&#39;
         * @param {number} [filterEqTestCaseHash] Filters by &#39;testCaseHash&#39;
         * @param {string} [filterEqTestCaseId] Filters by &#39;testCaseId&#39;
         * @param {string} [filterEqTicketId] Filters by &#39;ticketId&#39;
         * @param {string} [filterEqType] Filters by &#39;type&#39;
         * @param {string} [filterEqUniqueId] Filters by &#39;uniqueId&#39;
         * @param {string} [filterEqUuid] Filters by &#39;uuid&#39;
         * @param {string} [filterEqValue] Filters by &#39;value&#39;
         * @param {number} [filterId] filterId
         * @param {boolean} [isLatest] isLatest
         * @param {number} [launchesLimit] launchesLimit
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestItemsUsingGET2(projectName: string, filterEqAttributeKey?: Array<any>, filterEqAttributeValue?: Array<any>, filterEqAutoAnalyzed?: boolean, filterEqClusterId?: number, filterEqCompositeAttribute?: Array<string>, filterEqCompositeSystemAttribute?: Array<string>, filterEqDescription?: string, filterEqDuration?: number, filterEqEndTime?: Date, filterEqHasChildren?: boolean, filterEqHasRetries?: boolean, filterEqHasStats?: boolean, filterEqId?: number, filterEqIgnoreAnalyzer?: boolean, filterEqIssueComment?: string, filterEqIssueGroupId?: number, filterEqIssueId?: number, filterEqIssueType?: string, filterEqIssueTypeId?: number, filterEqKey?: string, filterEqLastModified?: string, filterEqLaunchId?: number, filterEqLevelAttribute?: Array<any>, filterEqLocator?: string, filterEqMode?: string, filterEqName?: string, filterEqParentId?: number, filterEqParentId2?: number, filterEqPath?: number, filterEqPatternName?: Array<any>, filterEqProjectId?: number, filterEqRetryParentId?: number, filterEqStartTime?: Date, filterEqStatisticsdefectsautomationBugab001?: number, filterEqStatisticsdefectsnoDefectnd001?: number, filterEqStatisticsdefectsproductBugpb001?: number, filterEqStatisticsdefectssystemIssuesi001?: number, filterEqStatisticsdefectstoInvestigateti001?: number, filterEqStatisticsexecutionsfailed?: number, filterEqStatisticsexecutionspassed?: number, filterEqStatisticsexecutionsskipped?: number, filterEqStatisticsexecutionstotal?: number, filterEqStatus?: string, filterEqTestCaseHash?: number, filterEqTestCaseId?: string, filterEqTicketId?: string, filterEqType?: string, filterEqUniqueId?: string, filterEqUuid?: string, filterEqValue?: string, filterId?: number, isLatest?: boolean, launchesLimit?: number, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<IterableTestItemResource> {
            const localVarFetchArgs = TestItemControllerApiFetchParamCreator(configuration).getTestItemsUsingGET2(projectName, filterEqAttributeKey, filterEqAttributeValue, filterEqAutoAnalyzed, filterEqClusterId, filterEqCompositeAttribute, filterEqCompositeSystemAttribute, filterEqDescription, filterEqDuration, filterEqEndTime, filterEqHasChildren, filterEqHasRetries, filterEqHasStats, filterEqId, filterEqIgnoreAnalyzer, filterEqIssueComment, filterEqIssueGroupId, filterEqIssueId, filterEqIssueType, filterEqIssueTypeId, filterEqKey, filterEqLastModified, filterEqLaunchId, filterEqLevelAttribute, filterEqLocator, filterEqMode, filterEqName, filterEqParentId, filterEqParentId2, filterEqPath, filterEqPatternName, filterEqProjectId, filterEqRetryParentId, filterEqStartTime, filterEqStatisticsdefectsautomationBugab001, filterEqStatisticsdefectsnoDefectnd001, filterEqStatisticsdefectsproductBugpb001, filterEqStatisticsdefectssystemIssuesi001, filterEqStatisticsdefectstoInvestigateti001, filterEqStatisticsexecutionsfailed, filterEqStatisticsexecutionspassed, filterEqStatisticsexecutionsskipped, filterEqStatisticsexecutionstotal, filterEqStatus, filterEqTestCaseHash, filterEqTestCaseId, filterEqTicketId, filterEqType, filterEqUniqueId, filterEqUuid, filterEqValue, filterId, isLatest, launchesLimit, pagePage, pageSize, pageSort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Find test items by specified filter
         * @param {any} params params
         * @param {string} projectName projectName
         * @param {Array<any>} [filterEqAttributeKey] Filters by &#39;attributeKey&#39;
         * @param {Array<any>} [filterEqAttributeValue] Filters by &#39;attributeValue&#39;
         * @param {boolean} [filterEqAutoAnalyzed] Filters by &#39;autoAnalyzed&#39;
         * @param {number} [filterEqClusterId] Filters by &#39;clusterId&#39;
         * @param {Array<string>} [filterEqCompositeAttribute] Filters by &#39;compositeAttribute&#39;
         * @param {Array<string>} [filterEqCompositeSystemAttribute] Filters by &#39;compositeSystemAttribute&#39;
         * @param {string} [filterEqDescription] Filters by &#39;description&#39;
         * @param {number} [filterEqDuration] Filters by &#39;duration&#39;
         * @param {Date} [filterEqEndTime] Filters by &#39;endTime&#39;
         * @param {boolean} [filterEqHasChildren] Filters by &#39;hasChildren&#39;
         * @param {boolean} [filterEqHasRetries] Filters by &#39;hasRetries&#39;
         * @param {boolean} [filterEqHasStats] Filters by &#39;hasStats&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {boolean} [filterEqIgnoreAnalyzer] Filters by &#39;ignoreAnalyzer&#39;
         * @param {string} [filterEqIssueComment] Filters by &#39;issueComment&#39;
         * @param {number} [filterEqIssueGroupId] Filters by &#39;issueGroupId&#39;
         * @param {number} [filterEqIssueId] Filters by &#39;issueId&#39;
         * @param {string} [filterEqIssueType] Filters by &#39;issueType&#39;
         * @param {number} [filterEqIssueTypeId] Filters by &#39;issueTypeId&#39;
         * @param {string} [filterEqKey] Filters by &#39;key&#39;
         * @param {string} [filterEqLastModified] Filters by &#39;lastModified&#39;
         * @param {number} [filterEqLaunchId] Filters by &#39;launchId&#39;
         * @param {Array<any>} [filterEqLevelAttribute] Filters by &#39;levelAttribute&#39;
         * @param {string} [filterEqLocator] Filters by &#39;locator&#39;
         * @param {string} [filterEqMode] Filters by &#39;mode&#39;
         * @param {string} [filterEqName] Filters by &#39;name&#39;
         * @param {number} [filterEqParentId] Filters by &#39;parentId&#39;
         * @param {number} [filterEqParentId2] Filters by &#39;parentId&#39;
         * @param {number} [filterEqPath] Filters by &#39;path&#39;
         * @param {Array<any>} [filterEqPatternName] Filters by &#39;patternName&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {number} [filterEqRetryParentId] Filters by &#39;retryParentId&#39;
         * @param {Date} [filterEqStartTime] Filters by &#39;startTime&#39;
         * @param {number} [filterEqStatisticsdefectsautomationBugab001] Filters by &#39;statistics$defects$automation_bug$ab001&#39;
         * @param {number} [filterEqStatisticsdefectsnoDefectnd001] Filters by &#39;statistics$defects$no_defect$nd001&#39;
         * @param {number} [filterEqStatisticsdefectsproductBugpb001] Filters by &#39;statistics$defects$product_bug$pb001&#39;
         * @param {number} [filterEqStatisticsdefectssystemIssuesi001] Filters by &#39;statistics$defects$system_issue$si001&#39;
         * @param {number} [filterEqStatisticsdefectstoInvestigateti001] Filters by &#39;statistics$defects$to_investigate$ti001&#39;
         * @param {number} [filterEqStatisticsexecutionsfailed] Filters by &#39;statistics$executions$failed&#39;
         * @param {number} [filterEqStatisticsexecutionspassed] Filters by &#39;statistics$executions$passed&#39;
         * @param {number} [filterEqStatisticsexecutionsskipped] Filters by &#39;statistics$executions$skipped&#39;
         * @param {number} [filterEqStatisticsexecutionstotal] Filters by &#39;statistics$executions$total&#39;
         * @param {string} [filterEqStatus] Filters by &#39;status&#39;
         * @param {number} [filterEqTestCaseHash] Filters by &#39;testCaseHash&#39;
         * @param {string} [filterEqTestCaseId] Filters by &#39;testCaseId&#39;
         * @param {string} [filterEqTicketId] Filters by &#39;ticketId&#39;
         * @param {string} [filterEqType] Filters by &#39;type&#39;
         * @param {string} [filterEqUniqueId] Filters by &#39;uniqueId&#39;
         * @param {string} [filterEqUuid] Filters by &#39;uuid&#39;
         * @param {string} [filterEqValue] Filters by &#39;value&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestItemsV2UsingGET(params: any, projectName: string, filterEqAttributeKey?: Array<any>, filterEqAttributeValue?: Array<any>, filterEqAutoAnalyzed?: boolean, filterEqClusterId?: number, filterEqCompositeAttribute?: Array<string>, filterEqCompositeSystemAttribute?: Array<string>, filterEqDescription?: string, filterEqDuration?: number, filterEqEndTime?: Date, filterEqHasChildren?: boolean, filterEqHasRetries?: boolean, filterEqHasStats?: boolean, filterEqId?: number, filterEqIgnoreAnalyzer?: boolean, filterEqIssueComment?: string, filterEqIssueGroupId?: number, filterEqIssueId?: number, filterEqIssueType?: string, filterEqIssueTypeId?: number, filterEqKey?: string, filterEqLastModified?: string, filterEqLaunchId?: number, filterEqLevelAttribute?: Array<any>, filterEqLocator?: string, filterEqMode?: string, filterEqName?: string, filterEqParentId?: number, filterEqParentId2?: number, filterEqPath?: number, filterEqPatternName?: Array<any>, filterEqProjectId?: number, filterEqRetryParentId?: number, filterEqStartTime?: Date, filterEqStatisticsdefectsautomationBugab001?: number, filterEqStatisticsdefectsnoDefectnd001?: number, filterEqStatisticsdefectsproductBugpb001?: number, filterEqStatisticsdefectssystemIssuesi001?: number, filterEqStatisticsdefectstoInvestigateti001?: number, filterEqStatisticsexecutionsfailed?: number, filterEqStatisticsexecutionspassed?: number, filterEqStatisticsexecutionsskipped?: number, filterEqStatisticsexecutionstotal?: number, filterEqStatus?: string, filterEqTestCaseHash?: number, filterEqTestCaseId?: string, filterEqTicketId?: string, filterEqType?: string, filterEqUniqueId?: string, filterEqUuid?: string, filterEqValue?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<IterableTestItemResource> {
            const localVarFetchArgs = TestItemControllerApiFetchParamCreator(configuration).getTestItemsV2UsingGET(params, projectName, filterEqAttributeKey, filterEqAttributeValue, filterEqAutoAnalyzed, filterEqClusterId, filterEqCompositeAttribute, filterEqCompositeSystemAttribute, filterEqDescription, filterEqDuration, filterEqEndTime, filterEqHasChildren, filterEqHasRetries, filterEqHasStats, filterEqId, filterEqIgnoreAnalyzer, filterEqIssueComment, filterEqIssueGroupId, filterEqIssueId, filterEqIssueType, filterEqIssueTypeId, filterEqKey, filterEqLastModified, filterEqLaunchId, filterEqLevelAttribute, filterEqLocator, filterEqMode, filterEqName, filterEqParentId, filterEqParentId2, filterEqPath, filterEqPatternName, filterEqProjectId, filterEqRetryParentId, filterEqStartTime, filterEqStatisticsdefectsautomationBugab001, filterEqStatisticsdefectsnoDefectnd001, filterEqStatisticsdefectsproductBugpb001, filterEqStatisticsdefectssystemIssuesi001, filterEqStatisticsdefectstoInvestigateti001, filterEqStatisticsexecutionsfailed, filterEqStatisticsexecutionspassed, filterEqStatisticsexecutionsskipped, filterEqStatisticsexecutionstotal, filterEqStatus, filterEqTestCaseHash, filterEqTestCaseId, filterEqTicketId, filterEqType, filterEqUniqueId, filterEqUuid, filterEqValue, pagePage, pageSize, pageSort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get tickets that contains a term as a part inside for specified launch
         * @param {string} projectName projectName
         * @param {string} term term
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicketIdsForProjectUsingGET(projectName: string, term: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = TestItemControllerApiFetchParamCreator(configuration).getTicketIdsForProjectUsingGET(projectName, term, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get tickets that contains a term as a part inside for specified launch
         * @param {number} launch launch
         * @param {string} projectName projectName
         * @param {string} term term
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicketIdsUsingGET(launch: number, projectName: string, term: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = TestItemControllerApiFetchParamCreator(configuration).getTicketIdsUsingGET(launch, projectName, term, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Handle user choice from suggested items
         * @param {string} projectName projectName
         * @param {Array<SuggestInfo>} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleSuggestChooseUsingPUT(projectName: string, request: Array<SuggestInfo>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = TestItemControllerApiFetchParamCreator(configuration).handleSuggestChooseUsingPUT(projectName, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Attach external issue for specified test items
         * @param {string} projectName projectName
         * @param {LinkExternalIssueRQ} rq rq
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkExternalIssuesUsingPUT(projectName: string, rq: LinkExternalIssueRQ, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<OperationCompletionRS>> {
            const localVarFetchArgs = TestItemControllerApiFetchParamCreator(configuration).linkExternalIssuesUsingPUT(projectName, rq, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Start a child test item
         * @param {string} parentItem parentItem
         * @param {string} projectName projectName
         * @param {StartTestItemRQ} startTestItemRQ startTestItemRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startChildItemUsingPOST1(parentItem: string, projectName: string, startTestItemRQ: StartTestItemRQ, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EntryCreatedAsyncRS> {
            const localVarFetchArgs = TestItemControllerApiFetchParamCreator(configuration).startChildItemUsingPOST1(parentItem, projectName, startTestItemRQ, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Start a root test item
         * @param {string} projectName projectName
         * @param {StartTestItemRQ} startTestItemRQ startTestItemRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRootItemUsingPOST1(projectName: string, startTestItemRQ: StartTestItemRQ, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EntryCreatedAsyncRS> {
            const localVarFetchArgs = TestItemControllerApiFetchParamCreator(configuration).startRootItemUsingPOST1(projectName, startTestItemRQ, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Unlink external issue for specified test items
         * @param {string} projectName projectName
         * @param {UnlinkExternalIssueRQ} rq rq
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkExternalIssuesUsingPUT(projectName: string, rq: UnlinkExternalIssueRQ, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<OperationCompletionRS>> {
            const localVarFetchArgs = TestItemControllerApiFetchParamCreator(configuration).unlinkExternalIssuesUsingPUT(projectName, rq, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update test item
         * @param {number} itemId itemId
         * @param {string} projectName projectName
         * @param {UpdateTestItemRQ} rq rq
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTestItemUsingPUT(itemId: number, projectName: string, rq: UpdateTestItemRQ, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = TestItemControllerApiFetchParamCreator(configuration).updateTestItemUsingPUT(itemId, projectName, rq, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TestItemControllerApi - factory interface
 * @export
 */
export const TestItemControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Bulk update attributes and description
         * @param {BulkInfoUpdateRQ} bulkInfoUpdateRQ bulkInfoUpdateRQ
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateUsingPUT1(bulkInfoUpdateRQ: BulkInfoUpdateRQ, projectName: string, options?: any) {
            return TestItemControllerApiFp(configuration).bulkUpdateUsingPUT1(bulkInfoUpdateRQ, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update issues of specified test items
         * @param {string} projectName projectName
         * @param {DefineIssueRQ} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defineTestItemIssueTypeUsingPUT(projectName: string, request: DefineIssueRQ, options?: any) {
            return TestItemControllerApiFp(configuration).defineTestItemIssueTypeUsingPUT(projectName, request, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete test item
         * @param {number} itemId itemId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTestItemUsingDELETE(itemId: number, projectName: string, options?: any) {
            return TestItemControllerApiFp(configuration).deleteTestItemUsingDELETE(itemId, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete test items by specified ids
         * @param {Array<number>} ids ids
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTestItemsUsingDELETE(ids: Array<number>, projectName: string, options?: any) {
            return TestItemControllerApiFp(configuration).deleteTestItemsUsingDELETE(ids, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Finish test item
         * @param {FinishTestItemRQ} finishExecutionRQ finishExecutionRQ
         * @param {string} projectName projectName
         * @param {string} testItemId testItemId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finishTestItemUsingPUT1(finishExecutionRQ: FinishTestItemRQ, projectName: string, testItemId: string, options?: any) {
            return TestItemControllerApiFp(configuration).finishTestItemUsingPUT1(finishExecutionRQ, projectName, testItemId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get all unique attribute keys of specified launch
         * @param {string} filterCntAttributeKey filter.cnt.attributeKey
         * @param {number} filterId filterId
         * @param {string} projectName projectName
         * @param {boolean} [isLatest] isLatest
         * @param {number} [launchesLimit] launchesLimit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributeKeysForProjectUsingGET(filterCntAttributeKey: string, filterId: number, projectName: string, isLatest?: boolean, launchesLimit?: number, options?: any) {
            return TestItemControllerApiFp(configuration).getAttributeKeysForProjectUsingGET(filterCntAttributeKey, filterId, projectName, isLatest, launchesLimit, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get all unique attribute keys of specified launch
         * @param {string} filterCntAttributeKey filter.cnt.attributeKey
         * @param {number} launch launch
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributeKeysUsingGET1(filterCntAttributeKey: string, launch: number, projectName: string, options?: any) {
            return TestItemControllerApiFp(configuration).getAttributeKeysUsingGET1(filterCntAttributeKey, launch, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get all unique attribute keys of step items under specified project
         * @param {string} filterCntAttributeKey filter.cnt.attributeKey
         * @param {string} projectName projectName
         * @param {string} [filterEqName] filter.eq.name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributeKeysUsingGET2(filterCntAttributeKey: string, projectName: string, filterEqName?: string, options?: any) {
            return TestItemControllerApiFp(configuration).getAttributeKeysUsingGET2(filterCntAttributeKey, projectName, filterEqName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get all unique attribute values of specified launch
         * @param {string} filterCntAttributeValue filter.cnt.attributeValue
         * @param {number} launch launch
         * @param {string} projectName projectName
         * @param {string} [filterEqAttributeKey] filter.eq.attributeKey
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributeValuesUsingGET1(filterCntAttributeValue: string, launch: number, projectName: string, filterEqAttributeKey?: string, options?: any) {
            return TestItemControllerApiFp(configuration).getAttributeValuesUsingGET1(filterCntAttributeValue, launch, projectName, filterEqAttributeKey, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get all unique attribute values of step items under specified project
         * @param {string} filterCntAttributeValue filter.cnt.attributeValue
         * @param {string} projectName projectName
         * @param {string} [filterEqAttributeKey] filter.eq.attributeKey
         * @param {string} [filterEqName] filter.eq.name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributeValuesUsingGET2(filterCntAttributeValue: string, projectName: string, filterEqAttributeKey?: string, filterEqName?: string, options?: any) {
            return TestItemControllerApiFp(configuration).getAttributeValuesUsingGET2(filterCntAttributeValue, projectName, filterEqAttributeKey, filterEqName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Load history of test items
         * @param {string} projectName projectName
         * @param {Array<any>} [filterEqAttributeKey] Filters by &#39;attributeKey&#39;
         * @param {Array<any>} [filterEqAttributeValue] Filters by &#39;attributeValue&#39;
         * @param {boolean} [filterEqAutoAnalyzed] Filters by &#39;autoAnalyzed&#39;
         * @param {number} [filterEqClusterId] Filters by &#39;clusterId&#39;
         * @param {Array<string>} [filterEqCompositeAttribute] Filters by &#39;compositeAttribute&#39;
         * @param {Array<string>} [filterEqCompositeSystemAttribute] Filters by &#39;compositeSystemAttribute&#39;
         * @param {string} [filterEqDescription] Filters by &#39;description&#39;
         * @param {number} [filterEqDuration] Filters by &#39;duration&#39;
         * @param {Date} [filterEqEndTime] Filters by &#39;endTime&#39;
         * @param {boolean} [filterEqHasChildren] Filters by &#39;hasChildren&#39;
         * @param {boolean} [filterEqHasRetries] Filters by &#39;hasRetries&#39;
         * @param {boolean} [filterEqHasStats] Filters by &#39;hasStats&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {boolean} [filterEqIgnoreAnalyzer] Filters by &#39;ignoreAnalyzer&#39;
         * @param {string} [filterEqIssueComment] Filters by &#39;issueComment&#39;
         * @param {number} [filterEqIssueGroupId] Filters by &#39;issueGroupId&#39;
         * @param {number} [filterEqIssueId] Filters by &#39;issueId&#39;
         * @param {string} [filterEqIssueType] Filters by &#39;issueType&#39;
         * @param {number} [filterEqIssueTypeId] Filters by &#39;issueTypeId&#39;
         * @param {string} [filterEqKey] Filters by &#39;key&#39;
         * @param {string} [filterEqLastModified] Filters by &#39;lastModified&#39;
         * @param {number} [filterEqLaunchId] Filters by &#39;launchId&#39;
         * @param {Array<any>} [filterEqLevelAttribute] Filters by &#39;levelAttribute&#39;
         * @param {string} [filterEqLocator] Filters by &#39;locator&#39;
         * @param {string} [filterEqMode] Filters by &#39;mode&#39;
         * @param {string} [filterEqName] Filters by &#39;name&#39;
         * @param {number} [filterEqParentId] Filters by &#39;parentId&#39;
         * @param {number} [filterEqParentId2] Filters by &#39;parentId&#39;
         * @param {number} [filterEqPath] Filters by &#39;path&#39;
         * @param {Array<any>} [filterEqPatternName] Filters by &#39;patternName&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {number} [filterEqRetryParentId] Filters by &#39;retryParentId&#39;
         * @param {Date} [filterEqStartTime] Filters by &#39;startTime&#39;
         * @param {number} [filterEqStatisticsdefectsautomationBugab001] Filters by &#39;statistics$defects$automation_bug$ab001&#39;
         * @param {number} [filterEqStatisticsdefectsnoDefectnd001] Filters by &#39;statistics$defects$no_defect$nd001&#39;
         * @param {number} [filterEqStatisticsdefectsproductBugpb001] Filters by &#39;statistics$defects$product_bug$pb001&#39;
         * @param {number} [filterEqStatisticsdefectssystemIssuesi001] Filters by &#39;statistics$defects$system_issue$si001&#39;
         * @param {number} [filterEqStatisticsdefectstoInvestigateti001] Filters by &#39;statistics$defects$to_investigate$ti001&#39;
         * @param {number} [filterEqStatisticsexecutionsfailed] Filters by &#39;statistics$executions$failed&#39;
         * @param {number} [filterEqStatisticsexecutionspassed] Filters by &#39;statistics$executions$passed&#39;
         * @param {number} [filterEqStatisticsexecutionsskipped] Filters by &#39;statistics$executions$skipped&#39;
         * @param {number} [filterEqStatisticsexecutionstotal] Filters by &#39;statistics$executions$total&#39;
         * @param {string} [filterEqStatus] Filters by &#39;status&#39;
         * @param {number} [filterEqTestCaseHash] Filters by &#39;testCaseHash&#39;
         * @param {string} [filterEqTestCaseId] Filters by &#39;testCaseId&#39;
         * @param {string} [filterEqTicketId] Filters by &#39;ticketId&#39;
         * @param {string} [filterEqType] Filters by &#39;type&#39;
         * @param {string} [filterEqUniqueId] Filters by &#39;uniqueId&#39;
         * @param {string} [filterEqUuid] Filters by &#39;uuid&#39;
         * @param {string} [filterEqValue] Filters by &#39;value&#39;
         * @param {number} [filterId] filterId
         * @param {number} [historyDepth] historyDepth
         * @param {boolean} [isLatest] isLatest
         * @param {number} [launchesLimit] launchesLimit
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {string} [type] type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsHistoryUsingGET(projectName: string, filterEqAttributeKey?: Array<any>, filterEqAttributeValue?: Array<any>, filterEqAutoAnalyzed?: boolean, filterEqClusterId?: number, filterEqCompositeAttribute?: Array<string>, filterEqCompositeSystemAttribute?: Array<string>, filterEqDescription?: string, filterEqDuration?: number, filterEqEndTime?: Date, filterEqHasChildren?: boolean, filterEqHasRetries?: boolean, filterEqHasStats?: boolean, filterEqId?: number, filterEqIgnoreAnalyzer?: boolean, filterEqIssueComment?: string, filterEqIssueGroupId?: number, filterEqIssueId?: number, filterEqIssueType?: string, filterEqIssueTypeId?: number, filterEqKey?: string, filterEqLastModified?: string, filterEqLaunchId?: number, filterEqLevelAttribute?: Array<any>, filterEqLocator?: string, filterEqMode?: string, filterEqName?: string, filterEqParentId?: number, filterEqParentId2?: number, filterEqPath?: number, filterEqPatternName?: Array<any>, filterEqProjectId?: number, filterEqRetryParentId?: number, filterEqStartTime?: Date, filterEqStatisticsdefectsautomationBugab001?: number, filterEqStatisticsdefectsnoDefectnd001?: number, filterEqStatisticsdefectsproductBugpb001?: number, filterEqStatisticsdefectssystemIssuesi001?: number, filterEqStatisticsdefectstoInvestigateti001?: number, filterEqStatisticsexecutionsfailed?: number, filterEqStatisticsexecutionspassed?: number, filterEqStatisticsexecutionsskipped?: number, filterEqStatisticsexecutionstotal?: number, filterEqStatus?: string, filterEqTestCaseHash?: number, filterEqTestCaseId?: string, filterEqTicketId?: string, filterEqType?: string, filterEqUniqueId?: string, filterEqUuid?: string, filterEqValue?: string, filterId?: number, historyDepth?: number, isLatest?: boolean, launchesLimit?: number, pagePage?: number, pageSize?: number, pageSort?: Array<string>, type?: string, options?: any) {
            return TestItemControllerApiFp(configuration).getItemsHistoryUsingGET(projectName, filterEqAttributeKey, filterEqAttributeValue, filterEqAutoAnalyzed, filterEqClusterId, filterEqCompositeAttribute, filterEqCompositeSystemAttribute, filterEqDescription, filterEqDuration, filterEqEndTime, filterEqHasChildren, filterEqHasRetries, filterEqHasStats, filterEqId, filterEqIgnoreAnalyzer, filterEqIssueComment, filterEqIssueGroupId, filterEqIssueId, filterEqIssueType, filterEqIssueTypeId, filterEqKey, filterEqLastModified, filterEqLaunchId, filterEqLevelAttribute, filterEqLocator, filterEqMode, filterEqName, filterEqParentId, filterEqParentId2, filterEqPath, filterEqPatternName, filterEqProjectId, filterEqRetryParentId, filterEqStartTime, filterEqStatisticsdefectsautomationBugab001, filterEqStatisticsdefectsnoDefectnd001, filterEqStatisticsdefectsproductBugpb001, filterEqStatisticsdefectssystemIssuesi001, filterEqStatisticsdefectstoInvestigateti001, filterEqStatisticsexecutionsfailed, filterEqStatisticsexecutionspassed, filterEqStatisticsexecutionsskipped, filterEqStatisticsexecutionstotal, filterEqStatus, filterEqTestCaseHash, filterEqTestCaseId, filterEqTicketId, filterEqType, filterEqUniqueId, filterEqUuid, filterEqValue, filterId, historyDepth, isLatest, launchesLimit, pagePage, pageSize, pageSort, type, options)(fetch, basePath);
        },
        /**
         *
         * @summary Search suggested items in analyzer for provided one
         * @param {number} clusterId clusterId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSuggestedClusterItemsUsingGET(clusterId: number, projectName: string, options?: any) {
            return TestItemControllerApiFp(configuration).getSuggestedClusterItemsUsingGET(clusterId, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Search suggested items in analyzer for provided one
         * @param {number} itemId itemId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSuggestedItemsUsingGET(itemId: number, projectName: string, options?: any) {
            return TestItemControllerApiFp(configuration).getSuggestedItemsUsingGET(itemId, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find test item by UUID
         * @param {string} itemId itemId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestItemByUuidUsingGET(itemId: string, projectName: string, options?: any) {
            return TestItemControllerApiFp(configuration).getTestItemByUuidUsingGET(itemId, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find test item by ID
         * @param {string} itemId itemId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestItemUsingGET(itemId: string, projectName: string, options?: any) {
            return TestItemControllerApiFp(configuration).getTestItemUsingGET(itemId, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get test items by specified ids
         * @param {Array<number>} ids ids
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestItemsUsingGET(ids: Array<number>, projectName: string, options?: any) {
            return TestItemControllerApiFp(configuration).getTestItemsUsingGET(ids, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find accumulated statistics of items by specified filter
         * @param {any} params params
         * @param {string} projectName projectName
         * @param {Array<any>} [filterEqAttributeKey] Filters by &#39;attributeKey&#39;
         * @param {Array<any>} [filterEqAttributeValue] Filters by &#39;attributeValue&#39;
         * @param {boolean} [filterEqAutoAnalyzed] Filters by &#39;autoAnalyzed&#39;
         * @param {number} [filterEqClusterId] Filters by &#39;clusterId&#39;
         * @param {Array<string>} [filterEqCompositeAttribute] Filters by &#39;compositeAttribute&#39;
         * @param {Array<string>} [filterEqCompositeSystemAttribute] Filters by &#39;compositeSystemAttribute&#39;
         * @param {string} [filterEqDescription] Filters by &#39;description&#39;
         * @param {number} [filterEqDuration] Filters by &#39;duration&#39;
         * @param {Date} [filterEqEndTime] Filters by &#39;endTime&#39;
         * @param {boolean} [filterEqHasChildren] Filters by &#39;hasChildren&#39;
         * @param {boolean} [filterEqHasRetries] Filters by &#39;hasRetries&#39;
         * @param {boolean} [filterEqHasStats] Filters by &#39;hasStats&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {boolean} [filterEqIgnoreAnalyzer] Filters by &#39;ignoreAnalyzer&#39;
         * @param {string} [filterEqIssueComment] Filters by &#39;issueComment&#39;
         * @param {number} [filterEqIssueGroupId] Filters by &#39;issueGroupId&#39;
         * @param {number} [filterEqIssueId] Filters by &#39;issueId&#39;
         * @param {string} [filterEqIssueType] Filters by &#39;issueType&#39;
         * @param {number} [filterEqIssueTypeId] Filters by &#39;issueTypeId&#39;
         * @param {string} [filterEqKey] Filters by &#39;key&#39;
         * @param {string} [filterEqLastModified] Filters by &#39;lastModified&#39;
         * @param {number} [filterEqLaunchId] Filters by &#39;launchId&#39;
         * @param {Array<any>} [filterEqLevelAttribute] Filters by &#39;levelAttribute&#39;
         * @param {string} [filterEqLocator] Filters by &#39;locator&#39;
         * @param {string} [filterEqMode] Filters by &#39;mode&#39;
         * @param {string} [filterEqName] Filters by &#39;name&#39;
         * @param {number} [filterEqParentId] Filters by &#39;parentId&#39;
         * @param {number} [filterEqParentId2] Filters by &#39;parentId&#39;
         * @param {number} [filterEqPath] Filters by &#39;path&#39;
         * @param {Array<any>} [filterEqPatternName] Filters by &#39;patternName&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {number} [filterEqRetryParentId] Filters by &#39;retryParentId&#39;
         * @param {Date} [filterEqStartTime] Filters by &#39;startTime&#39;
         * @param {number} [filterEqStatisticsdefectsautomationBugab001] Filters by &#39;statistics$defects$automation_bug$ab001&#39;
         * @param {number} [filterEqStatisticsdefectsnoDefectnd001] Filters by &#39;statistics$defects$no_defect$nd001&#39;
         * @param {number} [filterEqStatisticsdefectsproductBugpb001] Filters by &#39;statistics$defects$product_bug$pb001&#39;
         * @param {number} [filterEqStatisticsdefectssystemIssuesi001] Filters by &#39;statistics$defects$system_issue$si001&#39;
         * @param {number} [filterEqStatisticsdefectstoInvestigateti001] Filters by &#39;statistics$defects$to_investigate$ti001&#39;
         * @param {number} [filterEqStatisticsexecutionsfailed] Filters by &#39;statistics$executions$failed&#39;
         * @param {number} [filterEqStatisticsexecutionspassed] Filters by &#39;statistics$executions$passed&#39;
         * @param {number} [filterEqStatisticsexecutionsskipped] Filters by &#39;statistics$executions$skipped&#39;
         * @param {number} [filterEqStatisticsexecutionstotal] Filters by &#39;statistics$executions$total&#39;
         * @param {string} [filterEqStatus] Filters by &#39;status&#39;
         * @param {number} [filterEqTestCaseHash] Filters by &#39;testCaseHash&#39;
         * @param {string} [filterEqTestCaseId] Filters by &#39;testCaseId&#39;
         * @param {string} [filterEqTicketId] Filters by &#39;ticketId&#39;
         * @param {string} [filterEqType] Filters by &#39;type&#39;
         * @param {string} [filterEqUniqueId] Filters by &#39;uniqueId&#39;
         * @param {string} [filterEqUuid] Filters by &#39;uuid&#39;
         * @param {string} [filterEqValue] Filters by &#39;value&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestItemsUsingGET1(params: any, projectName: string, filterEqAttributeKey?: Array<any>, filterEqAttributeValue?: Array<any>, filterEqAutoAnalyzed?: boolean, filterEqClusterId?: number, filterEqCompositeAttribute?: Array<string>, filterEqCompositeSystemAttribute?: Array<string>, filterEqDescription?: string, filterEqDuration?: number, filterEqEndTime?: Date, filterEqHasChildren?: boolean, filterEqHasRetries?: boolean, filterEqHasStats?: boolean, filterEqId?: number, filterEqIgnoreAnalyzer?: boolean, filterEqIssueComment?: string, filterEqIssueGroupId?: number, filterEqIssueId?: number, filterEqIssueType?: string, filterEqIssueTypeId?: number, filterEqKey?: string, filterEqLastModified?: string, filterEqLaunchId?: number, filterEqLevelAttribute?: Array<any>, filterEqLocator?: string, filterEqMode?: string, filterEqName?: string, filterEqParentId?: number, filterEqParentId2?: number, filterEqPath?: number, filterEqPatternName?: Array<any>, filterEqProjectId?: number, filterEqRetryParentId?: number, filterEqStartTime?: Date, filterEqStatisticsdefectsautomationBugab001?: number, filterEqStatisticsdefectsnoDefectnd001?: number, filterEqStatisticsdefectsproductBugpb001?: number, filterEqStatisticsdefectssystemIssuesi001?: number, filterEqStatisticsdefectstoInvestigateti001?: number, filterEqStatisticsexecutionsfailed?: number, filterEqStatisticsexecutionspassed?: number, filterEqStatisticsexecutionsskipped?: number, filterEqStatisticsexecutionstotal?: number, filterEqStatus?: string, filterEqTestCaseHash?: number, filterEqTestCaseId?: string, filterEqTicketId?: string, filterEqType?: string, filterEqUniqueId?: string, filterEqUuid?: string, filterEqValue?: string, options?: any) {
            return TestItemControllerApiFp(configuration).getTestItemsUsingGET1(params, projectName, filterEqAttributeKey, filterEqAttributeValue, filterEqAutoAnalyzed, filterEqClusterId, filterEqCompositeAttribute, filterEqCompositeSystemAttribute, filterEqDescription, filterEqDuration, filterEqEndTime, filterEqHasChildren, filterEqHasRetries, filterEqHasStats, filterEqId, filterEqIgnoreAnalyzer, filterEqIssueComment, filterEqIssueGroupId, filterEqIssueId, filterEqIssueType, filterEqIssueTypeId, filterEqKey, filterEqLastModified, filterEqLaunchId, filterEqLevelAttribute, filterEqLocator, filterEqMode, filterEqName, filterEqParentId, filterEqParentId2, filterEqPath, filterEqPatternName, filterEqProjectId, filterEqRetryParentId, filterEqStartTime, filterEqStatisticsdefectsautomationBugab001, filterEqStatisticsdefectsnoDefectnd001, filterEqStatisticsdefectsproductBugpb001, filterEqStatisticsdefectssystemIssuesi001, filterEqStatisticsdefectstoInvestigateti001, filterEqStatisticsexecutionsfailed, filterEqStatisticsexecutionspassed, filterEqStatisticsexecutionsskipped, filterEqStatisticsexecutionstotal, filterEqStatus, filterEqTestCaseHash, filterEqTestCaseId, filterEqTicketId, filterEqType, filterEqUniqueId, filterEqUuid, filterEqValue, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find test items by specified filter
         * @param {string} projectName projectName
         * @param {Array<any>} [filterEqAttributeKey] Filters by &#39;attributeKey&#39;
         * @param {Array<any>} [filterEqAttributeValue] Filters by &#39;attributeValue&#39;
         * @param {boolean} [filterEqAutoAnalyzed] Filters by &#39;autoAnalyzed&#39;
         * @param {number} [filterEqClusterId] Filters by &#39;clusterId&#39;
         * @param {Array<string>} [filterEqCompositeAttribute] Filters by &#39;compositeAttribute&#39;
         * @param {Array<string>} [filterEqCompositeSystemAttribute] Filters by &#39;compositeSystemAttribute&#39;
         * @param {string} [filterEqDescription] Filters by &#39;description&#39;
         * @param {number} [filterEqDuration] Filters by &#39;duration&#39;
         * @param {Date} [filterEqEndTime] Filters by &#39;endTime&#39;
         * @param {boolean} [filterEqHasChildren] Filters by &#39;hasChildren&#39;
         * @param {boolean} [filterEqHasRetries] Filters by &#39;hasRetries&#39;
         * @param {boolean} [filterEqHasStats] Filters by &#39;hasStats&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {boolean} [filterEqIgnoreAnalyzer] Filters by &#39;ignoreAnalyzer&#39;
         * @param {string} [filterEqIssueComment] Filters by &#39;issueComment&#39;
         * @param {number} [filterEqIssueGroupId] Filters by &#39;issueGroupId&#39;
         * @param {number} [filterEqIssueId] Filters by &#39;issueId&#39;
         * @param {string} [filterEqIssueType] Filters by &#39;issueType&#39;
         * @param {number} [filterEqIssueTypeId] Filters by &#39;issueTypeId&#39;
         * @param {string} [filterEqKey] Filters by &#39;key&#39;
         * @param {string} [filterEqLastModified] Filters by &#39;lastModified&#39;
         * @param {number} [filterEqLaunchId] Filters by &#39;launchId&#39;
         * @param {Array<any>} [filterEqLevelAttribute] Filters by &#39;levelAttribute&#39;
         * @param {string} [filterEqLocator] Filters by &#39;locator&#39;
         * @param {string} [filterEqMode] Filters by &#39;mode&#39;
         * @param {string} [filterEqName] Filters by &#39;name&#39;
         * @param {number} [filterEqParentId] Filters by &#39;parentId&#39;
         * @param {number} [filterEqParentId2] Filters by &#39;parentId&#39;
         * @param {number} [filterEqPath] Filters by &#39;path&#39;
         * @param {Array<any>} [filterEqPatternName] Filters by &#39;patternName&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {number} [filterEqRetryParentId] Filters by &#39;retryParentId&#39;
         * @param {Date} [filterEqStartTime] Filters by &#39;startTime&#39;
         * @param {number} [filterEqStatisticsdefectsautomationBugab001] Filters by &#39;statistics$defects$automation_bug$ab001&#39;
         * @param {number} [filterEqStatisticsdefectsnoDefectnd001] Filters by &#39;statistics$defects$no_defect$nd001&#39;
         * @param {number} [filterEqStatisticsdefectsproductBugpb001] Filters by &#39;statistics$defects$product_bug$pb001&#39;
         * @param {number} [filterEqStatisticsdefectssystemIssuesi001] Filters by &#39;statistics$defects$system_issue$si001&#39;
         * @param {number} [filterEqStatisticsdefectstoInvestigateti001] Filters by &#39;statistics$defects$to_investigate$ti001&#39;
         * @param {number} [filterEqStatisticsexecutionsfailed] Filters by &#39;statistics$executions$failed&#39;
         * @param {number} [filterEqStatisticsexecutionspassed] Filters by &#39;statistics$executions$passed&#39;
         * @param {number} [filterEqStatisticsexecutionsskipped] Filters by &#39;statistics$executions$skipped&#39;
         * @param {number} [filterEqStatisticsexecutionstotal] Filters by &#39;statistics$executions$total&#39;
         * @param {string} [filterEqStatus] Filters by &#39;status&#39;
         * @param {number} [filterEqTestCaseHash] Filters by &#39;testCaseHash&#39;
         * @param {string} [filterEqTestCaseId] Filters by &#39;testCaseId&#39;
         * @param {string} [filterEqTicketId] Filters by &#39;ticketId&#39;
         * @param {string} [filterEqType] Filters by &#39;type&#39;
         * @param {string} [filterEqUniqueId] Filters by &#39;uniqueId&#39;
         * @param {string} [filterEqUuid] Filters by &#39;uuid&#39;
         * @param {string} [filterEqValue] Filters by &#39;value&#39;
         * @param {number} [filterId] filterId
         * @param {boolean} [isLatest] isLatest
         * @param {number} [launchesLimit] launchesLimit
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestItemsUsingGET2(projectName: string, filterEqAttributeKey?: Array<any>, filterEqAttributeValue?: Array<any>, filterEqAutoAnalyzed?: boolean, filterEqClusterId?: number, filterEqCompositeAttribute?: Array<string>, filterEqCompositeSystemAttribute?: Array<string>, filterEqDescription?: string, filterEqDuration?: number, filterEqEndTime?: Date, filterEqHasChildren?: boolean, filterEqHasRetries?: boolean, filterEqHasStats?: boolean, filterEqId?: number, filterEqIgnoreAnalyzer?: boolean, filterEqIssueComment?: string, filterEqIssueGroupId?: number, filterEqIssueId?: number, filterEqIssueType?: string, filterEqIssueTypeId?: number, filterEqKey?: string, filterEqLastModified?: string, filterEqLaunchId?: number, filterEqLevelAttribute?: Array<any>, filterEqLocator?: string, filterEqMode?: string, filterEqName?: string, filterEqParentId?: number, filterEqParentId2?: number, filterEqPath?: number, filterEqPatternName?: Array<any>, filterEqProjectId?: number, filterEqRetryParentId?: number, filterEqStartTime?: Date, filterEqStatisticsdefectsautomationBugab001?: number, filterEqStatisticsdefectsnoDefectnd001?: number, filterEqStatisticsdefectsproductBugpb001?: number, filterEqStatisticsdefectssystemIssuesi001?: number, filterEqStatisticsdefectstoInvestigateti001?: number, filterEqStatisticsexecutionsfailed?: number, filterEqStatisticsexecutionspassed?: number, filterEqStatisticsexecutionsskipped?: number, filterEqStatisticsexecutionstotal?: number, filterEqStatus?: string, filterEqTestCaseHash?: number, filterEqTestCaseId?: string, filterEqTicketId?: string, filterEqType?: string, filterEqUniqueId?: string, filterEqUuid?: string, filterEqValue?: string, filterId?: number, isLatest?: boolean, launchesLimit?: number, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any) {
            return TestItemControllerApiFp(configuration).getTestItemsUsingGET2(projectName, filterEqAttributeKey, filterEqAttributeValue, filterEqAutoAnalyzed, filterEqClusterId, filterEqCompositeAttribute, filterEqCompositeSystemAttribute, filterEqDescription, filterEqDuration, filterEqEndTime, filterEqHasChildren, filterEqHasRetries, filterEqHasStats, filterEqId, filterEqIgnoreAnalyzer, filterEqIssueComment, filterEqIssueGroupId, filterEqIssueId, filterEqIssueType, filterEqIssueTypeId, filterEqKey, filterEqLastModified, filterEqLaunchId, filterEqLevelAttribute, filterEqLocator, filterEqMode, filterEqName, filterEqParentId, filterEqParentId2, filterEqPath, filterEqPatternName, filterEqProjectId, filterEqRetryParentId, filterEqStartTime, filterEqStatisticsdefectsautomationBugab001, filterEqStatisticsdefectsnoDefectnd001, filterEqStatisticsdefectsproductBugpb001, filterEqStatisticsdefectssystemIssuesi001, filterEqStatisticsdefectstoInvestigateti001, filterEqStatisticsexecutionsfailed, filterEqStatisticsexecutionspassed, filterEqStatisticsexecutionsskipped, filterEqStatisticsexecutionstotal, filterEqStatus, filterEqTestCaseHash, filterEqTestCaseId, filterEqTicketId, filterEqType, filterEqUniqueId, filterEqUuid, filterEqValue, filterId, isLatest, launchesLimit, pagePage, pageSize, pageSort, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find test items by specified filter
         * @param {any} params params
         * @param {string} projectName projectName
         * @param {Array<any>} [filterEqAttributeKey] Filters by &#39;attributeKey&#39;
         * @param {Array<any>} [filterEqAttributeValue] Filters by &#39;attributeValue&#39;
         * @param {boolean} [filterEqAutoAnalyzed] Filters by &#39;autoAnalyzed&#39;
         * @param {number} [filterEqClusterId] Filters by &#39;clusterId&#39;
         * @param {Array<string>} [filterEqCompositeAttribute] Filters by &#39;compositeAttribute&#39;
         * @param {Array<string>} [filterEqCompositeSystemAttribute] Filters by &#39;compositeSystemAttribute&#39;
         * @param {string} [filterEqDescription] Filters by &#39;description&#39;
         * @param {number} [filterEqDuration] Filters by &#39;duration&#39;
         * @param {Date} [filterEqEndTime] Filters by &#39;endTime&#39;
         * @param {boolean} [filterEqHasChildren] Filters by &#39;hasChildren&#39;
         * @param {boolean} [filterEqHasRetries] Filters by &#39;hasRetries&#39;
         * @param {boolean} [filterEqHasStats] Filters by &#39;hasStats&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {boolean} [filterEqIgnoreAnalyzer] Filters by &#39;ignoreAnalyzer&#39;
         * @param {string} [filterEqIssueComment] Filters by &#39;issueComment&#39;
         * @param {number} [filterEqIssueGroupId] Filters by &#39;issueGroupId&#39;
         * @param {number} [filterEqIssueId] Filters by &#39;issueId&#39;
         * @param {string} [filterEqIssueType] Filters by &#39;issueType&#39;
         * @param {number} [filterEqIssueTypeId] Filters by &#39;issueTypeId&#39;
         * @param {string} [filterEqKey] Filters by &#39;key&#39;
         * @param {string} [filterEqLastModified] Filters by &#39;lastModified&#39;
         * @param {number} [filterEqLaunchId] Filters by &#39;launchId&#39;
         * @param {Array<any>} [filterEqLevelAttribute] Filters by &#39;levelAttribute&#39;
         * @param {string} [filterEqLocator] Filters by &#39;locator&#39;
         * @param {string} [filterEqMode] Filters by &#39;mode&#39;
         * @param {string} [filterEqName] Filters by &#39;name&#39;
         * @param {number} [filterEqParentId] Filters by &#39;parentId&#39;
         * @param {number} [filterEqParentId2] Filters by &#39;parentId&#39;
         * @param {number} [filterEqPath] Filters by &#39;path&#39;
         * @param {Array<any>} [filterEqPatternName] Filters by &#39;patternName&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {number} [filterEqRetryParentId] Filters by &#39;retryParentId&#39;
         * @param {Date} [filterEqStartTime] Filters by &#39;startTime&#39;
         * @param {number} [filterEqStatisticsdefectsautomationBugab001] Filters by &#39;statistics$defects$automation_bug$ab001&#39;
         * @param {number} [filterEqStatisticsdefectsnoDefectnd001] Filters by &#39;statistics$defects$no_defect$nd001&#39;
         * @param {number} [filterEqStatisticsdefectsproductBugpb001] Filters by &#39;statistics$defects$product_bug$pb001&#39;
         * @param {number} [filterEqStatisticsdefectssystemIssuesi001] Filters by &#39;statistics$defects$system_issue$si001&#39;
         * @param {number} [filterEqStatisticsdefectstoInvestigateti001] Filters by &#39;statistics$defects$to_investigate$ti001&#39;
         * @param {number} [filterEqStatisticsexecutionsfailed] Filters by &#39;statistics$executions$failed&#39;
         * @param {number} [filterEqStatisticsexecutionspassed] Filters by &#39;statistics$executions$passed&#39;
         * @param {number} [filterEqStatisticsexecutionsskipped] Filters by &#39;statistics$executions$skipped&#39;
         * @param {number} [filterEqStatisticsexecutionstotal] Filters by &#39;statistics$executions$total&#39;
         * @param {string} [filterEqStatus] Filters by &#39;status&#39;
         * @param {number} [filterEqTestCaseHash] Filters by &#39;testCaseHash&#39;
         * @param {string} [filterEqTestCaseId] Filters by &#39;testCaseId&#39;
         * @param {string} [filterEqTicketId] Filters by &#39;ticketId&#39;
         * @param {string} [filterEqType] Filters by &#39;type&#39;
         * @param {string} [filterEqUniqueId] Filters by &#39;uniqueId&#39;
         * @param {string} [filterEqUuid] Filters by &#39;uuid&#39;
         * @param {string} [filterEqValue] Filters by &#39;value&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestItemsV2UsingGET(params: any, projectName: string, filterEqAttributeKey?: Array<any>, filterEqAttributeValue?: Array<any>, filterEqAutoAnalyzed?: boolean, filterEqClusterId?: number, filterEqCompositeAttribute?: Array<string>, filterEqCompositeSystemAttribute?: Array<string>, filterEqDescription?: string, filterEqDuration?: number, filterEqEndTime?: Date, filterEqHasChildren?: boolean, filterEqHasRetries?: boolean, filterEqHasStats?: boolean, filterEqId?: number, filterEqIgnoreAnalyzer?: boolean, filterEqIssueComment?: string, filterEqIssueGroupId?: number, filterEqIssueId?: number, filterEqIssueType?: string, filterEqIssueTypeId?: number, filterEqKey?: string, filterEqLastModified?: string, filterEqLaunchId?: number, filterEqLevelAttribute?: Array<any>, filterEqLocator?: string, filterEqMode?: string, filterEqName?: string, filterEqParentId?: number, filterEqParentId2?: number, filterEqPath?: number, filterEqPatternName?: Array<any>, filterEqProjectId?: number, filterEqRetryParentId?: number, filterEqStartTime?: Date, filterEqStatisticsdefectsautomationBugab001?: number, filterEqStatisticsdefectsnoDefectnd001?: number, filterEqStatisticsdefectsproductBugpb001?: number, filterEqStatisticsdefectssystemIssuesi001?: number, filterEqStatisticsdefectstoInvestigateti001?: number, filterEqStatisticsexecutionsfailed?: number, filterEqStatisticsexecutionspassed?: number, filterEqStatisticsexecutionsskipped?: number, filterEqStatisticsexecutionstotal?: number, filterEqStatus?: string, filterEqTestCaseHash?: number, filterEqTestCaseId?: string, filterEqTicketId?: string, filterEqType?: string, filterEqUniqueId?: string, filterEqUuid?: string, filterEqValue?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any) {
            return TestItemControllerApiFp(configuration).getTestItemsV2UsingGET(params, projectName, filterEqAttributeKey, filterEqAttributeValue, filterEqAutoAnalyzed, filterEqClusterId, filterEqCompositeAttribute, filterEqCompositeSystemAttribute, filterEqDescription, filterEqDuration, filterEqEndTime, filterEqHasChildren, filterEqHasRetries, filterEqHasStats, filterEqId, filterEqIgnoreAnalyzer, filterEqIssueComment, filterEqIssueGroupId, filterEqIssueId, filterEqIssueType, filterEqIssueTypeId, filterEqKey, filterEqLastModified, filterEqLaunchId, filterEqLevelAttribute, filterEqLocator, filterEqMode, filterEqName, filterEqParentId, filterEqParentId2, filterEqPath, filterEqPatternName, filterEqProjectId, filterEqRetryParentId, filterEqStartTime, filterEqStatisticsdefectsautomationBugab001, filterEqStatisticsdefectsnoDefectnd001, filterEqStatisticsdefectsproductBugpb001, filterEqStatisticsdefectssystemIssuesi001, filterEqStatisticsdefectstoInvestigateti001, filterEqStatisticsexecutionsfailed, filterEqStatisticsexecutionspassed, filterEqStatisticsexecutionsskipped, filterEqStatisticsexecutionstotal, filterEqStatus, filterEqTestCaseHash, filterEqTestCaseId, filterEqTicketId, filterEqType, filterEqUniqueId, filterEqUuid, filterEqValue, pagePage, pageSize, pageSort, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get tickets that contains a term as a part inside for specified launch
         * @param {string} projectName projectName
         * @param {string} term term
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicketIdsForProjectUsingGET(projectName: string, term: string, options?: any) {
            return TestItemControllerApiFp(configuration).getTicketIdsForProjectUsingGET(projectName, term, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get tickets that contains a term as a part inside for specified launch
         * @param {number} launch launch
         * @param {string} projectName projectName
         * @param {string} term term
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicketIdsUsingGET(launch: number, projectName: string, term: string, options?: any) {
            return TestItemControllerApiFp(configuration).getTicketIdsUsingGET(launch, projectName, term, options)(fetch, basePath);
        },
        /**
         *
         * @summary Handle user choice from suggested items
         * @param {string} projectName projectName
         * @param {Array<SuggestInfo>} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleSuggestChooseUsingPUT(projectName: string, request: Array<SuggestInfo>, options?: any) {
            return TestItemControllerApiFp(configuration).handleSuggestChooseUsingPUT(projectName, request, options)(fetch, basePath);
        },
        /**
         *
         * @summary Attach external issue for specified test items
         * @param {string} projectName projectName
         * @param {LinkExternalIssueRQ} rq rq
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkExternalIssuesUsingPUT(projectName: string, rq: LinkExternalIssueRQ, options?: any) {
            return TestItemControllerApiFp(configuration).linkExternalIssuesUsingPUT(projectName, rq, options)(fetch, basePath);
        },
        /**
         *
         * @summary Start a child test item
         * @param {string} parentItem parentItem
         * @param {string} projectName projectName
         * @param {StartTestItemRQ} startTestItemRQ startTestItemRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startChildItemUsingPOST1(parentItem: string, projectName: string, startTestItemRQ: StartTestItemRQ, options?: any) {
            return TestItemControllerApiFp(configuration).startChildItemUsingPOST1(parentItem, projectName, startTestItemRQ, options)(fetch, basePath);
        },
        /**
         *
         * @summary Start a root test item
         * @param {string} projectName projectName
         * @param {StartTestItemRQ} startTestItemRQ startTestItemRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRootItemUsingPOST1(projectName: string, startTestItemRQ: StartTestItemRQ, options?: any) {
            return TestItemControllerApiFp(configuration).startRootItemUsingPOST1(projectName, startTestItemRQ, options)(fetch, basePath);
        },
        /**
         *
         * @summary Unlink external issue for specified test items
         * @param {string} projectName projectName
         * @param {UnlinkExternalIssueRQ} rq rq
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkExternalIssuesUsingPUT(projectName: string, rq: UnlinkExternalIssueRQ, options?: any) {
            return TestItemControllerApiFp(configuration).unlinkExternalIssuesUsingPUT(projectName, rq, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update test item
         * @param {number} itemId itemId
         * @param {string} projectName projectName
         * @param {UpdateTestItemRQ} rq rq
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTestItemUsingPUT(itemId: number, projectName: string, rq: UpdateTestItemRQ, options?: any) {
            return TestItemControllerApiFp(configuration).updateTestItemUsingPUT(itemId, projectName, rq, options)(fetch, basePath);
        },
    };
};

/**
 * TestItemControllerApi - object-oriented interface
 * @export
 * @class TestItemControllerApi
 * @extends {BaseAPI}
 */
export class TestItemControllerApi extends BaseAPI {
    /**
     *
     * @summary Bulk update attributes and description
     * @param {BulkInfoUpdateRQ} bulkInfoUpdateRQ bulkInfoUpdateRQ
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestItemControllerApi
     */
    public bulkUpdateUsingPUT1(bulkInfoUpdateRQ: BulkInfoUpdateRQ, projectName: string, options?: any) {
        return TestItemControllerApiFp(this.configuration).bulkUpdateUsingPUT1(bulkInfoUpdateRQ, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Update issues of specified test items
     * @param {string} projectName projectName
     * @param {DefineIssueRQ} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestItemControllerApi
     */
    public defineTestItemIssueTypeUsingPUT(projectName: string, request: DefineIssueRQ, options?: any) {
        return TestItemControllerApiFp(this.configuration).defineTestItemIssueTypeUsingPUT(projectName, request, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete test item
     * @param {number} itemId itemId
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestItemControllerApi
     */
    public deleteTestItemUsingDELETE(itemId: number, projectName: string, options?: any) {
        return TestItemControllerApiFp(this.configuration).deleteTestItemUsingDELETE(itemId, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete test items by specified ids
     * @param {Array<number>} ids ids
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestItemControllerApi
     */
    public deleteTestItemsUsingDELETE(ids: Array<number>, projectName: string, options?: any) {
        return TestItemControllerApiFp(this.configuration).deleteTestItemsUsingDELETE(ids, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Finish test item
     * @param {FinishTestItemRQ} finishExecutionRQ finishExecutionRQ
     * @param {string} projectName projectName
     * @param {string} testItemId testItemId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestItemControllerApi
     */
    public finishTestItemUsingPUT1(finishExecutionRQ: FinishTestItemRQ, projectName: string, testItemId: string, options?: any) {
        return TestItemControllerApiFp(this.configuration).finishTestItemUsingPUT1(finishExecutionRQ, projectName, testItemId, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get all unique attribute keys of specified launch
     * @param {string} filterCntAttributeKey filter.cnt.attributeKey
     * @param {number} filterId filterId
     * @param {string} projectName projectName
     * @param {boolean} [isLatest] isLatest
     * @param {number} [launchesLimit] launchesLimit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestItemControllerApi
     */
    public getAttributeKeysForProjectUsingGET(filterCntAttributeKey: string, filterId: number, projectName: string, isLatest?: boolean, launchesLimit?: number, options?: any) {
        return TestItemControllerApiFp(this.configuration).getAttributeKeysForProjectUsingGET(filterCntAttributeKey, filterId, projectName, isLatest, launchesLimit, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get all unique attribute keys of specified launch
     * @param {string} filterCntAttributeKey filter.cnt.attributeKey
     * @param {number} launch launch
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestItemControllerApi
     */
    public getAttributeKeysUsingGET1(filterCntAttributeKey: string, launch: number, projectName: string, options?: any) {
        return TestItemControllerApiFp(this.configuration).getAttributeKeysUsingGET1(filterCntAttributeKey, launch, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get all unique attribute keys of step items under specified project
     * @param {string} filterCntAttributeKey filter.cnt.attributeKey
     * @param {string} projectName projectName
     * @param {string} [filterEqName] filter.eq.name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestItemControllerApi
     */
    public getAttributeKeysUsingGET2(filterCntAttributeKey: string, projectName: string, filterEqName?: string, options?: any) {
        return TestItemControllerApiFp(this.configuration).getAttributeKeysUsingGET2(filterCntAttributeKey, projectName, filterEqName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get all unique attribute values of specified launch
     * @param {string} filterCntAttributeValue filter.cnt.attributeValue
     * @param {number} launch launch
     * @param {string} projectName projectName
     * @param {string} [filterEqAttributeKey] filter.eq.attributeKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestItemControllerApi
     */
    public getAttributeValuesUsingGET1(filterCntAttributeValue: string, launch: number, projectName: string, filterEqAttributeKey?: string, options?: any) {
        return TestItemControllerApiFp(this.configuration).getAttributeValuesUsingGET1(filterCntAttributeValue, launch, projectName, filterEqAttributeKey, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get all unique attribute values of step items under specified project
     * @param {string} filterCntAttributeValue filter.cnt.attributeValue
     * @param {string} projectName projectName
     * @param {string} [filterEqAttributeKey] filter.eq.attributeKey
     * @param {string} [filterEqName] filter.eq.name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestItemControllerApi
     */
    public getAttributeValuesUsingGET2(filterCntAttributeValue: string, projectName: string, filterEqAttributeKey?: string, filterEqName?: string, options?: any) {
        return TestItemControllerApiFp(this.configuration).getAttributeValuesUsingGET2(filterCntAttributeValue, projectName, filterEqAttributeKey, filterEqName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Load history of test items
     * @param {string} projectName projectName
     * @param {Array<any>} [filterEqAttributeKey] Filters by &#39;attributeKey&#39;
     * @param {Array<any>} [filterEqAttributeValue] Filters by &#39;attributeValue&#39;
     * @param {boolean} [filterEqAutoAnalyzed] Filters by &#39;autoAnalyzed&#39;
     * @param {number} [filterEqClusterId] Filters by &#39;clusterId&#39;
     * @param {Array<string>} [filterEqCompositeAttribute] Filters by &#39;compositeAttribute&#39;
     * @param {Array<string>} [filterEqCompositeSystemAttribute] Filters by &#39;compositeSystemAttribute&#39;
     * @param {string} [filterEqDescription] Filters by &#39;description&#39;
     * @param {number} [filterEqDuration] Filters by &#39;duration&#39;
     * @param {Date} [filterEqEndTime] Filters by &#39;endTime&#39;
     * @param {boolean} [filterEqHasChildren] Filters by &#39;hasChildren&#39;
     * @param {boolean} [filterEqHasRetries] Filters by &#39;hasRetries&#39;
     * @param {boolean} [filterEqHasStats] Filters by &#39;hasStats&#39;
     * @param {number} [filterEqId] Filters by &#39;id&#39;
     * @param {boolean} [filterEqIgnoreAnalyzer] Filters by &#39;ignoreAnalyzer&#39;
     * @param {string} [filterEqIssueComment] Filters by &#39;issueComment&#39;
     * @param {number} [filterEqIssueGroupId] Filters by &#39;issueGroupId&#39;
     * @param {number} [filterEqIssueId] Filters by &#39;issueId&#39;
     * @param {string} [filterEqIssueType] Filters by &#39;issueType&#39;
     * @param {number} [filterEqIssueTypeId] Filters by &#39;issueTypeId&#39;
     * @param {string} [filterEqKey] Filters by &#39;key&#39;
     * @param {string} [filterEqLastModified] Filters by &#39;lastModified&#39;
     * @param {number} [filterEqLaunchId] Filters by &#39;launchId&#39;
     * @param {Array<any>} [filterEqLevelAttribute] Filters by &#39;levelAttribute&#39;
     * @param {string} [filterEqLocator] Filters by &#39;locator&#39;
     * @param {string} [filterEqMode] Filters by &#39;mode&#39;
     * @param {string} [filterEqName] Filters by &#39;name&#39;
     * @param {number} [filterEqParentId] Filters by &#39;parentId&#39;
     * @param {number} [filterEqParentId2] Filters by &#39;parentId&#39;
     * @param {number} [filterEqPath] Filters by &#39;path&#39;
     * @param {Array<any>} [filterEqPatternName] Filters by &#39;patternName&#39;
     * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
     * @param {number} [filterEqRetryParentId] Filters by &#39;retryParentId&#39;
     * @param {Date} [filterEqStartTime] Filters by &#39;startTime&#39;
     * @param {number} [filterEqStatisticsdefectsautomationBugab001] Filters by &#39;statistics$defects$automation_bug$ab001&#39;
     * @param {number} [filterEqStatisticsdefectsnoDefectnd001] Filters by &#39;statistics$defects$no_defect$nd001&#39;
     * @param {number} [filterEqStatisticsdefectsproductBugpb001] Filters by &#39;statistics$defects$product_bug$pb001&#39;
     * @param {number} [filterEqStatisticsdefectssystemIssuesi001] Filters by &#39;statistics$defects$system_issue$si001&#39;
     * @param {number} [filterEqStatisticsdefectstoInvestigateti001] Filters by &#39;statistics$defects$to_investigate$ti001&#39;
     * @param {number} [filterEqStatisticsexecutionsfailed] Filters by &#39;statistics$executions$failed&#39;
     * @param {number} [filterEqStatisticsexecutionspassed] Filters by &#39;statistics$executions$passed&#39;
     * @param {number} [filterEqStatisticsexecutionsskipped] Filters by &#39;statistics$executions$skipped&#39;
     * @param {number} [filterEqStatisticsexecutionstotal] Filters by &#39;statistics$executions$total&#39;
     * @param {string} [filterEqStatus] Filters by &#39;status&#39;
     * @param {number} [filterEqTestCaseHash] Filters by &#39;testCaseHash&#39;
     * @param {string} [filterEqTestCaseId] Filters by &#39;testCaseId&#39;
     * @param {string} [filterEqTicketId] Filters by &#39;ticketId&#39;
     * @param {string} [filterEqType] Filters by &#39;type&#39;
     * @param {string} [filterEqUniqueId] Filters by &#39;uniqueId&#39;
     * @param {string} [filterEqUuid] Filters by &#39;uuid&#39;
     * @param {string} [filterEqValue] Filters by &#39;value&#39;
     * @param {number} [filterId] filterId
     * @param {number} [historyDepth] historyDepth
     * @param {boolean} [isLatest] isLatest
     * @param {number} [launchesLimit] launchesLimit
     * @param {number} [pagePage] Results page you want to retrieve (0..N)
     * @param {number} [pageSize] Number of records per page
     * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {string} [type] type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestItemControllerApi
     */
    public getItemsHistoryUsingGET(projectName: string, filterEqAttributeKey?: Array<any>, filterEqAttributeValue?: Array<any>, filterEqAutoAnalyzed?: boolean, filterEqClusterId?: number, filterEqCompositeAttribute?: Array<string>, filterEqCompositeSystemAttribute?: Array<string>, filterEqDescription?: string, filterEqDuration?: number, filterEqEndTime?: Date, filterEqHasChildren?: boolean, filterEqHasRetries?: boolean, filterEqHasStats?: boolean, filterEqId?: number, filterEqIgnoreAnalyzer?: boolean, filterEqIssueComment?: string, filterEqIssueGroupId?: number, filterEqIssueId?: number, filterEqIssueType?: string, filterEqIssueTypeId?: number, filterEqKey?: string, filterEqLastModified?: string, filterEqLaunchId?: number, filterEqLevelAttribute?: Array<any>, filterEqLocator?: string, filterEqMode?: string, filterEqName?: string, filterEqParentId?: number, filterEqParentId2?: number, filterEqPath?: number, filterEqPatternName?: Array<any>, filterEqProjectId?: number, filterEqRetryParentId?: number, filterEqStartTime?: Date, filterEqStatisticsdefectsautomationBugab001?: number, filterEqStatisticsdefectsnoDefectnd001?: number, filterEqStatisticsdefectsproductBugpb001?: number, filterEqStatisticsdefectssystemIssuesi001?: number, filterEqStatisticsdefectstoInvestigateti001?: number, filterEqStatisticsexecutionsfailed?: number, filterEqStatisticsexecutionspassed?: number, filterEqStatisticsexecutionsskipped?: number, filterEqStatisticsexecutionstotal?: number, filterEqStatus?: string, filterEqTestCaseHash?: number, filterEqTestCaseId?: string, filterEqTicketId?: string, filterEqType?: string, filterEqUniqueId?: string, filterEqUuid?: string, filterEqValue?: string, filterId?: number, historyDepth?: number, isLatest?: boolean, launchesLimit?: number, pagePage?: number, pageSize?: number, pageSort?: Array<string>, type?: string, options?: any) {
        return TestItemControllerApiFp(this.configuration).getItemsHistoryUsingGET(projectName, filterEqAttributeKey, filterEqAttributeValue, filterEqAutoAnalyzed, filterEqClusterId, filterEqCompositeAttribute, filterEqCompositeSystemAttribute, filterEqDescription, filterEqDuration, filterEqEndTime, filterEqHasChildren, filterEqHasRetries, filterEqHasStats, filterEqId, filterEqIgnoreAnalyzer, filterEqIssueComment, filterEqIssueGroupId, filterEqIssueId, filterEqIssueType, filterEqIssueTypeId, filterEqKey, filterEqLastModified, filterEqLaunchId, filterEqLevelAttribute, filterEqLocator, filterEqMode, filterEqName, filterEqParentId, filterEqParentId2, filterEqPath, filterEqPatternName, filterEqProjectId, filterEqRetryParentId, filterEqStartTime, filterEqStatisticsdefectsautomationBugab001, filterEqStatisticsdefectsnoDefectnd001, filterEqStatisticsdefectsproductBugpb001, filterEqStatisticsdefectssystemIssuesi001, filterEqStatisticsdefectstoInvestigateti001, filterEqStatisticsexecutionsfailed, filterEqStatisticsexecutionspassed, filterEqStatisticsexecutionsskipped, filterEqStatisticsexecutionstotal, filterEqStatus, filterEqTestCaseHash, filterEqTestCaseId, filterEqTicketId, filterEqType, filterEqUniqueId, filterEqUuid, filterEqValue, filterId, historyDepth, isLatest, launchesLimit, pagePage, pageSize, pageSort, type, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Search suggested items in analyzer for provided one
     * @param {number} clusterId clusterId
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestItemControllerApi
     */
    public getSuggestedClusterItemsUsingGET(clusterId: number, projectName: string, options?: any) {
        return TestItemControllerApiFp(this.configuration).getSuggestedClusterItemsUsingGET(clusterId, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Search suggested items in analyzer for provided one
     * @param {number} itemId itemId
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestItemControllerApi
     */
    public getSuggestedItemsUsingGET(itemId: number, projectName: string, options?: any) {
        return TestItemControllerApiFp(this.configuration).getSuggestedItemsUsingGET(itemId, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Find test item by UUID
     * @param {string} itemId itemId
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestItemControllerApi
     */
    public getTestItemByUuidUsingGET(itemId: string, projectName: string, options?: any) {
        return TestItemControllerApiFp(this.configuration).getTestItemByUuidUsingGET(itemId, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Find test item by ID
     * @param {string} itemId itemId
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestItemControllerApi
     */
    public getTestItemUsingGET(itemId: string, projectName: string, options?: any) {
        return TestItemControllerApiFp(this.configuration).getTestItemUsingGET(itemId, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get test items by specified ids
     * @param {Array<number>} ids ids
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestItemControllerApi
     */
    public getTestItemsUsingGET(ids: Array<number>, projectName: string, options?: any) {
        return TestItemControllerApiFp(this.configuration).getTestItemsUsingGET(ids, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Find accumulated statistics of items by specified filter
     * @param {any} params params
     * @param {string} projectName projectName
     * @param {Array<any>} [filterEqAttributeKey] Filters by &#39;attributeKey&#39;
     * @param {Array<any>} [filterEqAttributeValue] Filters by &#39;attributeValue&#39;
     * @param {boolean} [filterEqAutoAnalyzed] Filters by &#39;autoAnalyzed&#39;
     * @param {number} [filterEqClusterId] Filters by &#39;clusterId&#39;
     * @param {Array<string>} [filterEqCompositeAttribute] Filters by &#39;compositeAttribute&#39;
     * @param {Array<string>} [filterEqCompositeSystemAttribute] Filters by &#39;compositeSystemAttribute&#39;
     * @param {string} [filterEqDescription] Filters by &#39;description&#39;
     * @param {number} [filterEqDuration] Filters by &#39;duration&#39;
     * @param {Date} [filterEqEndTime] Filters by &#39;endTime&#39;
     * @param {boolean} [filterEqHasChildren] Filters by &#39;hasChildren&#39;
     * @param {boolean} [filterEqHasRetries] Filters by &#39;hasRetries&#39;
     * @param {boolean} [filterEqHasStats] Filters by &#39;hasStats&#39;
     * @param {number} [filterEqId] Filters by &#39;id&#39;
     * @param {boolean} [filterEqIgnoreAnalyzer] Filters by &#39;ignoreAnalyzer&#39;
     * @param {string} [filterEqIssueComment] Filters by &#39;issueComment&#39;
     * @param {number} [filterEqIssueGroupId] Filters by &#39;issueGroupId&#39;
     * @param {number} [filterEqIssueId] Filters by &#39;issueId&#39;
     * @param {string} [filterEqIssueType] Filters by &#39;issueType&#39;
     * @param {number} [filterEqIssueTypeId] Filters by &#39;issueTypeId&#39;
     * @param {string} [filterEqKey] Filters by &#39;key&#39;
     * @param {string} [filterEqLastModified] Filters by &#39;lastModified&#39;
     * @param {number} [filterEqLaunchId] Filters by &#39;launchId&#39;
     * @param {Array<any>} [filterEqLevelAttribute] Filters by &#39;levelAttribute&#39;
     * @param {string} [filterEqLocator] Filters by &#39;locator&#39;
     * @param {string} [filterEqMode] Filters by &#39;mode&#39;
     * @param {string} [filterEqName] Filters by &#39;name&#39;
     * @param {number} [filterEqParentId] Filters by &#39;parentId&#39;
     * @param {number} [filterEqParentId2] Filters by &#39;parentId&#39;
     * @param {number} [filterEqPath] Filters by &#39;path&#39;
     * @param {Array<any>} [filterEqPatternName] Filters by &#39;patternName&#39;
     * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
     * @param {number} [filterEqRetryParentId] Filters by &#39;retryParentId&#39;
     * @param {Date} [filterEqStartTime] Filters by &#39;startTime&#39;
     * @param {number} [filterEqStatisticsdefectsautomationBugab001] Filters by &#39;statistics$defects$automation_bug$ab001&#39;
     * @param {number} [filterEqStatisticsdefectsnoDefectnd001] Filters by &#39;statistics$defects$no_defect$nd001&#39;
     * @param {number} [filterEqStatisticsdefectsproductBugpb001] Filters by &#39;statistics$defects$product_bug$pb001&#39;
     * @param {number} [filterEqStatisticsdefectssystemIssuesi001] Filters by &#39;statistics$defects$system_issue$si001&#39;
     * @param {number} [filterEqStatisticsdefectstoInvestigateti001] Filters by &#39;statistics$defects$to_investigate$ti001&#39;
     * @param {number} [filterEqStatisticsexecutionsfailed] Filters by &#39;statistics$executions$failed&#39;
     * @param {number} [filterEqStatisticsexecutionspassed] Filters by &#39;statistics$executions$passed&#39;
     * @param {number} [filterEqStatisticsexecutionsskipped] Filters by &#39;statistics$executions$skipped&#39;
     * @param {number} [filterEqStatisticsexecutionstotal] Filters by &#39;statistics$executions$total&#39;
     * @param {string} [filterEqStatus] Filters by &#39;status&#39;
     * @param {number} [filterEqTestCaseHash] Filters by &#39;testCaseHash&#39;
     * @param {string} [filterEqTestCaseId] Filters by &#39;testCaseId&#39;
     * @param {string} [filterEqTicketId] Filters by &#39;ticketId&#39;
     * @param {string} [filterEqType] Filters by &#39;type&#39;
     * @param {string} [filterEqUniqueId] Filters by &#39;uniqueId&#39;
     * @param {string} [filterEqUuid] Filters by &#39;uuid&#39;
     * @param {string} [filterEqValue] Filters by &#39;value&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestItemControllerApi
     */
    public getTestItemsUsingGET1(params: any, projectName: string, filterEqAttributeKey?: Array<any>, filterEqAttributeValue?: Array<any>, filterEqAutoAnalyzed?: boolean, filterEqClusterId?: number, filterEqCompositeAttribute?: Array<string>, filterEqCompositeSystemAttribute?: Array<string>, filterEqDescription?: string, filterEqDuration?: number, filterEqEndTime?: Date, filterEqHasChildren?: boolean, filterEqHasRetries?: boolean, filterEqHasStats?: boolean, filterEqId?: number, filterEqIgnoreAnalyzer?: boolean, filterEqIssueComment?: string, filterEqIssueGroupId?: number, filterEqIssueId?: number, filterEqIssueType?: string, filterEqIssueTypeId?: number, filterEqKey?: string, filterEqLastModified?: string, filterEqLaunchId?: number, filterEqLevelAttribute?: Array<any>, filterEqLocator?: string, filterEqMode?: string, filterEqName?: string, filterEqParentId?: number, filterEqParentId2?: number, filterEqPath?: number, filterEqPatternName?: Array<any>, filterEqProjectId?: number, filterEqRetryParentId?: number, filterEqStartTime?: Date, filterEqStatisticsdefectsautomationBugab001?: number, filterEqStatisticsdefectsnoDefectnd001?: number, filterEqStatisticsdefectsproductBugpb001?: number, filterEqStatisticsdefectssystemIssuesi001?: number, filterEqStatisticsdefectstoInvestigateti001?: number, filterEqStatisticsexecutionsfailed?: number, filterEqStatisticsexecutionspassed?: number, filterEqStatisticsexecutionsskipped?: number, filterEqStatisticsexecutionstotal?: number, filterEqStatus?: string, filterEqTestCaseHash?: number, filterEqTestCaseId?: string, filterEqTicketId?: string, filterEqType?: string, filterEqUniqueId?: string, filterEqUuid?: string, filterEqValue?: string, options?: any) {
        return TestItemControllerApiFp(this.configuration).getTestItemsUsingGET1(params, projectName, filterEqAttributeKey, filterEqAttributeValue, filterEqAutoAnalyzed, filterEqClusterId, filterEqCompositeAttribute, filterEqCompositeSystemAttribute, filterEqDescription, filterEqDuration, filterEqEndTime, filterEqHasChildren, filterEqHasRetries, filterEqHasStats, filterEqId, filterEqIgnoreAnalyzer, filterEqIssueComment, filterEqIssueGroupId, filterEqIssueId, filterEqIssueType, filterEqIssueTypeId, filterEqKey, filterEqLastModified, filterEqLaunchId, filterEqLevelAttribute, filterEqLocator, filterEqMode, filterEqName, filterEqParentId, filterEqParentId2, filterEqPath, filterEqPatternName, filterEqProjectId, filterEqRetryParentId, filterEqStartTime, filterEqStatisticsdefectsautomationBugab001, filterEqStatisticsdefectsnoDefectnd001, filterEqStatisticsdefectsproductBugpb001, filterEqStatisticsdefectssystemIssuesi001, filterEqStatisticsdefectstoInvestigateti001, filterEqStatisticsexecutionsfailed, filterEqStatisticsexecutionspassed, filterEqStatisticsexecutionsskipped, filterEqStatisticsexecutionstotal, filterEqStatus, filterEqTestCaseHash, filterEqTestCaseId, filterEqTicketId, filterEqType, filterEqUniqueId, filterEqUuid, filterEqValue, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Find test items by specified filter
     * @param {string} projectName projectName
     * @param {Array<any>} [filterEqAttributeKey] Filters by &#39;attributeKey&#39;
     * @param {Array<any>} [filterEqAttributeValue] Filters by &#39;attributeValue&#39;
     * @param {boolean} [filterEqAutoAnalyzed] Filters by &#39;autoAnalyzed&#39;
     * @param {number} [filterEqClusterId] Filters by &#39;clusterId&#39;
     * @param {Array<string>} [filterEqCompositeAttribute] Filters by &#39;compositeAttribute&#39;
     * @param {Array<string>} [filterEqCompositeSystemAttribute] Filters by &#39;compositeSystemAttribute&#39;
     * @param {string} [filterEqDescription] Filters by &#39;description&#39;
     * @param {number} [filterEqDuration] Filters by &#39;duration&#39;
     * @param {Date} [filterEqEndTime] Filters by &#39;endTime&#39;
     * @param {boolean} [filterEqHasChildren] Filters by &#39;hasChildren&#39;
     * @param {boolean} [filterEqHasRetries] Filters by &#39;hasRetries&#39;
     * @param {boolean} [filterEqHasStats] Filters by &#39;hasStats&#39;
     * @param {number} [filterEqId] Filters by &#39;id&#39;
     * @param {boolean} [filterEqIgnoreAnalyzer] Filters by &#39;ignoreAnalyzer&#39;
     * @param {string} [filterEqIssueComment] Filters by &#39;issueComment&#39;
     * @param {number} [filterEqIssueGroupId] Filters by &#39;issueGroupId&#39;
     * @param {number} [filterEqIssueId] Filters by &#39;issueId&#39;
     * @param {string} [filterEqIssueType] Filters by &#39;issueType&#39;
     * @param {number} [filterEqIssueTypeId] Filters by &#39;issueTypeId&#39;
     * @param {string} [filterEqKey] Filters by &#39;key&#39;
     * @param {string} [filterEqLastModified] Filters by &#39;lastModified&#39;
     * @param {number} [filterEqLaunchId] Filters by &#39;launchId&#39;
     * @param {Array<any>} [filterEqLevelAttribute] Filters by &#39;levelAttribute&#39;
     * @param {string} [filterEqLocator] Filters by &#39;locator&#39;
     * @param {string} [filterEqMode] Filters by &#39;mode&#39;
     * @param {string} [filterEqName] Filters by &#39;name&#39;
     * @param {number} [filterEqParentId] Filters by &#39;parentId&#39;
     * @param {number} [filterEqParentId2] Filters by &#39;parentId&#39;
     * @param {number} [filterEqPath] Filters by &#39;path&#39;
     * @param {Array<any>} [filterEqPatternName] Filters by &#39;patternName&#39;
     * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
     * @param {number} [filterEqRetryParentId] Filters by &#39;retryParentId&#39;
     * @param {Date} [filterEqStartTime] Filters by &#39;startTime&#39;
     * @param {number} [filterEqStatisticsdefectsautomationBugab001] Filters by &#39;statistics$defects$automation_bug$ab001&#39;
     * @param {number} [filterEqStatisticsdefectsnoDefectnd001] Filters by &#39;statistics$defects$no_defect$nd001&#39;
     * @param {number} [filterEqStatisticsdefectsproductBugpb001] Filters by &#39;statistics$defects$product_bug$pb001&#39;
     * @param {number} [filterEqStatisticsdefectssystemIssuesi001] Filters by &#39;statistics$defects$system_issue$si001&#39;
     * @param {number} [filterEqStatisticsdefectstoInvestigateti001] Filters by &#39;statistics$defects$to_investigate$ti001&#39;
     * @param {number} [filterEqStatisticsexecutionsfailed] Filters by &#39;statistics$executions$failed&#39;
     * @param {number} [filterEqStatisticsexecutionspassed] Filters by &#39;statistics$executions$passed&#39;
     * @param {number} [filterEqStatisticsexecutionsskipped] Filters by &#39;statistics$executions$skipped&#39;
     * @param {number} [filterEqStatisticsexecutionstotal] Filters by &#39;statistics$executions$total&#39;
     * @param {string} [filterEqStatus] Filters by &#39;status&#39;
     * @param {number} [filterEqTestCaseHash] Filters by &#39;testCaseHash&#39;
     * @param {string} [filterEqTestCaseId] Filters by &#39;testCaseId&#39;
     * @param {string} [filterEqTicketId] Filters by &#39;ticketId&#39;
     * @param {string} [filterEqType] Filters by &#39;type&#39;
     * @param {string} [filterEqUniqueId] Filters by &#39;uniqueId&#39;
     * @param {string} [filterEqUuid] Filters by &#39;uuid&#39;
     * @param {string} [filterEqValue] Filters by &#39;value&#39;
     * @param {number} [filterId] filterId
     * @param {boolean} [isLatest] isLatest
     * @param {number} [launchesLimit] launchesLimit
     * @param {number} [pagePage] Results page you want to retrieve (0..N)
     * @param {number} [pageSize] Number of records per page
     * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestItemControllerApi
     */
    public getTestItemsUsingGET2(projectName: string, filterEqAttributeKey?: Array<any>, filterEqAttributeValue?: Array<any>, filterEqAutoAnalyzed?: boolean, filterEqClusterId?: number, filterEqCompositeAttribute?: Array<string>, filterEqCompositeSystemAttribute?: Array<string>, filterEqDescription?: string, filterEqDuration?: number, filterEqEndTime?: Date, filterEqHasChildren?: boolean, filterEqHasRetries?: boolean, filterEqHasStats?: boolean, filterEqId?: number, filterEqIgnoreAnalyzer?: boolean, filterEqIssueComment?: string, filterEqIssueGroupId?: number, filterEqIssueId?: number, filterEqIssueType?: string, filterEqIssueTypeId?: number, filterEqKey?: string, filterEqLastModified?: string, filterEqLaunchId?: number, filterEqLevelAttribute?: Array<any>, filterEqLocator?: string, filterEqMode?: string, filterEqName?: string, filterEqParentId?: number, filterEqParentId2?: number, filterEqPath?: number, filterEqPatternName?: Array<any>, filterEqProjectId?: number, filterEqRetryParentId?: number, filterEqStartTime?: Date, filterEqStatisticsdefectsautomationBugab001?: number, filterEqStatisticsdefectsnoDefectnd001?: number, filterEqStatisticsdefectsproductBugpb001?: number, filterEqStatisticsdefectssystemIssuesi001?: number, filterEqStatisticsdefectstoInvestigateti001?: number, filterEqStatisticsexecutionsfailed?: number, filterEqStatisticsexecutionspassed?: number, filterEqStatisticsexecutionsskipped?: number, filterEqStatisticsexecutionstotal?: number, filterEqStatus?: string, filterEqTestCaseHash?: number, filterEqTestCaseId?: string, filterEqTicketId?: string, filterEqType?: string, filterEqUniqueId?: string, filterEqUuid?: string, filterEqValue?: string, filterId?: number, isLatest?: boolean, launchesLimit?: number, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any) {
        return TestItemControllerApiFp(this.configuration).getTestItemsUsingGET2(projectName, filterEqAttributeKey, filterEqAttributeValue, filterEqAutoAnalyzed, filterEqClusterId, filterEqCompositeAttribute, filterEqCompositeSystemAttribute, filterEqDescription, filterEqDuration, filterEqEndTime, filterEqHasChildren, filterEqHasRetries, filterEqHasStats, filterEqId, filterEqIgnoreAnalyzer, filterEqIssueComment, filterEqIssueGroupId, filterEqIssueId, filterEqIssueType, filterEqIssueTypeId, filterEqKey, filterEqLastModified, filterEqLaunchId, filterEqLevelAttribute, filterEqLocator, filterEqMode, filterEqName, filterEqParentId, filterEqParentId2, filterEqPath, filterEqPatternName, filterEqProjectId, filterEqRetryParentId, filterEqStartTime, filterEqStatisticsdefectsautomationBugab001, filterEqStatisticsdefectsnoDefectnd001, filterEqStatisticsdefectsproductBugpb001, filterEqStatisticsdefectssystemIssuesi001, filterEqStatisticsdefectstoInvestigateti001, filterEqStatisticsexecutionsfailed, filterEqStatisticsexecutionspassed, filterEqStatisticsexecutionsskipped, filterEqStatisticsexecutionstotal, filterEqStatus, filterEqTestCaseHash, filterEqTestCaseId, filterEqTicketId, filterEqType, filterEqUniqueId, filterEqUuid, filterEqValue, filterId, isLatest, launchesLimit, pagePage, pageSize, pageSort, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Find test items by specified filter
     * @param {any} params params
     * @param {string} projectName projectName
     * @param {Array<any>} [filterEqAttributeKey] Filters by &#39;attributeKey&#39;
     * @param {Array<any>} [filterEqAttributeValue] Filters by &#39;attributeValue&#39;
     * @param {boolean} [filterEqAutoAnalyzed] Filters by &#39;autoAnalyzed&#39;
     * @param {number} [filterEqClusterId] Filters by &#39;clusterId&#39;
     * @param {Array<string>} [filterEqCompositeAttribute] Filters by &#39;compositeAttribute&#39;
     * @param {Array<string>} [filterEqCompositeSystemAttribute] Filters by &#39;compositeSystemAttribute&#39;
     * @param {string} [filterEqDescription] Filters by &#39;description&#39;
     * @param {number} [filterEqDuration] Filters by &#39;duration&#39;
     * @param {Date} [filterEqEndTime] Filters by &#39;endTime&#39;
     * @param {boolean} [filterEqHasChildren] Filters by &#39;hasChildren&#39;
     * @param {boolean} [filterEqHasRetries] Filters by &#39;hasRetries&#39;
     * @param {boolean} [filterEqHasStats] Filters by &#39;hasStats&#39;
     * @param {number} [filterEqId] Filters by &#39;id&#39;
     * @param {boolean} [filterEqIgnoreAnalyzer] Filters by &#39;ignoreAnalyzer&#39;
     * @param {string} [filterEqIssueComment] Filters by &#39;issueComment&#39;
     * @param {number} [filterEqIssueGroupId] Filters by &#39;issueGroupId&#39;
     * @param {number} [filterEqIssueId] Filters by &#39;issueId&#39;
     * @param {string} [filterEqIssueType] Filters by &#39;issueType&#39;
     * @param {number} [filterEqIssueTypeId] Filters by &#39;issueTypeId&#39;
     * @param {string} [filterEqKey] Filters by &#39;key&#39;
     * @param {string} [filterEqLastModified] Filters by &#39;lastModified&#39;
     * @param {number} [filterEqLaunchId] Filters by &#39;launchId&#39;
     * @param {Array<any>} [filterEqLevelAttribute] Filters by &#39;levelAttribute&#39;
     * @param {string} [filterEqLocator] Filters by &#39;locator&#39;
     * @param {string} [filterEqMode] Filters by &#39;mode&#39;
     * @param {string} [filterEqName] Filters by &#39;name&#39;
     * @param {number} [filterEqParentId] Filters by &#39;parentId&#39;
     * @param {number} [filterEqParentId2] Filters by &#39;parentId&#39;
     * @param {number} [filterEqPath] Filters by &#39;path&#39;
     * @param {Array<any>} [filterEqPatternName] Filters by &#39;patternName&#39;
     * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
     * @param {number} [filterEqRetryParentId] Filters by &#39;retryParentId&#39;
     * @param {Date} [filterEqStartTime] Filters by &#39;startTime&#39;
     * @param {number} [filterEqStatisticsdefectsautomationBugab001] Filters by &#39;statistics$defects$automation_bug$ab001&#39;
     * @param {number} [filterEqStatisticsdefectsnoDefectnd001] Filters by &#39;statistics$defects$no_defect$nd001&#39;
     * @param {number} [filterEqStatisticsdefectsproductBugpb001] Filters by &#39;statistics$defects$product_bug$pb001&#39;
     * @param {number} [filterEqStatisticsdefectssystemIssuesi001] Filters by &#39;statistics$defects$system_issue$si001&#39;
     * @param {number} [filterEqStatisticsdefectstoInvestigateti001] Filters by &#39;statistics$defects$to_investigate$ti001&#39;
     * @param {number} [filterEqStatisticsexecutionsfailed] Filters by &#39;statistics$executions$failed&#39;
     * @param {number} [filterEqStatisticsexecutionspassed] Filters by &#39;statistics$executions$passed&#39;
     * @param {number} [filterEqStatisticsexecutionsskipped] Filters by &#39;statistics$executions$skipped&#39;
     * @param {number} [filterEqStatisticsexecutionstotal] Filters by &#39;statistics$executions$total&#39;
     * @param {string} [filterEqStatus] Filters by &#39;status&#39;
     * @param {number} [filterEqTestCaseHash] Filters by &#39;testCaseHash&#39;
     * @param {string} [filterEqTestCaseId] Filters by &#39;testCaseId&#39;
     * @param {string} [filterEqTicketId] Filters by &#39;ticketId&#39;
     * @param {string} [filterEqType] Filters by &#39;type&#39;
     * @param {string} [filterEqUniqueId] Filters by &#39;uniqueId&#39;
     * @param {string} [filterEqUuid] Filters by &#39;uuid&#39;
     * @param {string} [filterEqValue] Filters by &#39;value&#39;
     * @param {number} [pagePage] Results page you want to retrieve (0..N)
     * @param {number} [pageSize] Number of records per page
     * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestItemControllerApi
     */
    public getTestItemsV2UsingGET(params: any, projectName: string, filterEqAttributeKey?: Array<any>, filterEqAttributeValue?: Array<any>, filterEqAutoAnalyzed?: boolean, filterEqClusterId?: number, filterEqCompositeAttribute?: Array<string>, filterEqCompositeSystemAttribute?: Array<string>, filterEqDescription?: string, filterEqDuration?: number, filterEqEndTime?: Date, filterEqHasChildren?: boolean, filterEqHasRetries?: boolean, filterEqHasStats?: boolean, filterEqId?: number, filterEqIgnoreAnalyzer?: boolean, filterEqIssueComment?: string, filterEqIssueGroupId?: number, filterEqIssueId?: number, filterEqIssueType?: string, filterEqIssueTypeId?: number, filterEqKey?: string, filterEqLastModified?: string, filterEqLaunchId?: number, filterEqLevelAttribute?: Array<any>, filterEqLocator?: string, filterEqMode?: string, filterEqName?: string, filterEqParentId?: number, filterEqParentId2?: number, filterEqPath?: number, filterEqPatternName?: Array<any>, filterEqProjectId?: number, filterEqRetryParentId?: number, filterEqStartTime?: Date, filterEqStatisticsdefectsautomationBugab001?: number, filterEqStatisticsdefectsnoDefectnd001?: number, filterEqStatisticsdefectsproductBugpb001?: number, filterEqStatisticsdefectssystemIssuesi001?: number, filterEqStatisticsdefectstoInvestigateti001?: number, filterEqStatisticsexecutionsfailed?: number, filterEqStatisticsexecutionspassed?: number, filterEqStatisticsexecutionsskipped?: number, filterEqStatisticsexecutionstotal?: number, filterEqStatus?: string, filterEqTestCaseHash?: number, filterEqTestCaseId?: string, filterEqTicketId?: string, filterEqType?: string, filterEqUniqueId?: string, filterEqUuid?: string, filterEqValue?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any) {
        return TestItemControllerApiFp(this.configuration).getTestItemsV2UsingGET(params, projectName, filterEqAttributeKey, filterEqAttributeValue, filterEqAutoAnalyzed, filterEqClusterId, filterEqCompositeAttribute, filterEqCompositeSystemAttribute, filterEqDescription, filterEqDuration, filterEqEndTime, filterEqHasChildren, filterEqHasRetries, filterEqHasStats, filterEqId, filterEqIgnoreAnalyzer, filterEqIssueComment, filterEqIssueGroupId, filterEqIssueId, filterEqIssueType, filterEqIssueTypeId, filterEqKey, filterEqLastModified, filterEqLaunchId, filterEqLevelAttribute, filterEqLocator, filterEqMode, filterEqName, filterEqParentId, filterEqParentId2, filterEqPath, filterEqPatternName, filterEqProjectId, filterEqRetryParentId, filterEqStartTime, filterEqStatisticsdefectsautomationBugab001, filterEqStatisticsdefectsnoDefectnd001, filterEqStatisticsdefectsproductBugpb001, filterEqStatisticsdefectssystemIssuesi001, filterEqStatisticsdefectstoInvestigateti001, filterEqStatisticsexecutionsfailed, filterEqStatisticsexecutionspassed, filterEqStatisticsexecutionsskipped, filterEqStatisticsexecutionstotal, filterEqStatus, filterEqTestCaseHash, filterEqTestCaseId, filterEqTicketId, filterEqType, filterEqUniqueId, filterEqUuid, filterEqValue, pagePage, pageSize, pageSort, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get tickets that contains a term as a part inside for specified launch
     * @param {string} projectName projectName
     * @param {string} term term
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestItemControllerApi
     */
    public getTicketIdsForProjectUsingGET(projectName: string, term: string, options?: any) {
        return TestItemControllerApiFp(this.configuration).getTicketIdsForProjectUsingGET(projectName, term, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get tickets that contains a term as a part inside for specified launch
     * @param {number} launch launch
     * @param {string} projectName projectName
     * @param {string} term term
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestItemControllerApi
     */
    public getTicketIdsUsingGET(launch: number, projectName: string, term: string, options?: any) {
        return TestItemControllerApiFp(this.configuration).getTicketIdsUsingGET(launch, projectName, term, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Handle user choice from suggested items
     * @param {string} projectName projectName
     * @param {Array<SuggestInfo>} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestItemControllerApi
     */
    public handleSuggestChooseUsingPUT(projectName: string, request: Array<SuggestInfo>, options?: any) {
        return TestItemControllerApiFp(this.configuration).handleSuggestChooseUsingPUT(projectName, request, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Attach external issue for specified test items
     * @param {string} projectName projectName
     * @param {LinkExternalIssueRQ} rq rq
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestItemControllerApi
     */
    public linkExternalIssuesUsingPUT(projectName: string, rq: LinkExternalIssueRQ, options?: any) {
        return TestItemControllerApiFp(this.configuration).linkExternalIssuesUsingPUT(projectName, rq, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Start a child test item
     * @param {string} parentItem parentItem
     * @param {string} projectName projectName
     * @param {StartTestItemRQ} startTestItemRQ startTestItemRQ
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestItemControllerApi
     */
    public startChildItemUsingPOST1(parentItem: string, projectName: string, startTestItemRQ: StartTestItemRQ, options?: any) {
        return TestItemControllerApiFp(this.configuration).startChildItemUsingPOST1(parentItem, projectName, startTestItemRQ, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Start a root test item
     * @param {string} projectName projectName
     * @param {StartTestItemRQ} startTestItemRQ startTestItemRQ
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestItemControllerApi
     */
    public startRootItemUsingPOST1(projectName: string, startTestItemRQ: StartTestItemRQ, options?: any) {
        return TestItemControllerApiFp(this.configuration).startRootItemUsingPOST1(projectName, startTestItemRQ, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Unlink external issue for specified test items
     * @param {string} projectName projectName
     * @param {UnlinkExternalIssueRQ} rq rq
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestItemControllerApi
     */
    public unlinkExternalIssuesUsingPUT(projectName: string, rq: UnlinkExternalIssueRQ, options?: any) {
        return TestItemControllerApiFp(this.configuration).unlinkExternalIssuesUsingPUT(projectName, rq, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Update test item
     * @param {number} itemId itemId
     * @param {string} projectName projectName
     * @param {UpdateTestItemRQ} rq rq
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestItemControllerApi
     */
    public updateTestItemUsingPUT(itemId: number, projectName: string, rq: UpdateTestItemRQ, options?: any) {
        return TestItemControllerApiFp(this.configuration).updateTestItemUsingPUT(itemId, projectName, rq, options)(this.fetch, this.basePath);
    }

}

/**
 * UserControllerApi - fetch parameter creator
 * @export
 */
export const UserControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Change own password
         * @param {ChangePasswordRQ} changePasswordRQ changePasswordRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePasswordUsingPOST1(changePasswordRQ: ChangePasswordRQ, options: any = {}): FetchArgs {
            // verify required parameter 'changePasswordRQ' is not null or undefined
            if (changePasswordRQ === null || changePasswordRQ === undefined) {
                throw new RequiredError('changePasswordRQ', 'Required parameter changePasswordRQ was null or undefined when calling changePasswordUsingPOST1.');
            }
            const localVarPath = `/users/password/change`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ChangePasswordRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(changePasswordRQ || {}) : (changePasswordRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create new Api Key for current user
         * @param {ApiKeyRQ} apiKeyRQ apiKeyRQ
         * @param {number} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKeyUsingPOST1(apiKeyRQ: ApiKeyRQ, userId: number, options: any = {}): FetchArgs {
            // verify required parameter 'apiKeyRQ' is not null or undefined
            if (apiKeyRQ === null || apiKeyRQ === undefined) {
                throw new RequiredError('apiKeyRQ', 'Required parameter apiKeyRQ was null or undefined when calling createApiKeyUsingPOST1.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId', 'Required parameter userId was null or undefined when calling createApiKeyUsingPOST1.');
            }
            const localVarPath = `/users/{userId}/api-keys`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ApiKeyRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(apiKeyRQ || {}) : (apiKeyRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Register invitation for user who will be created
         * @param {CreateUserRQ} createUserRQ createUserRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserBidUsingPOST1(createUserRQ: CreateUserRQ, options: any = {}): FetchArgs {
            // verify required parameter 'createUserRQ' is not null or undefined
            if (createUserRQ === null || createUserRQ === undefined) {
                throw new RequiredError('createUserRQ', 'Required parameter createUserRQ was null or undefined when calling createUserBidUsingPOST1.');
            }
            const localVarPath = `/users/bid`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateUserRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(createUserRQ || {}) : (createUserRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allowable only for users with administrator role
         * @summary Create specified user
         * @param {CreateUserRQFull} rq rq
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserByAdminUsingPOST1(rq: CreateUserRQFull, options: any = {}): FetchArgs {
            // verify required parameter 'rq' is not null or undefined
            if (rq === null || rq === undefined) {
                throw new RequiredError('rq', 'Required parameter rq was null or undefined when calling createUserByAdminUsingPOST1.');
            }
            const localVarPath = `/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateUserRQFull" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(rq || {}) : (rq || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Activate invitation and create user in system
         * @param {CreateUserRQConfirm} request request
         * @param {string} uuid uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserUsingPOST1(request: CreateUserRQConfirm, uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request', 'Required parameter request was null or undefined when calling createUserUsingPOST1.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid', 'Required parameter uuid was null or undefined when calling createUserUsingPOST1.');
            }
            const localVarPath = `/users/registration`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateUserRQConfirm" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete specified Api Key
         * @param {number} keyId keyId
         * @param {number} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKeyUsingDELETE1(keyId: number, userId: number, options: any = {}): FetchArgs {
            // verify required parameter 'keyId' is not null or undefined
            if (keyId === null || keyId === undefined) {
                throw new RequiredError('keyId', 'Required parameter keyId was null or undefined when calling deleteApiKeyUsingDELETE1.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId', 'Required parameter userId was null or undefined when calling deleteApiKeyUsingDELETE1.');
            }
            const localVarPath = `/users/{userId}/api-keys/{keyId}`
                .replace(`{${"keyId"}}`, encodeURIComponent(String(keyId)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'DELETE'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete specified user
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserUsingDELETE1(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling deleteUserUsingDELETE1.');
            }
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'DELETE'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete specified users by ids
         * @param {DeleteBulkRQ} deleteBulkRQ deleteBulkRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsersUsingDELETE1(deleteBulkRQ: DeleteBulkRQ, options: any = {}): FetchArgs {
            // verify required parameter 'deleteBulkRQ' is not null or undefined
            if (deleteBulkRQ === null || deleteBulkRQ === undefined) {
                throw new RequiredError('deleteBulkRQ', 'Required parameter deleteBulkRQ was null or undefined when calling deleteUsersUsingDELETE1.');
            }
            const localVarPath = `/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'DELETE'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DeleteBulkRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(deleteBulkRQ || {}) : (deleteBulkRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only for administrators and profile's owner
         * @summary Edit specified user
         * @param {EditUserRQ} editUserRQ editUserRQ
         * @param {string} login login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUserUsingPUT1(editUserRQ: EditUserRQ, login: string, options: any = {}): FetchArgs {
            // verify required parameter 'editUserRQ' is not null or undefined
            if (editUserRQ === null || editUserRQ === undefined) {
                throw new RequiredError('editUserRQ', 'Required parameter editUserRQ was null or undefined when calling editUserUsingPUT1.');
            }
            // verify required parameter 'login' is not null or undefined
            if (login === null || login === undefined) {
                throw new RequiredError('login', 'Required parameter login was null or undefined when calling editUserUsingPUT1.');
            }
            const localVarPath = `/users/{login}`
                .replace(`{${"login"}}`, encodeURIComponent(String(login)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'PUT'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EditUserRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(editUserRQ || {}) : (editUserRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allowable only for users with administrator role
         * @summary Exports information about all users
         * @param {string} [filterEqEmail] Filters by &#39;email&#39;
         * @param {boolean} [filterEqExpired] Filters by &#39;expired&#39;
         * @param {string} [filterEqFullName] Filters by &#39;fullName&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {number} [filterEqLastLogin] Filters by &#39;lastLogin&#39;
         * @param {Array<any>} [filterEqProject] Filters by &#39;project&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {string} [filterEqRole] Filters by &#39;role&#39;
         * @param {number} [filterEqSynchronizationDate] Filters by &#39;synchronizationDate&#39;
         * @param {string} [filterEqType] Filters by &#39;type&#39;
         * @param {string} [filterEqUser] Filters by &#39;user&#39;
         * @param {'csv'} [view] view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportUsingGET1(filterEqEmail?: string, filterEqExpired?: boolean, filterEqFullName?: string, filterEqId?: number, filterEqLastLogin?: number, filterEqProject?: Array<any>, filterEqProjectId?: number, filterEqRole?: string, filterEqSynchronizationDate?: number, filterEqType?: string, filterEqUser?: string, view?: 'csv', options: any = {}): FetchArgs {
            const localVarPath = `/users/export`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filterEqEmail !== undefined) {
                localVarQueryParameter['filter.eq.email'] = filterEqEmail;
            }

            if (filterEqExpired !== undefined) {
                localVarQueryParameter['filter.eq.expired'] = filterEqExpired;
            }

            if (filterEqFullName !== undefined) {
                localVarQueryParameter['filter.eq.fullName'] = filterEqFullName;
            }

            if (filterEqId !== undefined) {
                localVarQueryParameter['filter.eq.id'] = filterEqId;
            }

            if (filterEqLastLogin !== undefined) {
                localVarQueryParameter['filter.eq.lastLogin'] = filterEqLastLogin;
            }

            if (filterEqProject) {
                localVarQueryParameter['filter.eq.project'] = filterEqProject;
            }

            if (filterEqProjectId !== undefined) {
                localVarQueryParameter['filter.eq.projectId'] = filterEqProjectId;
            }

            if (filterEqRole !== undefined) {
                localVarQueryParameter['filter.eq.role'] = filterEqRole;
            }

            if (filterEqSynchronizationDate !== undefined) {
                localVarQueryParameter['filter.eq.synchronizationDate'] = filterEqSynchronizationDate;
            }

            if (filterEqType !== undefined) {
                localVarQueryParameter['filter.eq.type'] = filterEqType;
            }

            if (filterEqUser !== undefined) {
                localVarQueryParameter['filter.eq.user'] = filterEqUser;
            }

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary findUsers
         * @param {string} term term
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUsersUsingGET1(term: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'term' is not null or undefined
            if (term === null || term === undefined) {
                throw new RequiredError('term', 'Required parameter term was null or undefined when calling findUsersUsingGET1.');
            }
            const localVarPath = `/users/search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pagePage !== undefined) {
                localVarQueryParameter['page.page'] = pagePage;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page.size'] = pageSize;
            }

            if (pageSort) {
                localVarQueryParameter['page.sort'] = pageSort;
            }

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return information about current logged-in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyselfUsingGET2(options: any = {}): FetchArgs {
            const localVarPath = `/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return information about current logged-in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyselfUsingGET3(options: any = {}): FetchArgs {
            const localVarPath = `/users/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary getUserBidInfo
         * @param {string} uuid uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBidInfoUsingGET1(uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid', 'Required parameter uuid was null or undefined when calling getUserBidInfoUsingGET1.');
            }
            const localVarPath = `/users/registration`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary getUserProjects
         * @param {string} userName userName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserProjectsUsingGET1(userName: string, options: any = {}): FetchArgs {
            // verify required parameter 'userName' is not null or undefined
            if (userName === null || userName === undefined) {
                throw new RequiredError('userName', 'Required parameter userName was null or undefined when calling getUserProjectsUsingGET1.');
            }
            const localVarPath = `/users/{userName}/projects`
                .replace(`{${"userName"}}`, encodeURIComponent(String(userName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only for administrators and profile's owner
         * @summary Return information about specified user
         * @param {string} login login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserUsingGET1(login: string, options: any = {}): FetchArgs {
            // verify required parameter 'login' is not null or undefined
            if (login === null || login === undefined) {
                throw new RequiredError('login', 'Required parameter login was null or undefined when calling getUserUsingGET1.');
            }
            const localVarPath = `/users/{login}`
                .replace(`{${"login"}}`, encodeURIComponent(String(login)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get List of users Api Keys
         * @param {number} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersApiKeysUsingGET1(userId: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId', 'Required parameter userId was null or undefined when calling getUsersApiKeysUsingGET1.');
            }
            const localVarPath = `/users/{userId}/api-keys`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allowable only for users with administrator role
         * @summary Return information about all users
         * @param {string} [filterEqEmail] Filters by &#39;email&#39;
         * @param {boolean} [filterEqExpired] Filters by &#39;expired&#39;
         * @param {string} [filterEqFullName] Filters by &#39;fullName&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {number} [filterEqLastLogin] Filters by &#39;lastLogin&#39;
         * @param {Array<any>} [filterEqProject] Filters by &#39;project&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {string} [filterEqRole] Filters by &#39;role&#39;
         * @param {number} [filterEqSynchronizationDate] Filters by &#39;synchronizationDate&#39;
         * @param {string} [filterEqType] Filters by &#39;type&#39;
         * @param {string} [filterEqUser] Filters by &#39;user&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUsingGET1(filterEqEmail?: string, filterEqExpired?: boolean, filterEqFullName?: string, filterEqId?: number, filterEqLastLogin?: number, filterEqProject?: Array<any>, filterEqProjectId?: number, filterEqRole?: string, filterEqSynchronizationDate?: number, filterEqType?: string, filterEqUser?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/users/all`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filterEqEmail !== undefined) {
                localVarQueryParameter['filter.eq.email'] = filterEqEmail;
            }

            if (filterEqExpired !== undefined) {
                localVarQueryParameter['filter.eq.expired'] = filterEqExpired;
            }

            if (filterEqFullName !== undefined) {
                localVarQueryParameter['filter.eq.fullName'] = filterEqFullName;
            }

            if (filterEqId !== undefined) {
                localVarQueryParameter['filter.eq.id'] = filterEqId;
            }

            if (filterEqLastLogin !== undefined) {
                localVarQueryParameter['filter.eq.lastLogin'] = filterEqLastLogin;
            }

            if (filterEqProject) {
                localVarQueryParameter['filter.eq.project'] = filterEqProject;
            }

            if (filterEqProjectId !== undefined) {
                localVarQueryParameter['filter.eq.projectId'] = filterEqProjectId;
            }

            if (filterEqRole !== undefined) {
                localVarQueryParameter['filter.eq.role'] = filterEqRole;
            }

            if (filterEqSynchronizationDate !== undefined) {
                localVarQueryParameter['filter.eq.synchronizationDate'] = filterEqSynchronizationDate;
            }

            if (filterEqType !== undefined) {
                localVarQueryParameter['filter.eq.type'] = filterEqType;
            }

            if (filterEqUser !== undefined) {
                localVarQueryParameter['filter.eq.user'] = filterEqUser;
            }

            if (pagePage !== undefined) {
                localVarQueryParameter['page.page'] = pagePage;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page.size'] = pageSize;
            }

            if (pageSort) {
                localVarQueryParameter['page.sort'] = pageSort;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Check if a restore password bid exists
         * @param {string} uuid uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isRestorePasswordBidExistUsingGET1(uuid: string, options: any = {}): FetchArgs {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid', 'Required parameter uuid was null or undefined when calling isRestorePasswordBidExistUsingGET1.');
            }
            const localVarPath = `/users/password/reset/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Reset password
         * @param {ResetPasswordRQ} rq rq
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPasswordUsingPOST1(rq: ResetPasswordRQ, options: any = {}): FetchArgs {
            // verify required parameter 'rq' is not null or undefined
            if (rq === null || rq === undefined) {
                throw new RequiredError('rq', 'Required parameter rq was null or undefined when calling resetPasswordUsingPOST1.');
            }
            const localVarPath = `/users/password/reset`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ResetPasswordRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(rq || {}) : (rq || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a restore password request
         * @param {RestorePasswordRQ} rq rq
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restorePasswordUsingPOST1(rq: RestorePasswordRQ, options: any = {}): FetchArgs {
            // verify required parameter 'rq' is not null or undefined
            if (rq === null || rq === undefined) {
                throw new RequiredError('rq', 'Required parameter rq was null or undefined when calling restorePasswordUsingPOST1.');
            }
            const localVarPath = `/users/password/restore`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RestorePasswordRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(rq || {}) : (rq || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary validateInfo
         * @param {string} [email] email
         * @param {string} [username] username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateInfoUsingGET1(email?: string, username?: string, options: any = {}): FetchArgs {
            const localVarPath = `/users/registration/info`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserControllerApi - functional programming interface
 * @export
 */
export const UserControllerApiFp = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Change own password
         * @param {ChangePasswordRQ} changePasswordRQ changePasswordRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePasswordUsingPOST1(changePasswordRQ: ChangePasswordRQ, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = UserControllerApiFetchParamCreator(configuration).changePasswordUsingPOST1(changePasswordRQ, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create new Api Key for current user
         * @param {ApiKeyRQ} apiKeyRQ apiKeyRQ
         * @param {number} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKeyUsingPOST1(apiKeyRQ: ApiKeyRQ, userId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiKeyRS> {
            const localVarFetchArgs = UserControllerApiFetchParamCreator(configuration).createApiKeyUsingPOST1(apiKeyRQ, userId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Register invitation for user who will be created
         * @param {CreateUserRQ} createUserRQ createUserRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserBidUsingPOST1(createUserRQ: CreateUserRQ, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateUserBidRS> {
            const localVarFetchArgs = UserControllerApiFetchParamCreator(configuration).createUserBidUsingPOST1(createUserRQ, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Allowable only for users with administrator role
         * @summary Create specified user
         * @param {CreateUserRQFull} rq rq
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserByAdminUsingPOST1(rq: CreateUserRQFull, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateUserRS> {
            const localVarFetchArgs = UserControllerApiFetchParamCreator(configuration).createUserByAdminUsingPOST1(rq, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Activate invitation and create user in system
         * @param {CreateUserRQConfirm} request request
         * @param {string} uuid uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserUsingPOST1(request: CreateUserRQConfirm, uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateUserRS> {
            const localVarFetchArgs = UserControllerApiFetchParamCreator(configuration).createUserUsingPOST1(request, uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete specified Api Key
         * @param {number} keyId keyId
         * @param {number} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKeyUsingDELETE1(keyId: number, userId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = UserControllerApiFetchParamCreator(configuration).deleteApiKeyUsingDELETE1(keyId, userId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete specified user
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserUsingDELETE1(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = UserControllerApiFetchParamCreator(configuration).deleteUserUsingDELETE1(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete specified users by ids
         * @param {DeleteBulkRQ} deleteBulkRQ deleteBulkRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsersUsingDELETE1(deleteBulkRQ: DeleteBulkRQ, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeleteBulkRS> {
            const localVarFetchArgs = UserControllerApiFetchParamCreator(configuration).deleteUsersUsingDELETE1(deleteBulkRQ, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Only for administrators and profile's owner
         * @summary Edit specified user
         * @param {EditUserRQ} editUserRQ editUserRQ
         * @param {string} login login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUserUsingPUT1(editUserRQ: EditUserRQ, login: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = UserControllerApiFetchParamCreator(configuration).editUserUsingPUT1(editUserRQ, login, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Allowable only for users with administrator role
         * @summary Exports information about all users
         * @param {string} [filterEqEmail] Filters by &#39;email&#39;
         * @param {boolean} [filterEqExpired] Filters by &#39;expired&#39;
         * @param {string} [filterEqFullName] Filters by &#39;fullName&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {number} [filterEqLastLogin] Filters by &#39;lastLogin&#39;
         * @param {Array<any>} [filterEqProject] Filters by &#39;project&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {string} [filterEqRole] Filters by &#39;role&#39;
         * @param {number} [filterEqSynchronizationDate] Filters by &#39;synchronizationDate&#39;
         * @param {string} [filterEqType] Filters by &#39;type&#39;
         * @param {string} [filterEqUser] Filters by &#39;user&#39;
         * @param {'csv'} [view] view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportUsingGET1(filterEqEmail?: string, filterEqExpired?: boolean, filterEqFullName?: string, filterEqId?: number, filterEqLastLogin?: number, filterEqProject?: Array<any>, filterEqProjectId?: number, filterEqRole?: string, filterEqSynchronizationDate?: number, filterEqType?: string, filterEqUser?: string, view?: 'csv', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserControllerApiFetchParamCreator(configuration).exportUsingGET1(filterEqEmail, filterEqExpired, filterEqFullName, filterEqId, filterEqLastLogin, filterEqProject, filterEqProjectId, filterEqRole, filterEqSynchronizationDate, filterEqType, filterEqUser, view, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary findUsers
         * @param {string} term term
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUsersUsingGET1(term: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<IterableUserResource> {
            const localVarFetchArgs = UserControllerApiFetchParamCreator(configuration).findUsersUsingGET1(term, pagePage, pageSize, pageSort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Return information about current logged-in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyselfUsingGET2(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserResource> {
            const localVarFetchArgs = UserControllerApiFetchParamCreator(configuration).getMyselfUsingGET2(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Return information about current logged-in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyselfUsingGET3(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserResource> {
            const localVarFetchArgs = UserControllerApiFetchParamCreator(configuration).getMyselfUsingGET3(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary getUserBidInfo
         * @param {string} uuid uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBidInfoUsingGET1(uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserBidRS> {
            const localVarFetchArgs = UserControllerApiFetchParamCreator(configuration).getUserBidInfoUsingGET1(uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary getUserProjects
         * @param {string} userName userName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserProjectsUsingGET1(userName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{
            [key: string]: AssignedProject;
        }> {
            const localVarFetchArgs = UserControllerApiFetchParamCreator(configuration).getUserProjectsUsingGET1(userName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Only for administrators and profile's owner
         * @summary Return information about specified user
         * @param {string} login login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserUsingGET1(login: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserResource> {
            const localVarFetchArgs = UserControllerApiFetchParamCreator(configuration).getUserUsingGET1(login, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get List of users Api Keys
         * @param {number} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersApiKeysUsingGET1(userId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiKeysRS> {
            const localVarFetchArgs = UserControllerApiFetchParamCreator(configuration).getUsersApiKeysUsingGET1(userId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Allowable only for users with administrator role
         * @summary Return information about all users
         * @param {string} [filterEqEmail] Filters by &#39;email&#39;
         * @param {boolean} [filterEqExpired] Filters by &#39;expired&#39;
         * @param {string} [filterEqFullName] Filters by &#39;fullName&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {number} [filterEqLastLogin] Filters by &#39;lastLogin&#39;
         * @param {Array<any>} [filterEqProject] Filters by &#39;project&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {string} [filterEqRole] Filters by &#39;role&#39;
         * @param {number} [filterEqSynchronizationDate] Filters by &#39;synchronizationDate&#39;
         * @param {string} [filterEqType] Filters by &#39;type&#39;
         * @param {string} [filterEqUser] Filters by &#39;user&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUsingGET1(filterEqEmail?: string, filterEqExpired?: boolean, filterEqFullName?: string, filterEqId?: number, filterEqLastLogin?: number, filterEqProject?: Array<any>, filterEqProjectId?: number, filterEqRole?: string, filterEqSynchronizationDate?: number, filterEqType?: string, filterEqUser?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<IterableUserResource> {
            const localVarFetchArgs = UserControllerApiFetchParamCreator(configuration).getUsersUsingGET1(filterEqEmail, filterEqExpired, filterEqFullName, filterEqId, filterEqLastLogin, filterEqProject, filterEqProjectId, filterEqRole, filterEqSynchronizationDate, filterEqType, filterEqUser, pagePage, pageSize, pageSort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Check if a restore password bid exists
         * @param {string} uuid uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isRestorePasswordBidExistUsingGET1(uuid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<YesNoRS> {
            const localVarFetchArgs = UserControllerApiFetchParamCreator(configuration).isRestorePasswordBidExistUsingGET1(uuid, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Reset password
         * @param {ResetPasswordRQ} rq rq
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPasswordUsingPOST1(rq: ResetPasswordRQ, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = UserControllerApiFetchParamCreator(configuration).resetPasswordUsingPOST1(rq, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create a restore password request
         * @param {RestorePasswordRQ} rq rq
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restorePasswordUsingPOST1(rq: RestorePasswordRQ, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = UserControllerApiFetchParamCreator(configuration).restorePasswordUsingPOST1(rq, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary validateInfo
         * @param {string} [email] email
         * @param {string} [username] username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateInfoUsingGET1(email?: string, username?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<YesNoRS> {
            const localVarFetchArgs = UserControllerApiFetchParamCreator(configuration).validateInfoUsingGET1(email, username, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UserControllerApi - factory interface
 * @export
 */
export const UserControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Change own password
         * @param {ChangePasswordRQ} changePasswordRQ changePasswordRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePasswordUsingPOST1(changePasswordRQ: ChangePasswordRQ, options?: any) {
            return UserControllerApiFp(configuration).changePasswordUsingPOST1(changePasswordRQ, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create new Api Key for current user
         * @param {ApiKeyRQ} apiKeyRQ apiKeyRQ
         * @param {number} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKeyUsingPOST1(apiKeyRQ: ApiKeyRQ, userId: number, options?: any) {
            return UserControllerApiFp(configuration).createApiKeyUsingPOST1(apiKeyRQ, userId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Register invitation for user who will be created
         * @param {CreateUserRQ} createUserRQ createUserRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserBidUsingPOST1(createUserRQ: CreateUserRQ, options?: any) {
            return UserControllerApiFp(configuration).createUserBidUsingPOST1(createUserRQ, options)(fetch, basePath);
        },
        /**
         * Allowable only for users with administrator role
         * @summary Create specified user
         * @param {CreateUserRQFull} rq rq
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserByAdminUsingPOST1(rq: CreateUserRQFull, options?: any) {
            return UserControllerApiFp(configuration).createUserByAdminUsingPOST1(rq, options)(fetch, basePath);
        },
        /**
         *
         * @summary Activate invitation and create user in system
         * @param {CreateUserRQConfirm} request request
         * @param {string} uuid uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserUsingPOST1(request: CreateUserRQConfirm, uuid: string, options?: any) {
            return UserControllerApiFp(configuration).createUserUsingPOST1(request, uuid, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete specified Api Key
         * @param {number} keyId keyId
         * @param {number} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKeyUsingDELETE1(keyId: number, userId: number, options?: any) {
            return UserControllerApiFp(configuration).deleteApiKeyUsingDELETE1(keyId, userId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete specified user
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserUsingDELETE1(id: number, options?: any) {
            return UserControllerApiFp(configuration).deleteUserUsingDELETE1(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete specified users by ids
         * @param {DeleteBulkRQ} deleteBulkRQ deleteBulkRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsersUsingDELETE1(deleteBulkRQ: DeleteBulkRQ, options?: any) {
            return UserControllerApiFp(configuration).deleteUsersUsingDELETE1(deleteBulkRQ, options)(fetch, basePath);
        },
        /**
         * Only for administrators and profile's owner
         * @summary Edit specified user
         * @param {EditUserRQ} editUserRQ editUserRQ
         * @param {string} login login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editUserUsingPUT1(editUserRQ: EditUserRQ, login: string, options?: any) {
            return UserControllerApiFp(configuration).editUserUsingPUT1(editUserRQ, login, options)(fetch, basePath);
        },
        /**
         * Allowable only for users with administrator role
         * @summary Exports information about all users
         * @param {string} [filterEqEmail] Filters by &#39;email&#39;
         * @param {boolean} [filterEqExpired] Filters by &#39;expired&#39;
         * @param {string} [filterEqFullName] Filters by &#39;fullName&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {number} [filterEqLastLogin] Filters by &#39;lastLogin&#39;
         * @param {Array<any>} [filterEqProject] Filters by &#39;project&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {string} [filterEqRole] Filters by &#39;role&#39;
         * @param {number} [filterEqSynchronizationDate] Filters by &#39;synchronizationDate&#39;
         * @param {string} [filterEqType] Filters by &#39;type&#39;
         * @param {string} [filterEqUser] Filters by &#39;user&#39;
         * @param {'csv'} [view] view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportUsingGET1(filterEqEmail?: string, filterEqExpired?: boolean, filterEqFullName?: string, filterEqId?: number, filterEqLastLogin?: number, filterEqProject?: Array<any>, filterEqProjectId?: number, filterEqRole?: string, filterEqSynchronizationDate?: number, filterEqType?: string, filterEqUser?: string, view?: 'csv', options?: any) {
            return UserControllerApiFp(configuration).exportUsingGET1(filterEqEmail, filterEqExpired, filterEqFullName, filterEqId, filterEqLastLogin, filterEqProject, filterEqProjectId, filterEqRole, filterEqSynchronizationDate, filterEqType, filterEqUser, view, options)(fetch, basePath);
        },
        /**
         *
         * @summary findUsers
         * @param {string} term term
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUsersUsingGET1(term: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any) {
            return UserControllerApiFp(configuration).findUsersUsingGET1(term, pagePage, pageSize, pageSort, options)(fetch, basePath);
        },
        /**
         *
         * @summary Return information about current logged-in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyselfUsingGET2(options?: any) {
            return UserControllerApiFp(configuration).getMyselfUsingGET2(options)(fetch, basePath);
        },
        /**
         *
         * @summary Return information about current logged-in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyselfUsingGET3(options?: any) {
            return UserControllerApiFp(configuration).getMyselfUsingGET3(options)(fetch, basePath);
        },
        /**
         *
         * @summary getUserBidInfo
         * @param {string} uuid uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBidInfoUsingGET1(uuid: string, options?: any) {
            return UserControllerApiFp(configuration).getUserBidInfoUsingGET1(uuid, options)(fetch, basePath);
        },
        /**
         *
         * @summary getUserProjects
         * @param {string} userName userName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserProjectsUsingGET1(userName: string, options?: any) {
            return UserControllerApiFp(configuration).getUserProjectsUsingGET1(userName, options)(fetch, basePath);
        },
        /**
         * Only for administrators and profile's owner
         * @summary Return information about specified user
         * @param {string} login login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserUsingGET1(login: string, options?: any) {
            return UserControllerApiFp(configuration).getUserUsingGET1(login, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get List of users Api Keys
         * @param {number} userId userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersApiKeysUsingGET1(userId: number, options?: any) {
            return UserControllerApiFp(configuration).getUsersApiKeysUsingGET1(userId, options)(fetch, basePath);
        },
        /**
         * Allowable only for users with administrator role
         * @summary Return information about all users
         * @param {string} [filterEqEmail] Filters by &#39;email&#39;
         * @param {boolean} [filterEqExpired] Filters by &#39;expired&#39;
         * @param {string} [filterEqFullName] Filters by &#39;fullName&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {number} [filterEqLastLogin] Filters by &#39;lastLogin&#39;
         * @param {Array<any>} [filterEqProject] Filters by &#39;project&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {string} [filterEqRole] Filters by &#39;role&#39;
         * @param {number} [filterEqSynchronizationDate] Filters by &#39;synchronizationDate&#39;
         * @param {string} [filterEqType] Filters by &#39;type&#39;
         * @param {string} [filterEqUser] Filters by &#39;user&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUsingGET1(filterEqEmail?: string, filterEqExpired?: boolean, filterEqFullName?: string, filterEqId?: number, filterEqLastLogin?: number, filterEqProject?: Array<any>, filterEqProjectId?: number, filterEqRole?: string, filterEqSynchronizationDate?: number, filterEqType?: string, filterEqUser?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any) {
            return UserControllerApiFp(configuration).getUsersUsingGET1(filterEqEmail, filterEqExpired, filterEqFullName, filterEqId, filterEqLastLogin, filterEqProject, filterEqProjectId, filterEqRole, filterEqSynchronizationDate, filterEqType, filterEqUser, pagePage, pageSize, pageSort, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check if a restore password bid exists
         * @param {string} uuid uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isRestorePasswordBidExistUsingGET1(uuid: string, options?: any) {
            return UserControllerApiFp(configuration).isRestorePasswordBidExistUsingGET1(uuid, options)(fetch, basePath);
        },
        /**
         *
         * @summary Reset password
         * @param {ResetPasswordRQ} rq rq
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPasswordUsingPOST1(rq: ResetPasswordRQ, options?: any) {
            return UserControllerApiFp(configuration).resetPasswordUsingPOST1(rq, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a restore password request
         * @param {RestorePasswordRQ} rq rq
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restorePasswordUsingPOST1(rq: RestorePasswordRQ, options?: any) {
            return UserControllerApiFp(configuration).restorePasswordUsingPOST1(rq, options)(fetch, basePath);
        },
        /**
         *
         * @summary validateInfo
         * @param {string} [email] email
         * @param {string} [username] username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateInfoUsingGET1(email?: string, username?: string, options?: any) {
            return UserControllerApiFp(configuration).validateInfoUsingGET1(email, username, options)(fetch, basePath);
        },
    };
};

/**
 * UserControllerApi - object-oriented interface
 * @export
 * @class UserControllerApi
 * @extends {BaseAPI}
 */
export class UserControllerApi extends BaseAPI {
    /**
     *
     * @summary Change own password
     * @param {ChangePasswordRQ} changePasswordRQ changePasswordRQ
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public changePasswordUsingPOST1(changePasswordRQ: ChangePasswordRQ, options?: any) {
        return UserControllerApiFp(this.configuration).changePasswordUsingPOST1(changePasswordRQ, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Create new Api Key for current user
     * @param {ApiKeyRQ} apiKeyRQ apiKeyRQ
     * @param {number} userId userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public createApiKeyUsingPOST1(apiKeyRQ: ApiKeyRQ, userId: number, options?: any) {
        return UserControllerApiFp(this.configuration).createApiKeyUsingPOST1(apiKeyRQ, userId, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Register invitation for user who will be created
     * @param {CreateUserRQ} createUserRQ createUserRQ
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public createUserBidUsingPOST1(createUserRQ: CreateUserRQ, options?: any) {
        return UserControllerApiFp(this.configuration).createUserBidUsingPOST1(createUserRQ, options)(this.fetch, this.basePath);
    }

    /**
     * Allowable only for users with administrator role
     * @summary Create specified user
     * @param {CreateUserRQFull} rq rq
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public createUserByAdminUsingPOST1(rq: CreateUserRQFull, options?: any) {
        return UserControllerApiFp(this.configuration).createUserByAdminUsingPOST1(rq, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Activate invitation and create user in system
     * @param {CreateUserRQConfirm} request request
     * @param {string} uuid uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public createUserUsingPOST1(request: CreateUserRQConfirm, uuid: string, options?: any) {
        return UserControllerApiFp(this.configuration).createUserUsingPOST1(request, uuid, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete specified Api Key
     * @param {number} keyId keyId
     * @param {number} userId userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public deleteApiKeyUsingDELETE1(keyId: number, userId: number, options?: any) {
        return UserControllerApiFp(this.configuration).deleteApiKeyUsingDELETE1(keyId, userId, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete specified user
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public deleteUserUsingDELETE1(id: number, options?: any) {
        return UserControllerApiFp(this.configuration).deleteUserUsingDELETE1(id, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete specified users by ids
     * @param {DeleteBulkRQ} deleteBulkRQ deleteBulkRQ
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public deleteUsersUsingDELETE1(deleteBulkRQ: DeleteBulkRQ, options?: any) {
        return UserControllerApiFp(this.configuration).deleteUsersUsingDELETE1(deleteBulkRQ, options)(this.fetch, this.basePath);
    }

    /**
     * Only for administrators and profile's owner
     * @summary Edit specified user
     * @param {EditUserRQ} editUserRQ editUserRQ
     * @param {string} login login
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public editUserUsingPUT1(editUserRQ: EditUserRQ, login: string, options?: any) {
        return UserControllerApiFp(this.configuration).editUserUsingPUT1(editUserRQ, login, options)(this.fetch, this.basePath);
    }

    /**
     * Allowable only for users with administrator role
     * @summary Exports information about all users
     * @param {string} [filterEqEmail] Filters by &#39;email&#39;
     * @param {boolean} [filterEqExpired] Filters by &#39;expired&#39;
     * @param {string} [filterEqFullName] Filters by &#39;fullName&#39;
     * @param {number} [filterEqId] Filters by &#39;id&#39;
     * @param {number} [filterEqLastLogin] Filters by &#39;lastLogin&#39;
     * @param {Array<any>} [filterEqProject] Filters by &#39;project&#39;
     * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
     * @param {string} [filterEqRole] Filters by &#39;role&#39;
     * @param {number} [filterEqSynchronizationDate] Filters by &#39;synchronizationDate&#39;
     * @param {string} [filterEqType] Filters by &#39;type&#39;
     * @param {string} [filterEqUser] Filters by &#39;user&#39;
     * @param {'csv'} [view] view
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public exportUsingGET1(filterEqEmail?: string, filterEqExpired?: boolean, filterEqFullName?: string, filterEqId?: number, filterEqLastLogin?: number, filterEqProject?: Array<any>, filterEqProjectId?: number, filterEqRole?: string, filterEqSynchronizationDate?: number, filterEqType?: string, filterEqUser?: string, view?: 'csv', options?: any) {
        return UserControllerApiFp(this.configuration).exportUsingGET1(filterEqEmail, filterEqExpired, filterEqFullName, filterEqId, filterEqLastLogin, filterEqProject, filterEqProjectId, filterEqRole, filterEqSynchronizationDate, filterEqType, filterEqUser, view, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary findUsers
     * @param {string} term term
     * @param {number} [pagePage] Results page you want to retrieve (0..N)
     * @param {number} [pageSize] Number of records per page
     * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public findUsersUsingGET1(term: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any) {
        return UserControllerApiFp(this.configuration).findUsersUsingGET1(term, pagePage, pageSize, pageSort, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Return information about current logged-in user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getMyselfUsingGET2(options?: any) {
        return UserControllerApiFp(this.configuration).getMyselfUsingGET2(options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Return information about current logged-in user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getMyselfUsingGET3(options?: any) {
        return UserControllerApiFp(this.configuration).getMyselfUsingGET3(options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary getUserBidInfo
     * @param {string} uuid uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getUserBidInfoUsingGET1(uuid: string, options?: any) {
        return UserControllerApiFp(this.configuration).getUserBidInfoUsingGET1(uuid, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary getUserProjects
     * @param {string} userName userName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getUserProjectsUsingGET1(userName: string, options?: any) {
        return UserControllerApiFp(this.configuration).getUserProjectsUsingGET1(userName, options)(this.fetch, this.basePath);
    }

    /**
     * Only for administrators and profile's owner
     * @summary Return information about specified user
     * @param {string} login login
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getUserUsingGET1(login: string, options?: any) {
        return UserControllerApiFp(this.configuration).getUserUsingGET1(login, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get List of users Api Keys
     * @param {number} userId userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getUsersApiKeysUsingGET1(userId: number, options?: any) {
        return UserControllerApiFp(this.configuration).getUsersApiKeysUsingGET1(userId, options)(this.fetch, this.basePath);
    }

    /**
     * Allowable only for users with administrator role
     * @summary Return information about all users
     * @param {string} [filterEqEmail] Filters by &#39;email&#39;
     * @param {boolean} [filterEqExpired] Filters by &#39;expired&#39;
     * @param {string} [filterEqFullName] Filters by &#39;fullName&#39;
     * @param {number} [filterEqId] Filters by &#39;id&#39;
     * @param {number} [filterEqLastLogin] Filters by &#39;lastLogin&#39;
     * @param {Array<any>} [filterEqProject] Filters by &#39;project&#39;
     * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
     * @param {string} [filterEqRole] Filters by &#39;role&#39;
     * @param {number} [filterEqSynchronizationDate] Filters by &#39;synchronizationDate&#39;
     * @param {string} [filterEqType] Filters by &#39;type&#39;
     * @param {string} [filterEqUser] Filters by &#39;user&#39;
     * @param {number} [pagePage] Results page you want to retrieve (0..N)
     * @param {number} [pageSize] Number of records per page
     * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getUsersUsingGET1(filterEqEmail?: string, filterEqExpired?: boolean, filterEqFullName?: string, filterEqId?: number, filterEqLastLogin?: number, filterEqProject?: Array<any>, filterEqProjectId?: number, filterEqRole?: string, filterEqSynchronizationDate?: number, filterEqType?: string, filterEqUser?: string, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any) {
        return UserControllerApiFp(this.configuration).getUsersUsingGET1(filterEqEmail, filterEqExpired, filterEqFullName, filterEqId, filterEqLastLogin, filterEqProject, filterEqProjectId, filterEqRole, filterEqSynchronizationDate, filterEqType, filterEqUser, pagePage, pageSize, pageSort, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Check if a restore password bid exists
     * @param {string} uuid uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public isRestorePasswordBidExistUsingGET1(uuid: string, options?: any) {
        return UserControllerApiFp(this.configuration).isRestorePasswordBidExistUsingGET1(uuid, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Reset password
     * @param {ResetPasswordRQ} rq rq
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public resetPasswordUsingPOST1(rq: ResetPasswordRQ, options?: any) {
        return UserControllerApiFp(this.configuration).resetPasswordUsingPOST1(rq, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Create a restore password request
     * @param {RestorePasswordRQ} rq rq
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public restorePasswordUsingPOST1(rq: RestorePasswordRQ, options?: any) {
        return UserControllerApiFp(this.configuration).restorePasswordUsingPOST1(rq, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary validateInfo
     * @param {string} [email] email
     * @param {string} [username] username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public validateInfoUsingGET1(email?: string, username?: string, options?: any) {
        return UserControllerApiFp(this.configuration).validateInfoUsingGET1(email, username, options)(this.fetch, this.basePath);
    }

}

/**
 * UserFilterControllerApi - fetch parameter creator
 * @export
 */
export const UserFilterControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create user filter
         * @param {UpdateUserFilterRQ} createFilterRQ createFilterRQ
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFilterUsingPOST(createFilterRQ: UpdateUserFilterRQ, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'createFilterRQ' is not null or undefined
            if (createFilterRQ === null || createFilterRQ === undefined) {
                throw new RequiredError('createFilterRQ', 'Required parameter createFilterRQ was null or undefined when calling createFilterUsingPOST.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling createFilterUsingPOST.');
            }
            const localVarPath = `/v1/{projectName}/filter`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateUserFilterRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(createFilterRQ || {}) : (createFilterRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete specified user filter by id
         * @param {number} filterId filterId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFilterUsingDELETE(filterId: number, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'filterId' is not null or undefined
            if (filterId === null || filterId === undefined) {
                throw new RequiredError('filterId', 'Required parameter filterId was null or undefined when calling deleteFilterUsingDELETE.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling deleteFilterUsingDELETE.');
            }
            const localVarPath = `/v1/{projectName}/filter/{filterId}`
                .replace(`{${"filterId"}}`, encodeURIComponent(String(filterId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'DELETE'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get available filter names
         * @param {string} projectName projectName
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {string} [filterEqName] Filters by &#39;name&#39;
         * @param {string} [filterEqOwner] Filters by &#39;owner&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllFiltersNamesUsingGET(projectName: string, filterEqId?: number, filterEqName?: string, filterEqOwner?: string, filterEqProjectId?: number, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getAllFiltersNamesUsingGET.');
            }
            const localVarPath = `/v1/{projectName}/filter/names`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filterEqId !== undefined) {
                localVarQueryParameter['filter.eq.id'] = filterEqId;
            }

            if (filterEqName !== undefined) {
                localVarQueryParameter['filter.eq.name'] = filterEqName;
            }

            if (filterEqOwner !== undefined) {
                localVarQueryParameter['filter.eq.owner'] = filterEqOwner;
            }

            if (filterEqProjectId !== undefined) {
                localVarQueryParameter['filter.eq.projectId'] = filterEqProjectId;
            }

            if (pagePage !== undefined) {
                localVarQueryParameter['page.page'] = pagePage;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page.size'] = pageSize;
            }

            if (pageSort) {
                localVarQueryParameter['page.sort'] = pageSort;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get filters
         * @param {string} projectName projectName
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {string} [filterEqName] Filters by &#39;name&#39;
         * @param {string} [filterEqOwner] Filters by &#39;owner&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllFiltersUsingGET(projectName: string, filterEqId?: number, filterEqName?: string, filterEqOwner?: string, filterEqProjectId?: number, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getAllFiltersUsingGET.');
            }
            const localVarPath = `/v1/{projectName}/filter`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filterEqId !== undefined) {
                localVarQueryParameter['filter.eq.id'] = filterEqId;
            }

            if (filterEqName !== undefined) {
                localVarQueryParameter['filter.eq.name'] = filterEqName;
            }

            if (filterEqOwner !== undefined) {
                localVarQueryParameter['filter.eq.owner'] = filterEqOwner;
            }

            if (filterEqProjectId !== undefined) {
                localVarQueryParameter['filter.eq.projectId'] = filterEqProjectId;
            }

            if (pagePage !== undefined) {
                localVarQueryParameter['page.page'] = pagePage;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page.size'] = pageSize;
            }

            if (pageSort) {
                localVarQueryParameter['page.sort'] = pageSort;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get specified user filter by id
         * @param {number} filterId filterId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilterUsingGET(filterId: number, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'filterId' is not null or undefined
            if (filterId === null || filterId === undefined) {
                throw new RequiredError('filterId', 'Required parameter filterId was null or undefined when calling getFilterUsingGET.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getFilterUsingGET.');
            }
            const localVarPath = `/v1/{projectName}/filter/{filterId}`
                .replace(`{${"filterId"}}`, encodeURIComponent(String(filterId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get list of specified user filters
         * @param {Array<number>} ids ids
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFiltersUsingGET(ids: Array<number>, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'ids' is not null or undefined
            if (ids === null || ids === undefined) {
                throw new RequiredError('ids', 'Required parameter ids was null or undefined when calling getUserFiltersUsingGET.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getUserFiltersUsingGET.');
            }
            const localVarPath = `/v1/{projectName}/filter/filters`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update specified user filter
         * @param {number} filterId filterId
         * @param {string} projectName projectName
         * @param {UpdateUserFilterRQ} updateRQ updateRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserFilterUsingPUT(filterId: number, projectName: string, updateRQ: UpdateUserFilterRQ, options: any = {}): FetchArgs {
            // verify required parameter 'filterId' is not null or undefined
            if (filterId === null || filterId === undefined) {
                throw new RequiredError('filterId', 'Required parameter filterId was null or undefined when calling updateUserFilterUsingPUT.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling updateUserFilterUsingPUT.');
            }
            // verify required parameter 'updateRQ' is not null or undefined
            if (updateRQ === null || updateRQ === undefined) {
                throw new RequiredError('updateRQ', 'Required parameter updateRQ was null or undefined when calling updateUserFilterUsingPUT.');
            }
            const localVarPath = `/v1/{projectName}/filter/{filterId}`
                .replace(`{${"filterId"}}`, encodeURIComponent(String(filterId)))
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'PUT'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateUserFilterRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(updateRQ || {}) : (updateRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update list of user filters
         * @param {string} projectName projectName
         * @param {CollectionsRQBulkUpdateFilterRQ} updateRQ updateRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserFiltersUsingPUT(projectName: string, updateRQ: CollectionsRQBulkUpdateFilterRQ, options: any = {}): FetchArgs {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling updateUserFiltersUsingPUT.');
            }
            // verify required parameter 'updateRQ' is not null or undefined
            if (updateRQ === null || updateRQ === undefined) {
                throw new RequiredError('updateRQ', 'Required parameter updateRQ was null or undefined when calling updateUserFiltersUsingPUT.');
            }
            const localVarPath = `/v1/{projectName}/filter`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'PUT'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CollectionsRQBulkUpdateFilterRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(updateRQ || {}) : (updateRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserFilterControllerApi - functional programming interface
 * @export
 */
export const UserFilterControllerApiFp = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create user filter
         * @param {UpdateUserFilterRQ} createFilterRQ createFilterRQ
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFilterUsingPOST(createFilterRQ: UpdateUserFilterRQ, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EntryCreatedRS> {
            const localVarFetchArgs = UserFilterControllerApiFetchParamCreator(configuration).createFilterUsingPOST(createFilterRQ, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete specified user filter by id
         * @param {number} filterId filterId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFilterUsingDELETE(filterId: number, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = UserFilterControllerApiFetchParamCreator(configuration).deleteFilterUsingDELETE(filterId, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get available filter names
         * @param {string} projectName projectName
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {string} [filterEqName] Filters by &#39;name&#39;
         * @param {string} [filterEqOwner] Filters by &#39;owner&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllFiltersNamesUsingGET(projectName: string, filterEqId?: number, filterEqName?: string, filterEqOwner?: string, filterEqProjectId?: number, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<IterableOwnedEntityResource> {
            const localVarFetchArgs = UserFilterControllerApiFetchParamCreator(configuration).getAllFiltersNamesUsingGET(projectName, filterEqId, filterEqName, filterEqOwner, filterEqProjectId, pagePage, pageSize, pageSort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get filters
         * @param {string} projectName projectName
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {string} [filterEqName] Filters by &#39;name&#39;
         * @param {string} [filterEqOwner] Filters by &#39;owner&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllFiltersUsingGET(projectName: string, filterEqId?: number, filterEqName?: string, filterEqOwner?: string, filterEqProjectId?: number, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<IterableUserFilterResource> {
            const localVarFetchArgs = UserFilterControllerApiFetchParamCreator(configuration).getAllFiltersUsingGET(projectName, filterEqId, filterEqName, filterEqOwner, filterEqProjectId, pagePage, pageSize, pageSort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get specified user filter by id
         * @param {number} filterId filterId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilterUsingGET(filterId: number, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserFilterResource> {
            const localVarFetchArgs = UserFilterControllerApiFetchParamCreator(configuration).getFilterUsingGET(filterId, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get list of specified user filters
         * @param {Array<number>} ids ids
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFiltersUsingGET(ids: Array<number>, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserFilterResource>> {
            const localVarFetchArgs = UserFilterControllerApiFetchParamCreator(configuration).getUserFiltersUsingGET(ids, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update specified user filter
         * @param {number} filterId filterId
         * @param {string} projectName projectName
         * @param {UpdateUserFilterRQ} updateRQ updateRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserFilterUsingPUT(filterId: number, projectName: string, updateRQ: UpdateUserFilterRQ, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = UserFilterControllerApiFetchParamCreator(configuration).updateUserFilterUsingPUT(filterId, projectName, updateRQ, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update list of user filters
         * @param {string} projectName projectName
         * @param {CollectionsRQBulkUpdateFilterRQ} updateRQ updateRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserFiltersUsingPUT(projectName: string, updateRQ: CollectionsRQBulkUpdateFilterRQ, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<OperationCompletionRS>> {
            const localVarFetchArgs = UserFilterControllerApiFetchParamCreator(configuration).updateUserFiltersUsingPUT(projectName, updateRQ, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UserFilterControllerApi - factory interface
 * @export
 */
export const UserFilterControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Create user filter
         * @param {UpdateUserFilterRQ} createFilterRQ createFilterRQ
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFilterUsingPOST(createFilterRQ: UpdateUserFilterRQ, projectName: string, options?: any) {
            return UserFilterControllerApiFp(configuration).createFilterUsingPOST(createFilterRQ, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete specified user filter by id
         * @param {number} filterId filterId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFilterUsingDELETE(filterId: number, projectName: string, options?: any) {
            return UserFilterControllerApiFp(configuration).deleteFilterUsingDELETE(filterId, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get available filter names
         * @param {string} projectName projectName
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {string} [filterEqName] Filters by &#39;name&#39;
         * @param {string} [filterEqOwner] Filters by &#39;owner&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllFiltersNamesUsingGET(projectName: string, filterEqId?: number, filterEqName?: string, filterEqOwner?: string, filterEqProjectId?: number, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any) {
            return UserFilterControllerApiFp(configuration).getAllFiltersNamesUsingGET(projectName, filterEqId, filterEqName, filterEqOwner, filterEqProjectId, pagePage, pageSize, pageSort, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get filters
         * @param {string} projectName projectName
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {string} [filterEqName] Filters by &#39;name&#39;
         * @param {string} [filterEqOwner] Filters by &#39;owner&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllFiltersUsingGET(projectName: string, filterEqId?: number, filterEqName?: string, filterEqOwner?: string, filterEqProjectId?: number, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any) {
            return UserFilterControllerApiFp(configuration).getAllFiltersUsingGET(projectName, filterEqId, filterEqName, filterEqOwner, filterEqProjectId, pagePage, pageSize, pageSort, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get specified user filter by id
         * @param {number} filterId filterId
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilterUsingGET(filterId: number, projectName: string, options?: any) {
            return UserFilterControllerApiFp(configuration).getFilterUsingGET(filterId, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get list of specified user filters
         * @param {Array<number>} ids ids
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFiltersUsingGET(ids: Array<number>, projectName: string, options?: any) {
            return UserFilterControllerApiFp(configuration).getUserFiltersUsingGET(ids, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update specified user filter
         * @param {number} filterId filterId
         * @param {string} projectName projectName
         * @param {UpdateUserFilterRQ} updateRQ updateRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserFilterUsingPUT(filterId: number, projectName: string, updateRQ: UpdateUserFilterRQ, options?: any) {
            return UserFilterControllerApiFp(configuration).updateUserFilterUsingPUT(filterId, projectName, updateRQ, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update list of user filters
         * @param {string} projectName projectName
         * @param {CollectionsRQBulkUpdateFilterRQ} updateRQ updateRQ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserFiltersUsingPUT(projectName: string, updateRQ: CollectionsRQBulkUpdateFilterRQ, options?: any) {
            return UserFilterControllerApiFp(configuration).updateUserFiltersUsingPUT(projectName, updateRQ, options)(fetch, basePath);
        },
    };
};

/**
 * UserFilterControllerApi - object-oriented interface
 * @export
 * @class UserFilterControllerApi
 * @extends {BaseAPI}
 */
export class UserFilterControllerApi extends BaseAPI {
    /**
     *
     * @summary Create user filter
     * @param {UpdateUserFilterRQ} createFilterRQ createFilterRQ
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserFilterControllerApi
     */
    public createFilterUsingPOST(createFilterRQ: UpdateUserFilterRQ, projectName: string, options?: any) {
        return UserFilterControllerApiFp(this.configuration).createFilterUsingPOST(createFilterRQ, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete specified user filter by id
     * @param {number} filterId filterId
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserFilterControllerApi
     */
    public deleteFilterUsingDELETE(filterId: number, projectName: string, options?: any) {
        return UserFilterControllerApiFp(this.configuration).deleteFilterUsingDELETE(filterId, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get available filter names
     * @param {string} projectName projectName
     * @param {number} [filterEqId] Filters by &#39;id&#39;
     * @param {string} [filterEqName] Filters by &#39;name&#39;
     * @param {string} [filterEqOwner] Filters by &#39;owner&#39;
     * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
     * @param {number} [pagePage] Results page you want to retrieve (0..N)
     * @param {number} [pageSize] Number of records per page
     * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserFilterControllerApi
     */
    public getAllFiltersNamesUsingGET(projectName: string, filterEqId?: number, filterEqName?: string, filterEqOwner?: string, filterEqProjectId?: number, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any) {
        return UserFilterControllerApiFp(this.configuration).getAllFiltersNamesUsingGET(projectName, filterEqId, filterEqName, filterEqOwner, filterEqProjectId, pagePage, pageSize, pageSort, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get filters
     * @param {string} projectName projectName
     * @param {number} [filterEqId] Filters by &#39;id&#39;
     * @param {string} [filterEqName] Filters by &#39;name&#39;
     * @param {string} [filterEqOwner] Filters by &#39;owner&#39;
     * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
     * @param {number} [pagePage] Results page you want to retrieve (0..N)
     * @param {number} [pageSize] Number of records per page
     * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserFilterControllerApi
     */
    public getAllFiltersUsingGET(projectName: string, filterEqId?: number, filterEqName?: string, filterEqOwner?: string, filterEqProjectId?: number, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any) {
        return UserFilterControllerApiFp(this.configuration).getAllFiltersUsingGET(projectName, filterEqId, filterEqName, filterEqOwner, filterEqProjectId, pagePage, pageSize, pageSort, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get specified user filter by id
     * @param {number} filterId filterId
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserFilterControllerApi
     */
    public getFilterUsingGET(filterId: number, projectName: string, options?: any) {
        return UserFilterControllerApiFp(this.configuration).getFilterUsingGET(filterId, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get list of specified user filters
     * @param {Array<number>} ids ids
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserFilterControllerApi
     */
    public getUserFiltersUsingGET(ids: Array<number>, projectName: string, options?: any) {
        return UserFilterControllerApiFp(this.configuration).getUserFiltersUsingGET(ids, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Update specified user filter
     * @param {number} filterId filterId
     * @param {string} projectName projectName
     * @param {UpdateUserFilterRQ} updateRQ updateRQ
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserFilterControllerApi
     */
    public updateUserFilterUsingPUT(filterId: number, projectName: string, updateRQ: UpdateUserFilterRQ, options?: any) {
        return UserFilterControllerApiFp(this.configuration).updateUserFilterUsingPUT(filterId, projectName, updateRQ, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Update list of user filters
     * @param {string} projectName projectName
     * @param {CollectionsRQBulkUpdateFilterRQ} updateRQ updateRQ
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserFilterControllerApi
     */
    public updateUserFiltersUsingPUT(projectName: string, updateRQ: CollectionsRQBulkUpdateFilterRQ, options?: any) {
        return UserFilterControllerApiFp(this.configuration).updateUserFiltersUsingPUT(projectName, updateRQ, options)(this.fetch, this.basePath);
    }

}

/**
 * WidgetControllerApi - fetch parameter creator
 * @export
 */
export const WidgetControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a new widget
         * @param {WidgetRQ} createWidget createWidget
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWidgetUsingPOST(createWidget: WidgetRQ, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'createWidget' is not null or undefined
            if (createWidget === null || createWidget === undefined) {
                throw new RequiredError('createWidget', 'Required parameter createWidget was null or undefined when calling createWidgetUsingPOST.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling createWidgetUsingPOST.');
            }
            const localVarPath = `/v1/{projectName}/widget`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WidgetRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(createWidget || {}) : (createWidget || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Load all widget names which belong to a user
         * @param {string} projectName projectName
         * @param {string} [filterEqDescription] Filters by &#39;description&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {string} [filterEqName] Filters by &#39;name&#39;
         * @param {string} [filterEqOwner] Filters by &#39;owner&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWidgetNamesUsingGET(projectName: string, filterEqDescription?: string, filterEqId?: number, filterEqName?: string, filterEqOwner?: string, filterEqProjectId?: number, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getWidgetNamesUsingGET.');
            }
            const localVarPath = `/v1/{projectName}/widget/names/all`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filterEqDescription !== undefined) {
                localVarQueryParameter['filter.eq.description'] = filterEqDescription;
            }

            if (filterEqId !== undefined) {
                localVarQueryParameter['filter.eq.id'] = filterEqId;
            }

            if (filterEqName !== undefined) {
                localVarQueryParameter['filter.eq.name'] = filterEqName;
            }

            if (filterEqOwner !== undefined) {
                localVarQueryParameter['filter.eq.owner'] = filterEqOwner;
            }

            if (filterEqProjectId !== undefined) {
                localVarQueryParameter['filter.eq.projectId'] = filterEqProjectId;
            }

            if (pagePage !== undefined) {
                localVarQueryParameter['page.page'] = pagePage;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page.size'] = pageSize;
            }

            if (pageSort) {
                localVarQueryParameter['page.sort'] = pageSort;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get widget preview
         * @param {WidgetPreviewRQ} previewRQ previewRQ
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWidgetPreviewUsingPOST(previewRQ: WidgetPreviewRQ, projectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'previewRQ' is not null or undefined
            if (previewRQ === null || previewRQ === undefined) {
                throw new RequiredError('previewRQ', 'Required parameter previewRQ was null or undefined when calling getWidgetPreviewUsingPOST.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getWidgetPreviewUsingPOST.');
            }
            const localVarPath = `/v1/{projectName}/widget/preview`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'POST'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WidgetPreviewRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(previewRQ || {}) : (previewRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get multilevel widget by ID
         * @param {any} params params
         * @param {string} projectName projectName
         * @param {number} widgetId widgetId
         * @param {Array<string>} [attributes] attributes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWidgetUsingGET(params: any, projectName: string, widgetId: number, attributes?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'params' is not null or undefined
            if (params === null || params === undefined) {
                throw new RequiredError('params', 'Required parameter params was null or undefined when calling getWidgetUsingGET.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getWidgetUsingGET.');
            }
            // verify required parameter 'widgetId' is not null or undefined
            if (widgetId === null || widgetId === undefined) {
                throw new RequiredError('widgetId', 'Required parameter widgetId was null or undefined when calling getWidgetUsingGET.');
            }
            const localVarPath = `/v1/{projectName}/widget/multilevel/{widgetId}`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)))
                .replace(`{${"widgetId"}}`, encodeURIComponent(String(widgetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (attributes) {
                localVarQueryParameter['attributes'] = attributes;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get widget by ID
         * @param {string} projectName projectName
         * @param {number} widgetId widgetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWidgetUsingGET1(projectName: string, widgetId: number, options: any = {}): FetchArgs {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling getWidgetUsingGET1.');
            }
            // verify required parameter 'widgetId' is not null or undefined
            if (widgetId === null || widgetId === undefined) {
                throw new RequiredError('widgetId', 'Required parameter widgetId was null or undefined when calling getWidgetUsingGET1.');
            }
            const localVarPath = `/v1/{projectName}/widget/{widgetId}`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)))
                .replace(`{${"widgetId"}}`, encodeURIComponent(String(widgetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'GET'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update specified widget
         * @param {string} projectName projectName
         * @param {WidgetRQ} updateRQ updateRQ
         * @param {number} widgetId widgetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWidgetUsingPUT(projectName: string, updateRQ: WidgetRQ, widgetId: number, options: any = {}): FetchArgs {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName', 'Required parameter projectName was null or undefined when calling updateWidgetUsingPUT.');
            }
            // verify required parameter 'updateRQ' is not null or undefined
            if (updateRQ === null || updateRQ === undefined) {
                throw new RequiredError('updateRQ', 'Required parameter updateRQ was null or undefined when calling updateWidgetUsingPUT.');
            }
            // verify required parameter 'widgetId' is not null or undefined
            if (widgetId === null || widgetId === undefined) {
                throw new RequiredError('widgetId', 'Required parameter widgetId was null or undefined when calling updateWidgetUsingPUT.');
            }
            const localVarPath = `/v1/{projectName}/widget/{widgetId}`
                .replace(`{${"projectName"}}`, encodeURIComponent(String(projectName)))
                .replace(`{${"widgetId"}}`, encodeURIComponent(String(widgetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({method: 'PUT'}, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WidgetRQ" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(updateRQ || {}) : (updateRQ || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WidgetControllerApi - functional programming interface
 * @export
 */
export const WidgetControllerApiFp = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a new widget
         * @param {WidgetRQ} createWidget createWidget
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWidgetUsingPOST(createWidget: WidgetRQ, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EntryCreatedRS> {
            const localVarFetchArgs = WidgetControllerApiFetchParamCreator(configuration).createWidgetUsingPOST(createWidget, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Load all widget names which belong to a user
         * @param {string} projectName projectName
         * @param {string} [filterEqDescription] Filters by &#39;description&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {string} [filterEqName] Filters by &#39;name&#39;
         * @param {string} [filterEqOwner] Filters by &#39;owner&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWidgetNamesUsingGET(projectName: string, filterEqDescription?: string, filterEqId?: number, filterEqName?: string, filterEqOwner?: string, filterEqProjectId?: number, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Iterableobject> {
            const localVarFetchArgs = WidgetControllerApiFetchParamCreator(configuration).getWidgetNamesUsingGET(projectName, filterEqDescription, filterEqId, filterEqName, filterEqOwner, filterEqProjectId, pagePage, pageSize, pageSort, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get widget preview
         * @param {WidgetPreviewRQ} previewRQ previewRQ
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWidgetPreviewUsingPOST(previewRQ: WidgetPreviewRQ, projectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = WidgetControllerApiFetchParamCreator(configuration).getWidgetPreviewUsingPOST(previewRQ, projectName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get multilevel widget by ID
         * @param {any} params params
         * @param {string} projectName projectName
         * @param {number} widgetId widgetId
         * @param {Array<string>} [attributes] attributes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWidgetUsingGET(params: any, projectName: string, widgetId: number, attributes?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WidgetResource> {
            const localVarFetchArgs = WidgetControllerApiFetchParamCreator(configuration).getWidgetUsingGET(params, projectName, widgetId, attributes, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get widget by ID
         * @param {string} projectName projectName
         * @param {number} widgetId widgetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWidgetUsingGET1(projectName: string, widgetId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WidgetResource> {
            const localVarFetchArgs = WidgetControllerApiFetchParamCreator(configuration).getWidgetUsingGET1(projectName, widgetId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update specified widget
         * @param {string} projectName projectName
         * @param {WidgetRQ} updateRQ updateRQ
         * @param {number} widgetId widgetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWidgetUsingPUT(projectName: string, updateRQ: WidgetRQ, widgetId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OperationCompletionRS> {
            const localVarFetchArgs = WidgetControllerApiFetchParamCreator(configuration).updateWidgetUsingPUT(projectName, updateRQ, widgetId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * WidgetControllerApi - factory interface
 * @export
 */
export const WidgetControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Create a new widget
         * @param {WidgetRQ} createWidget createWidget
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWidgetUsingPOST(createWidget: WidgetRQ, projectName: string, options?: any) {
            return WidgetControllerApiFp(configuration).createWidgetUsingPOST(createWidget, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Load all widget names which belong to a user
         * @param {string} projectName projectName
         * @param {string} [filterEqDescription] Filters by &#39;description&#39;
         * @param {number} [filterEqId] Filters by &#39;id&#39;
         * @param {string} [filterEqName] Filters by &#39;name&#39;
         * @param {string} [filterEqOwner] Filters by &#39;owner&#39;
         * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
         * @param {number} [pagePage] Results page you want to retrieve (0..N)
         * @param {number} [pageSize] Number of records per page
         * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWidgetNamesUsingGET(projectName: string, filterEqDescription?: string, filterEqId?: number, filterEqName?: string, filterEqOwner?: string, filterEqProjectId?: number, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any) {
            return WidgetControllerApiFp(configuration).getWidgetNamesUsingGET(projectName, filterEqDescription, filterEqId, filterEqName, filterEqOwner, filterEqProjectId, pagePage, pageSize, pageSort, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get widget preview
         * @param {WidgetPreviewRQ} previewRQ previewRQ
         * @param {string} projectName projectName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWidgetPreviewUsingPOST(previewRQ: WidgetPreviewRQ, projectName: string, options?: any) {
            return WidgetControllerApiFp(configuration).getWidgetPreviewUsingPOST(previewRQ, projectName, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get multilevel widget by ID
         * @param {any} params params
         * @param {string} projectName projectName
         * @param {number} widgetId widgetId
         * @param {Array<string>} [attributes] attributes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWidgetUsingGET(params: any, projectName: string, widgetId: number, attributes?: Array<string>, options?: any) {
            return WidgetControllerApiFp(configuration).getWidgetUsingGET(params, projectName, widgetId, attributes, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get widget by ID
         * @param {string} projectName projectName
         * @param {number} widgetId widgetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWidgetUsingGET1(projectName: string, widgetId: number, options?: any) {
            return WidgetControllerApiFp(configuration).getWidgetUsingGET1(projectName, widgetId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update specified widget
         * @param {string} projectName projectName
         * @param {WidgetRQ} updateRQ updateRQ
         * @param {number} widgetId widgetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWidgetUsingPUT(projectName: string, updateRQ: WidgetRQ, widgetId: number, options?: any) {
            return WidgetControllerApiFp(configuration).updateWidgetUsingPUT(projectName, updateRQ, widgetId, options)(fetch, basePath);
        },
    };
};

/**
 * WidgetControllerApi - object-oriented interface
 * @export
 * @class WidgetControllerApi
 * @extends {BaseAPI}
 */
export class WidgetControllerApi extends BaseAPI {
    /**
     *
     * @summary Create a new widget
     * @param {WidgetRQ} createWidget createWidget
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WidgetControllerApi
     */
    public createWidgetUsingPOST(createWidget: WidgetRQ, projectName: string, options?: any) {
        return WidgetControllerApiFp(this.configuration).createWidgetUsingPOST(createWidget, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Load all widget names which belong to a user
     * @param {string} projectName projectName
     * @param {string} [filterEqDescription] Filters by &#39;description&#39;
     * @param {number} [filterEqId] Filters by &#39;id&#39;
     * @param {string} [filterEqName] Filters by &#39;name&#39;
     * @param {string} [filterEqOwner] Filters by &#39;owner&#39;
     * @param {number} [filterEqProjectId] Filters by &#39;projectId&#39;
     * @param {number} [pagePage] Results page you want to retrieve (0..N)
     * @param {number} [pageSize] Number of records per page
     * @param {Array<string>} [pageSort] Sorting criteria in the format: property, (asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WidgetControllerApi
     */
    public getWidgetNamesUsingGET(projectName: string, filterEqDescription?: string, filterEqId?: number, filterEqName?: string, filterEqOwner?: string, filterEqProjectId?: number, pagePage?: number, pageSize?: number, pageSort?: Array<string>, options?: any) {
        return WidgetControllerApiFp(this.configuration).getWidgetNamesUsingGET(projectName, filterEqDescription, filterEqId, filterEqName, filterEqOwner, filterEqProjectId, pagePage, pageSize, pageSort, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get widget preview
     * @param {WidgetPreviewRQ} previewRQ previewRQ
     * @param {string} projectName projectName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WidgetControllerApi
     */
    public getWidgetPreviewUsingPOST(previewRQ: WidgetPreviewRQ, projectName: string, options?: any) {
        return WidgetControllerApiFp(this.configuration).getWidgetPreviewUsingPOST(previewRQ, projectName, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get multilevel widget by ID
     * @param {any} params params
     * @param {string} projectName projectName
     * @param {number} widgetId widgetId
     * @param {Array<string>} [attributes] attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WidgetControllerApi
     */
    public getWidgetUsingGET(params: any, projectName: string, widgetId: number, attributes?: Array<string>, options?: any) {
        return WidgetControllerApiFp(this.configuration).getWidgetUsingGET(params, projectName, widgetId, attributes, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get widget by ID
     * @param {string} projectName projectName
     * @param {number} widgetId widgetId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WidgetControllerApi
     */
    public getWidgetUsingGET1(projectName: string, widgetId: number, options?: any) {
        return WidgetControllerApiFp(this.configuration).getWidgetUsingGET1(projectName, widgetId, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Update specified widget
     * @param {string} projectName projectName
     * @param {WidgetRQ} updateRQ updateRQ
     * @param {number} widgetId widgetId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WidgetControllerApi
     */
    public updateWidgetUsingPUT(projectName: string, updateRQ: WidgetRQ, widgetId: number, options?: any) {
        return WidgetControllerApiFp(this.configuration).updateWidgetUsingPUT(projectName, updateRQ, widgetId, options)(this.fetch, this.basePath);
    }

}

